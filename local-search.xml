<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcode：1143.最长公共子序列</title>
    <link href="/2021/02/15/Leetcode%201143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/02/15/Leetcode%201143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>注：两个字符串的「公共子序列」（Longest Common Subsequence，简称 LCS）是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p><pre><code>示例 1:输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。示例 2:输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。示例 3:输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>遇到子序列相关的问题，可以往动态规划上考虑。这道题让我们在<strong>两个字符串</strong>中寻找共同拥有的最长子序列，因此很容易想到用二维动态规划来解决。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义$dp[i][j]$为：$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度。</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>根据上述dp数组的定义，可以写出如下Base Case：</p><ul><li>i为0时，str1[0…i-1]不构成一个字符串，因此不存在与str2的公共子序列，因此dp[0][j]为0</li><li>j为0时，str2[0…j-1]不构成一个字符串，因此不存在于str1的公共子序列，因此dp[i][0]为0</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><p>当str1遍历到i - 1，str2遍历到j - 1时，即要求$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度时，需要考虑以下的几种情况：</p><ul><li><p>如果str1[i - 1]与str2[j - 1]相等，那么肯定要将其放入str1[0…i−1]和str2[0…j−1]的LCS当中，有了这个字符，LCS的长度就会加1，因此<br>$$dp[i][j] = dp[i - 1][j - 1] + 1$$</p></li><li><p>如果str1[i - 1]与str2[j - 1]不等，则又会分为以下的三种情况：</p><ul><li><p>str1[i - 1]与str2[j - 1]都不放入LCS当中，那么LCS的长度不会产生变化，即dp[i][j] = dp[i - 1][j - 1]</p></li><li><p>str1[i - 1]放入LCS中，但str2[j - 1]不放。这时dp[i][j] = dp[i][j - 1]</p></li><li><p>str1[i - 1]不放入LCS中，但str2[j - 1]放。这时dp[i][j] = dp[i - 1][j]</p><p> 由于在dp[i][j]这个位置可以做上述三种选择，因此取三种选择可能产生的最大值，即为dp[i][j]。即：<br> $$dp[i][j] = max(dp[i - 1][j - 1],dp[i][j - 1],dp[i - 1][j])$$</p></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length() + <span class="hljs-number">1</span>][str2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case,其实可以不用，因为数组初始化时全体元素就为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= str2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= str1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= str1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= str2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1.charAt(i - <span class="hljs-number">1</span>) == str2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[str1.length()][str2.length()];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度:O(m * n)</li><li>空间复杂度:O(m * n)<br>其中，m和n分别为str1和str2的长度</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris遍历</title>
    <link href="/2021/02/15/Morris%E9%81%8D%E5%8E%86/"/>
    <url>/2021/02/15/Morris%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h1><p>经典的二叉树遍历，无论是递归还是非递归。其空间复杂度都是O(h),其中h为二叉树的高度。<br>而Morris遍历可以做到时间复杂度O(N), 空间复杂度O(1)</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>记当前来到的节点引用为cur</p><ul><li>如果cur没有左孩子，那么cur向右移动：cur = cur.right</li><li>如果cur有左孩子，那么找到它左子树上最右的节点，记为mostright<ul><li>如果mostright的右指针right指向空，那么让其指向cur，然后cur向左移动：cur = cur.left</li><li>如果mostright的右指针right指向cur, 那么让其指向空，然后cur向右移动：cur = cur.right</li></ul></li></ul><p>举例说明：</p><pre><code>给定二叉树：          1        /   \       2     3      / \   /  \     4   5 6    7Morris遍历流程：1. cur在1：首先cur指向根节点1，当前cur有左孩子，所以找到左子树的最右节点5，5的右指针right现在为空，所以让其指向cur（5的right指向1），然后cur向左移动来到22. cur在2：cur有左孩子，找到其左子树的最右节点4，4的right为空，于是让其指向cur（4的right指向2），然后cur向左移动来到43. cur在4：当前cur没有左孩子，因此向右移动，回到24. cur在2：当前cur左子树的最右节点为4，4的right现在指向cur，于是让它指回空，然后cur向右移动来到55. cur在5：当前cur没有左孩子，因此向右移动，回到16. cur在1：cur左子树的最右节点为5，5的right现在指向cur，于是让它指回空，然后cur向右移动来到37. cur在3：cur左子树的最右节点为6，6的right指向空，于是让它指向cur，然后cur向左移动来到68. cur在5：当前cur没有左孩子，因此向右移动，回到39. cur在3：cur左子树的最右节点为6，6的right指向cur，于是让它指向空，然后cur向右移动来到710. cur在7：当前cur没有左孩子，因此向右移动，发现来到的位置上是空，于是整个遍历结束。总结下来：cur分别经过了1 2 4 2 5 1 3 5 3 7</code></pre><h2 id="Morris遍历的本质"><a href="#Morris遍历的本质" class="headerlink" title="Morris遍历的本质"></a>Morris遍历的本质</h2><p>在经典递归版的遍历中，只要一个节点不空，遍历会来到这个节点三次：</p><ul><li>首先来到这个节点</li><li>遍历完它的左子树后再回到这个节点</li><li>遍历完它的右子树后再回到这个节点</li></ul><p>如果把对这个节点的操作放在第一次来到这个节点的时候，就是先序遍历。<br>如果把对这个节点的操作放在第二次来到这个节点的时候，就是中序遍历。<br>如果把对这个节点的操作放在第三次来到这个节点的时候，就是后序遍历。  </p><p>而在Morris遍历中：</p><ul><li>如果一个节点有左子树，那么Morris遍历会回到它两次。并且第二次回到这个节点时，其左子树上所有的节点一定都已经遍历完了。Morris遍历根据左子树最右节点mostRight的右指针right指向谁来判断是第几次来到当前这个节点（指向空则是第一次，指向cur节点本身则是第二次）。</li><li>如果一个节点没有左子树，那么Morris遍历只会回到它一次</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Morris遍历的先序和中序思想一致，只是对节点操作（以打印为例）的时机不一致。在第一次来到节点时操作为先序，在第二次来到节点时操作为中序。</p><p>Morris遍历的中序遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(TreeNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode cur = head;<br>    TreeNode mostRight = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        mostRight = cur.left;<br>        <span class="hljs-comment">//如果cur有左孩子</span><br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//首先找到cur的左子树的最右节点</span><br>            <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;<br>                mostRight = mostRight.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;<br>                mostRight.right = cur;<br>                cur = cur.left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mostRight.right = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//若该节点有左子树，当把左子树处理完第二次回到这个节点时进行打印行为，即为中序遍历。</span><br>        <span class="hljs-comment">//如果该节点没有左子树，那么只会来到这个节点一次，在这时候打印即可。</span><br>        System.out.print(cur.val + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-comment">//如果cur没有左孩子，cur直接向右移动</span><br>        cur = cur.right;<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>Morris遍历的先序遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(TreeNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode cur = head;<br>    TreeNode mostRight = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        mostRight = cur.left;<br>        <span class="hljs-comment">//如果cur有左孩子</span><br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//首先找到cur的左子树的最右节点</span><br>            <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;<br>                mostRight = mostRight.right;<br>            &#125;<br>            <span class="hljs-comment">//若一个节点有左子树，那么当mosRight的right为空时，为第一次到达这个节点的时候。</span><br><span class="hljs-comment">//在此时进行打印行为，即为先序遍历</span><br>            <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;<br>                mostRight.right = cur;<br>                System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>                cur = cur.left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mostRight.right = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果一个节点没有左子树，那么只会来到这个节点一次，在这个时候打印即可。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果cur没有左孩子，cur直接向右移动</span><br>        cur = cur.right;<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/02/15/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法目的"><a href="#KMP算法目的" class="headerlink" title="KMP算法目的"></a>KMP算法目的</h2><p>在str1中寻找str2出现的位置<br>假设str1长度为N，str2长度为M  </p><p>暴力方法：尝试从str1的每一个位置开始，让str2来匹配，暴力方法时间复杂度：O(MN)</p><h2 id="KMP算法流程："><a href="#KMP算法流程：" class="headerlink" title="KMP算法流程："></a>KMP算法流程：</h2><p><img src="/img/kmp.jpg"></p><ul><li>i1代表str1的索引，i2代表str2的索引。二者都从零位置开始尝试匹配。每一次匹配成功，i1和i2都右移</li><li>当匹配失败时（以图中为例：X != Y)，有一个推论为：在str1从i到j中任何一个位置开始，都匹配不出str2。既然明知匹配不出，那就不用再像暴力法那样从str1中i的下一个位置开始尝试匹配str2。只需从下一个不确定能不能匹配的位置（即j）开始尝试匹配str2。即i1从j开始，i2从0开始。<br>又因为str1中从j到x的字符与str2中Y的前next[Y]个字符相等（曾经匹配成功过），str2中Y的前next[Y]个字符与str2的前next[Y]个字符相等（next数组的定义）。因此可以推出：str1中从j到x的字符与str2中Y的前next[Y]个字符相等。<br>所以str1中从j开始的next[Y]个字符和str2中从0开始的前next[Y]个字符是肯定相等、不用匹配的。因此i1可以直接从X处开始（匹配失败的位置），i2可以直接从next[Y]处开始。</li><li>还需注意一个特殊情况：当i2为str2的第一个位置（next[i2] == -1），且str2中i2与str1中i1对应字符不相等时，意味着str2中第一个位置和str1的i1处都不匹配。那么从str1的i1开始肯定匹配不出str2，于是i1++。</li><li>当while循环退出时，说明str1或str2中的任意一个走到末尾了。如果str2走到末尾了，则说明匹配成功了，返回str2在str1中出现位置的索引：i1-i2。否则，str2没走到末尾str1却走到了末尾，说明匹配失败，str2中没有str1,返回-1。</li></ul><p>Q &amp; A<br>问：为什么当匹配失败时可以说：在str1中从i到j任何一个位置开始，都匹配不出str2？<br>答：假设从str1中i到j的一个位置k开始，可以匹配出str2。即从k到X的这n个字符应该和str2中从0开始的前n个字符匹配（注意：n &gt; next[Y])。又因为str1中k到X的这n个字符已经和str2中Y的前n个字符匹配过了，它们是相等的。于是str2中从0开始的前n个字符（前缀）应该和Y前面的n个字符相等（后缀）。但由next数组的定义可知，它们是不相等的。因此这种假设不成立。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String s, String m)</span></span>&#123;<br>    <span class="hljs-comment">//在s中找不到m，返回-1</span><br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || m == <span class="hljs-keyword">null</span> || m.length() &lt; <span class="hljs-number">1</span> || s.length() &lt; m.length())<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span>[] str1 = s.toCharArray();<br>    <span class="hljs-keyword">char</span>[] str2 = m.toCharArray();<br>    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//根据str生成next数组</span><br>    <span class="hljs-keyword">int</span>[] next = getNextArray(str2);<br>    <span class="hljs-keyword">while</span>(i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length)&#123;<br>        <span class="hljs-keyword">if</span>(str1[i1] == str2[i2])&#123;<br>            i1++;<br>            i2++;<br>        &#125;<br>        <span class="hljs-comment">//next[i2]为1代表i2是str2中的第一个位置，即如果str2中第一个位置和str1的i1位置都不匹配</span><br>        <span class="hljs-comment">//那么让i1加1，让str2和在str1从i1的后一个位置开始匹配</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(next[i2] == -<span class="hljs-number">1</span>)<br>            i1++;<br>        <span class="hljs-keyword">else</span><br>            i2 = next[i2];<br>    &#125;<br>    <span class="hljs-keyword">return</span> i2 == str2.length ? i1 - i2 : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="next数组的构建"><a href="#next数组的构建" class="headerlink" title="next数组的构建"></a>next数组的构建</h2><p>next数组表示str2中任意一个字符<strong>前面的字符串的最长前缀和最长后缀的匹配长度</strong></p><p>比如：str2为abkababkabF,那么F在next数组中对应的数值就为5（F前面字符串的最长前缀和最长后缀最长匹配5个位置，abkab）</p><p>构建next数组的步骤：<br>例如str2为ababcababaK,那么K前面这个a对应的next值为4（最长前缀和最长后缀abab的长度）。现在已知这个next[a]，想要求next[K],于是我们比较next[a]对应的最长前缀的后一个字符c与next[a]对应的最长后缀的后一个字符a,发现二者不等。于是我们再将这个a与next[c]的最长前缀的后一个字符a相比，发现二者相等。于是next[K] = next[c] + 1,即2+1= 3</p><p>注：这里next[K]和next[c]都是简写，实际应该为next[11]和next<a href="%E5%8D%B3%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95%E5%80%BC">5</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(<span class="hljs-keyword">char</span>[] str)&#123;<br>    <span class="hljs-keyword">if</span>(str.length == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];<br>    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//i为当前来到的位置索引</span><br>    <span class="hljs-comment">//cn为i-1对应的最长前缀的下一个字符的位置索引</span><br>    <span class="hljs-comment">//cn可以看作next[i-1]</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; next.length)&#123;<br>        <span class="hljs-keyword">if</span>(str[i - <span class="hljs-number">1</span>] == str[cn])<br>            <span class="hljs-comment">//相当于next[i]=next[i-1]+1</span><br>            next[i++] = ++cn;<br>        <span class="hljs-comment">//如果前一个位置的字符与cn处不等，那么cn往前跳</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cn &gt; <span class="hljs-number">0</span>)<br>            cn = next[cn];<br>        <span class="hljs-comment">//如果不等且cn不能往前跳了(其最长前缀和最长后缀为0）</span><br>        <span class="hljs-keyword">else</span><br>            next[i++] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BFPRT算法</title>
    <link href="/2021/02/15/BFPRT%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/BFPRT%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h1><h2 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h2><p>在无序数组中找到第K小的数，时间复杂度O(N)</p><h2 id="基于partition思路的算法"><a href="#基于partition思路的算法" class="headerlink" title="基于partition思路的算法"></a>基于partition思路的算法</h2><p>和快速排序中partition的思想有些相像。比如说我们要在长度为1000的数组中找到第n小的数，于是我们现在数组中随机找一个数进行partition的过程，小于它的放左边，等于它的放中间，大于它的放右边。完成后的情况如下图所示，等于区域范围为500-600</p><p><img src="/img/BFPRT.jpg"></p><p>因为我们要找第n小的数，因此：</p><ul><li>如果500 &lt; n &lt; 600,因此这个第n小的数就在等于区域，即我们进行partition的基准元素。</li><li>如果n &lt; 500, 那么这个第n小的数肯定在小于区域，我们继续对小于区域进行partition过程。</li><li>如果n &gt; 600，那么这个第n小的数肯定在大于区域，我们继续对大于区域进行partition过程。</li></ul><p>该算法的平均时间复杂度基于概率，其长期期望为:O(N)</p><h2 id="BFPRT算法-1"><a href="#BFPRT算法-1" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><p>BFPRT算法的时间复杂度不基于概率，严格O(N)</p><p>BFPRT与上述算法的唯一区别在于：<strong>选择partition基准元素的这一步不是随机选取的</strong>。一旦选好了这个基准元素，之后的过程和上述算法相同。 </p><p>选择基准元素的方式：</p><ol><li>先将长度为N的数组进行分组，每5个元素一组</li><li>在每一组的组内进行排序(组间不排序)，也即将每一个长度为5的小组排序，小组内排序的时间复杂度为O(1)，一共有N/5个小组，因此这一步的时间复杂度为O(N)</li><li>将每一小组的中位数拿出来，构成一个长度为N/5的新数组</li><li>递归调用BFPRT算法，找到新数组中的中位数num</li><li>将这个元素num作为基准元素，进行partition</li></ol><p>为什么要这么选基准元素：<br>num在长度为N/5的新数组中是中位数，因此这个新数组中有N/10个数比num大，这N/10个数中的每个数a在它的原数组里又是中位数，即长度为5的原数组中有2个数比a大。因此，所有比num大的数统计起来，至少有$3N/10$个，也即最多有$7N/10$个数比num小.</p><p>同理，如果统计比num小的数，发现至少也有$3N/10$个数比它小，即最多有$7N/10$个数比num大.</p><p>那么我们用这个num做划分进行partition，会发现最多就有$7N/10$个数比它大，也最多有$7N/10$个数比它小。因此，下一步partition的范围最多也就是$7N/10$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>选基准元素的代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在arr中从begin到end间的元素范围内，选基准元素的过程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">medianOfMedians</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num = end - begin + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> offset = num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//mArr为中位数构成的新数组</span><br>    <span class="hljs-keyword">int</span>[] mArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num / <span class="hljs-number">5</span> + offset];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mArr.length; i++)&#123;<br>        <span class="hljs-comment">//beginI和endI为每个长度为5的小组的首尾</span><br>        <span class="hljs-keyword">int</span> beginI = begin + i * <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">int</span> endI = beginI + <span class="hljs-number">4</span>;<br>        <span class="hljs-comment">//取出每个小组的中位数，构成新数组</span><br>        mArr[i] = getMedian(arr, beginI, Math.min(end, endI));<br>    &#125;<br>    <span class="hljs-comment">//返回新数组的中位数</span><br>    <span class="hljs-keyword">return</span> bfprt(mArr, <span class="hljs-number">0</span>, mArr.length - <span class="hljs-number">1</span>, mArr.length / <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">//返回数组arr中从begin到end间所有元素的中位数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - begin + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)<br>        res[index++] = arr[i];<br>    Arrays.sort(res);<br>    <span class="hljs-keyword">return</span> res[res.length / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>获得基准元素pivot后，以它为基准进行partition操作，并进入BFPRT流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinKthByBFPRT</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] copyArr = Arrays.copyOf(arr, arr.length);<br>    <span class="hljs-keyword">return</span> bfprt(copyArr, <span class="hljs-number">0</span>, copyArr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//bfprt算法主体，在begin和end间的范围里求第i小的数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfprt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(begin == end)<br>        <span class="hljs-keyword">return</span> arr[begin];<br>    <span class="hljs-comment">//求每个小组中位数组成的新数组的中位数</span><br>    <span class="hljs-keyword">int</span> pivot = medianOfMedians(arr, begin, end);<br>    <span class="hljs-comment">//将pivot作为基准元素进行partition，返回等于区域的范围</span><br>    <span class="hljs-keyword">int</span>[] pivotRange = partition(arr, begin, end, pivot);<br>    <span class="hljs-keyword">if</span>(i &gt;= pivotRange[<span class="hljs-number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> arr[i];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; pivotRange[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> bfprt(arr, begin, pivotRange[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> bfprt(arr, pivotRange[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, end, i);<br>&#125;<br><br><span class="hljs-comment">//在数组arr中从begin到end的范围内以pivot为基准元素进行划分，返回等于区域范围</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> pivot)&#123;<br>    <span class="hljs-comment">//用small分别代表小于区域的右边界和大于区域的左边界，初始化时两个区域都没有元素</span><br>    <span class="hljs-keyword">int</span> small = begin - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> big = end + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cur = begin;<br>    <span class="hljs-keyword">while</span>(cur != big)&#123;<br>        <span class="hljs-keyword">if</span>(arr[cur] &lt; pivot)<br>            swap(arr, ++small, cur++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[cur] &gt; pivot)<br>            swap(arr, --big, cur);<br>        <span class="hljs-keyword">else</span><br>            cur++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;small + <span class="hljs-number">1</span>, big - <span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Manacher遍历</title>
    <link href="/2021/02/15/Manacher%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/Manacher%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><h2 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h2><p>一个字符串中找到最长回文子串</p><h2 id="暴力方法（中心扩展法）"><a href="#暴力方法（中心扩展法）" class="headerlink" title="暴力方法（中心扩展法）"></a>暴力方法（中心扩展法）</h2><p>假设字符串的长度为N，那么回文串可能的中心有2N-1种。其中，每个单字符串都可作为回文串的中心，这种情况有N种。其次，双字符串也可作为回文串的中心，这种情况有N-1种。单字符中心负责扩展成长度为奇数的字符串，双字符串中心可以扩展成长度为偶数的字符串。例如：</p><ul><li><p>字符串“aba”有5种可能的中心：a、b、c、ab、ba  </p></li><li><p>字符串“abba”有7种可能的中心：a、b、b、a、ab、bb、ba</p><p>中心扩展法的基本思想为：对于每一个中心都计算一次以其为中心的最长回文串长度</p></li></ul><p>具体算法：对于每一个可能的回文中心，都尽可能地扩展它对应的回文区间[left, right]，直到left=N或者S[left]不等于S[right]为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.length();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> left = i / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> right = left + i % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>            String tmp = s.substring(left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (tmp.length() &gt; res.length()) &#123;<br>                res = tmp;<br>            &#125;<br>            left--;<br>            right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li></ul><h2 id="Manacher算法-1"><a href="#Manacher算法-1" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>一些概念：</p><ul><li>回文半径数组：记录以每一个位置为中心的回文半径的长度</li><li>最右回文右边界：所有位置对应的回文半径中最靠右的位置</li><li>回文右边界的中心：得到最右回文右边界的回文半径的回文中心是哪里（由哪个中心向右扩展得到最右回文右边界）</li></ul><p>在回文右边界和回文左边界中的字符串是回文串。假设最右回文右边界R的中心是c，当前位置i关于c在其左边的对称位置为i’。</p><p><img src="/img/Manacher.jpg"></p><p>算法步骤：<br>分析四种情况</p><ol><li>i在R外，用暴力法扩展。</li><li>i在R里，i’的回文半径整体彻底在L（回文左边界）和R的内部，那么以i为中心的回文半径等于以i’为中心的回文半径</li><li>i在R里，i’的回文半径在L和R的外面，那么以i为中心的回文半径等于i到R的距离</li><li>i在R里，i’的回文左边界和L压线，那么要将i’的回文半径继续向外扩展（i到R的区域肯定在i的回文半径里，不需扩展。R右边是否在i的回文半径里还不清楚，需要扩展才知道)</li></ol><p>上面四种情况中，需要扩展的只有情况1和情况4，对于情况2和情况3，以i为中心的回文半径可以用O(1)的时间开销直接得出。而情况1和情况4在扩展时，R不断向右扩。只要进行一次成功的扩展，R都必然会增加。也就是说R最多就是从0位置到n位置（n为字符串长度)且R不会回退，所以**<em>整个Manacher算法的时间复杂度为O(N)**</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给定一个字符串，返回它的最长回文字串长度</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//将字符串扩展为manacher字符串（每个字符中间和字符串前后加#)</span><br>    <span class="hljs-comment">//因为扩展后字符串长度翻倍，因此求扩展后的字符串的最大回文半径，即求原来字符串的最大回文直径</span><br>    <span class="hljs-keyword">char</span>[] charArr = manacherString(str);<br>    <span class="hljs-comment">//pArr为回文半径数组</span><br>    <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[charArr.length];<br>    <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//max记录最长的回文半径长度</span><br>    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != charArr.length; i++) &#123;<br>        <span class="hljs-comment">//i在R里时：对于情况2和3，在i&#x27;的回文半径和i与R的距离中取较小值，即为i的回文半径</span><br>                 <span class="hljs-comment">//对于情况4，先将回文半径设为R-i，再在之后while循环中将回文半径继续向外扩展</span><br>        <span class="hljs-comment">//i在R外时，先将i位置的回文半径置为1，之后再在while循环里扩展</span><br>        pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//情况2和情况3即使进入了该while循环，但是第一次if都不会成立，会直接break退出循环</span><br>        <span class="hljs-comment">//只有情况1和情况4会在while循环里进行回文半径的扩展。</span><br>        <span class="hljs-keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])<br>                pArr[i]++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//更新最大回文右边界R和其对应的回文中心C</span><br>        <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;<br>            R = i + pArr[i];<br>            C = i;<br>        &#125;<br>        <span class="hljs-comment">//更新max</span><br>        max = Math.max(max, pArr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//生成manacher字符串，将给定字符串str的两端和每个字符中间全加上特殊符号#</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;<br>    <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();<br>    <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> C = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;<br>        res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[C++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2021/02/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>一句话描述：控制对其他对象的访问</strong></p><p>代理模式创建代理(Pxory)，让代理控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><p><img src="/img/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg"></p><p>RealSubject和Pxory都实现了Subject接口，因此Pxory可以在RealSubject出现的地方取代它。</p><p>代理模式有以下几个代表：</p><ul><li>远程代理：控制访问远程对象</li><li>虚拟代理：控制访问创建开销大的资源</li><li>保护代理：基于权限控制对资源的访问</li></ul><h2 id="远程代理："><a href="#远程代理：" class="headerlink" title="远程代理："></a>远程代理：</h2><p>如果我们要访问的对象在另一个JVM堆中（即在不同的地址空间中运行的远程对象），我们就没办法通过引用来得到这个对象。</p><pre><code>注：Subject a = XXX对于这种语句，a只能引用与当前代码语句所在同一个堆空间的对象。</code></pre><p>对于这种情况，远程代理就可以作为另一个JVM上对象的本地代表。调用代理的方法会被代理利用网络转发给远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>保护代理根据访问权限决定客户是否可以访问对象。</p><p>例如：有一个雇员对象，保护代理允许一个雇员自己调用对象上的某些方法（如setName()),但不允许雇员自己调用类似于setSalary()的方法。<br>而保护代理允许经理调用setSalary()方法，但不允许经理调用setName()方法。<br><img src="/img/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86.jpg"></p><h2 id="虚拟代理："><a href="#虚拟代理：" class="headerlink" title="虚拟代理："></a>虚拟代理：</h2><p>虚拟代理作为创建开销大的对象的代表。虚拟代理在我们真正需要使用一个对象时才创建这个对象。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。当对象创建后，代理就会将请求直接委托给对象。</p><p><img src="/img/%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86.jpg"></p><h3 id="以下为虚拟代理的实现："><a href="#以下为虚拟代理的实现：" class="headerlink" title="以下为虚拟代理的实现："></a>以下为虚拟代理的实现：</h3><p><strong>背景说明</strong>：当加载一张图片时，限于连接带宽和网络负载，加载可能需要一些时间，所以在等待图像加载的时候，应该显示一些东西。（同时也不希望在显示这些东西时整个应用被挂起）一旦图像被加载完成后，刚才显示的东西应该消失，图像显示出来。</p><p>先定义一个接口Image，代理和真正的图片对象都要实现Image接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Image</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImagePxory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RealImage realImage;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImagePxory</span><span class="hljs-params">(RealImage realImage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.realImage = realImage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//当realImage加载完成时，显示realImage</span><br>        <span class="hljs-comment">//否则显示:Image is loading, please wait</span><br>        <span class="hljs-keyword">while</span>(!realImage.isLoad())&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println((<span class="hljs-string">&quot;Image is loading, please wait&quot;</span>));<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                e.printStackTrace();;<br>            &#125;<br>        &#125;<br>        realImage.showImage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实图片类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> URL imageURL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> startTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealImage</span><span class="hljs-params">(URL imageURL)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.imageURL = imageURL;<br>        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">this</span>.startTime = System.currentTimeMillis();<br>    &#125;<br>    <span class="hljs-comment">//模拟图片加载过程，假定图片加载需要三秒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoad</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">return</span> endTime - startTime &gt; <span class="hljs-number">3000</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(imageURL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    String image = <span class="hljs-string">&quot;http://image.jpg&quot;</span>;<br>    URL url = <span class="hljs-keyword">new</span> URL(image);<br>    RealImage realImage = <span class="hljs-keyword">new</span> RealImage(url);<br>    ImagePxory imagePxory = <span class="hljs-keyword">new</span> ImagePxory(realImage);<br>    imagePxory.showImage();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md">CyC2018: CS-Notes:设计模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2021/02/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式分为三种，分别为：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>接下来以pizza店的例子阐述三种模式</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>一句话描述：简单工厂模式将对象的创建封装了起来</strong></p><p>通过工厂类创建对象，并且根据传入参数决定具体要实例化哪种子类对象的做法，叫简单工厂模式(Simpe Factory Pattern)<br>以下代码描述了产品类，包括一个抽象接口和两个具体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Pizza类为接口，description方法由具体的pizza类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//有两种pizza类实现了上面的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am cheesepizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am veggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们构建一个pizza工厂专门负责构造pizza对象。从而把本应在PizzaStore中构造并初始化pizza对象的代码迁移到pizza工厂类的创建方法createPizza中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//pizza工厂类。这个类只做一件事：帮客户创建pizza</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePizzaFactory</span></span>&#123;<br>    <span class="hljs-comment">//在创建方法中传入参数type，根据参数来判断要创建哪种pizza对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String type)</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;cheese&quot;</span>))<br>            pizza = <span class="hljs-keyword">new</span> CheesePizza();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;veggie&quot;</span>))<br>            pizza = <span class="hljs-keyword">new</span> VeggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在客户端（也就是PizzaStore类）中，想要创建哪种对象，只需传入对应的名称即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">(String type)</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个工厂对象factory</span><br>        SimplePizzaFactory factory = <span class="hljs-keyword">new</span> SimplePizzaFactory();<br>        <span class="hljs-comment">//再利用工厂factory创建与type相对应的工厂对象</span><br>        Pizza pizza = factory.createPizza(type);<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法（均可以调用createPizza方法创建pizza对象）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过简单工厂模式，我们可以把客户类和具体子类的实例化解耦，客户端不再需要用众多if else语句根据type判断自己应该实例化哪个子类。现在客户端只需要用将type传入工厂类中的创建方法，即可在在这个方法的返回值中得到想要的对象。</p><p>这样做有什么好处呢？   </p><blockquote><p>设想如果未使用简单工厂模式，在客户端用if else判断并实例化产品对象。当我们有多个客户端的时候，这些客户端就都需要知道产品的细节（即有哪些产品以及需要构建哪种产品对象）。而且如果我们多增加一项产品，那么这么多客户端都需要进行修改（再增加一条if else语句）</p></blockquote><p>简单工厂模式的缺陷：  </p><blockquote><p>即使使用了简单工厂模式，当我们多增加一项产品时，还是要在工厂类的构建方法中增加一条if else语句。这样就不符合”对扩展开放，对修改封闭”的OO原则。</p></blockquote><p>因此就引入了工厂方法模式，我们将在这个模式中解决以上缺陷带来的问题。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>一句话描述：每一个产品子类都有一个对应的工厂子类</strong></p><p>在工厂方法模式中，我们为每一个Pizza子类创建对应的工厂子类，工厂方法模式将构建产品的细节封装进具体的工厂子类中。注意：</p><ul><li>每一个Pizza子类都实现Pizza接口</li><li>每一个工厂子类都实现工厂接口</li></ul><p>因此，我们可以使用某一种具体工厂子类创建其对应的Pizza对象。当新增一种pizza时，我们构建一种和它对应的新工厂子类，就可以构造这种pizza对象。而不用在工厂类中修改代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象的工厂接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-function">Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//以下为两种工厂子类:CheesePizza工厂和VeggiePizza工厂</span><br><span class="hljs-comment">//它们分别实现了工厂接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizzaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">new</span> CheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeggiePizzaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">new</span> VeggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于客户端PizzaStore，想得到哪种Pizza对象，只需要构造与其对应的工厂子类对象，并使用其创建方法即可。连简单工厂模式中的传入type参数这一步都免了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个cheese披萨工厂</span><br>        PizzaFactory cheesefactory = <span class="hljs-keyword">new</span> CheesePizzaFactory();<br>        <span class="hljs-comment">//再利用这个工厂创建我们想要的cheese披萨</span><br>        Pizza pizza = cheesefactory.createPizza();<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg"></p><p>工厂方法模式的缺陷：  </p><blockquote><p>如果我们的产品子类越来越多，那么我们就要为每一个产品子类都创建一个工厂子类，这样类就会越来越多，非常繁琐。</p></blockquote><p>为了解决这个问题，以下引入抽象工厂模式</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>一句话描述：把产品分组，每组配备一个工厂，组内不同产品对应于这个工厂中的不同方法</strong></p><p>在抽象工厂模式中，我们不为每一个产品子类配备一个工厂子类。而是将产品进行分组，每组组内的不同产品由同一个工厂类的不同方法创建。</p><p>假设我们当前有四种pizza产品，分别为：</p><ul><li>大份cheese披萨</li><li>小份cheese披萨</li><li>大份蔬菜披萨</li><li>小份蔬菜披萨</li></ul><p>工厂方法模式的做法是：为这四种产品类都配备一个对应的具体工厂子类。</p><p>而对于抽象工厂模式，我们将产品分为两组：大份组和小份组。每组配备一个工厂。</p><p>以下为产品类：包括cheese披萨和蔬菜披萨两种抽象接口，每种接口分别由大份和小份两个具体类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">cheesePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigcheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cheesePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a BigcheesePizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallcheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cheesePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a SmallcheesePizza&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">veggiePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigveggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">veggiePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a BigveggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallveggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">veggiePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a SmallveggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是工厂类，先定义一个抽象的工厂接口。由于产品有两种（大份披萨和小份披萨），因此我们实现两种工厂类BigFactory和SmallFactory，分别用来构建大披萨对象和小披萨对象。</p><p>此外，每个工厂对应产品分类中的所有产品，工厂类都有一个与其对应的构建方法。例如：我们想得到一个大份cheese披萨对象，那么只需要使用大份pizza工厂中的createCheesePizza()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-function">cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//大份披萨工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>&#123;<br>        cheesePizza pizza = <span class="hljs-keyword">new</span> BigcheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>&#123;<br>        veggiePizza pizza = <span class="hljs-keyword">new</span> BigveggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//小份披萨工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>&#123;<br>        cheesePizza pizza = <span class="hljs-keyword">new</span> SmallcheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>&#123;<br>        veggiePizza pizza = <span class="hljs-keyword">new</span> SmallveggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是客户端代码，通过使用不同的工厂，并调用该工厂中不同的创建方法，我们就可以创造出不同的产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个大份披萨工厂</span><br>        Factory1 BigFactory = <span class="hljs-keyword">new</span> BigFactory();<br>        <span class="hljs-comment">//再利用这个工厂中的相应方法创建我们想要的cheese披萨</span><br>        Pizza pizza = BigFactory.createCheesePizza();<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2021/02/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了一簇算法，并把它们分别封装起来，让它们之间可以相互替换。此模式让算法的变化独立于使用算法的客户。</p><p><img src="/img/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义一个算法簇：描述鸭子的不同飞行行为.算法簇包含两个具体的算法(行为)：FlyWithWings和FlyNoWay。它们都实现自接口FlyBehavior</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I can fly with wings&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyNoWay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I can&#x27;t fly&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下为鸭子类，它不需要知道飞行行为的具体细节。因为它已将飞行行为委托给别人处理，而不是在Duck类内部定义这些行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span></span>&#123;<br>    <span class="hljs-comment">//FlyBehavior实例变量是一个接口类型，我们能在运行时利用多态为它指定不同的具体实现类。</span><br>    <span class="hljs-keyword">private</span> FlyBehavior flyBehavior;<br>    <span class="hljs-comment">//不在乎flyBehavior接口的对象是什么，只关心该对象知道如何进行fly动作就够了。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performFly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(flyBehavior != <span class="hljs-keyword">null</span>)<br>            flyBehavior.fly();<br>    &#125;<br>    <span class="hljs-comment">//为这个鸭子类设置给定的飞行行为</span><br>    <span class="hljs-comment">//在运行时想改变鸭子的飞行行为，只需调用这个方法即可</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlyBehavior</span><span class="hljs-params">(FlyBehavior flyBehavior)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flyBehavior = flyBehavior;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，因为飞行行为已经和鸭子类解耦（实际上二者为组合关系），因此飞行动作也可以被其他类的对象复用。而且当我们新增飞行行为时，只需要多创建一个实现飞行接口的具体行为类即可，不会影响到既有的具体行为类，也不会影响使用到飞行行为的Duck类。</p><p>以下为客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Duck duck = <span class="hljs-keyword">new</span> Duck();<br>        duck.setFlyBehavior(<span class="hljs-keyword">new</span> FlyWithWings());<br>        duck.performFly();<br>        duck.setFlyBehavior(<span class="hljs-keyword">new</span> FlyNoWay());<br>        duck.performFly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出将依次为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">I can fly <span class="hljs-keyword">with</span> wings<br>I can<span class="hljs-symbol">&#x27;t</span> fly<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式</title>
    <link href="/2021/02/15/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态地为对象扩展功能。</p><p>在扩展功能这一方面，装饰者模式比继承更有弹性</p><p><img src="/img/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>实现背景</strong>：一家咖啡店有多种饮料(如咖啡、豆浆），还有多种调料可以添加（如Whip、Mocha）。每种饮料都有一个基础价格，加完调料后，价格即为基础价格加上调料价格。要求我们要计算一杯加过调料的饮料的价格。</p><p>所有的装饰者和被装饰者都要继承自抽象类Beverage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    String description;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象调料类（装饰者），所有的调料类都需继承自这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CondimentDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-comment">//beverage为被装饰者的引用</span><br>    <span class="hljs-keyword">protected</span> Beverage beverage;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下为两个调料类(装饰者类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下是两个调料类（装饰者）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mocha</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage = beverage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Mocha&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Whip</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Whip</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage = beverage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Whip&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是两个饮料类（被装饰者类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Coffee</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Coffee&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soybean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Soybean</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Soybean&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.6</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    Beverage beverage = <span class="hljs-keyword">new</span> Soybean();<br>    beverage = <span class="hljs-keyword">new</span> Mocha(beverage);<br>    beverage = <span class="hljs-keyword">new</span> Whip(beverage);<br>    System.out.println(beverage.getDescription() + <span class="hljs-string">&quot;, $&quot;</span> + beverage.cost());<br>    Beverage beverage2 = <span class="hljs-keyword">new</span> Coffee();<br>    beverage2 = <span class="hljs-keyword">new</span> Mocha(beverage2);<br>    beverage2 = <span class="hljs-keyword">new</span> Whip(beverage2);<br>    System.out.println(beverage2.getDescription() + <span class="hljs-string">&quot;, $&quot;</span> + beverage2.cost());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/02/15/git/"/>
    <url>/2021/02/15/git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>git命令必须在仓库目录内执行</p><ol><li><p>创建一个空目录并进入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir learngit<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> learngit<br></code></pre></td></tr></table></figure></li><li><p>将这个目录变成git可以管理的仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>将一个文件<strong>添加</strong>到仓库</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-builtin-name">add</span> readme.txt<br></code></pre></td></tr></table></figure><p>注意：添加某个文件时，该文件必须在当前目录下存在</p></li><li><p>将这个文件<strong>提交</strong>到仓库</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-string">$ </span>git commit -m <span class="hljs-comment">&quot;wrote a readme file&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>-m后面是本次提交的说明</p><h2 id="对仓库中内容进行修改"><a href="#对仓库中内容进行修改" class="headerlink" title="对仓库中内容进行修改"></a>对仓库中内容进行修改</h2><p>用以下命令可以掌握工作区的状态，它会告诉我们文件有没有修改过</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><p>而以下命令可以查看修改的内容</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">diff</span> readme.txt<br></code></pre></td></tr></table></figure><h3 id="1-版本回退"><a href="#1-版本回退" class="headerlink" title="1.版本回退"></a>1.版本回退</h3><p>我们在工作中会不断地对文件进行修改，当我们觉得修改到一定程度的时候，就可以进行一次commit，相当于打游戏时进行一次存档。一旦文件被该乱了，或者不小心删除了文件，还可以从最近的一个commit中恢复。</p><p>以下命令告诉我们commit的历史记录,它会显示从最近到最远的提交版本</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>在Git中，<strong>用HEAD表示当前版本</strong>，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本就是HEAD~100。如果我们要把当前版本回退到上一个版本，就可以用如下的命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure><p>显然，当回退到上一个版本之后，刚才的当前版本已经不会在git log中看到了。但扔可以通过commit id回到刚才的那个版本（7c0b9b为那个版本git版本号的前几位）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> reset --hard  <span class="hljs-number">7</span>c<span class="hljs-number">0</span>b<span class="hljs-number">9</span>b<br></code></pre></td></tr></table></figure><p>但是那个版本的版本号找不到或者不记得了怎么办？不要紧，git记录了我们的每一次命令,通过如下命令行查看命令历史，就可以找到我们想重返的版本的id</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br><span class="hljs-number">7</span>c0b9b5 (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">7</span>c0b9b<br><span class="hljs-number">06</span>d21e9 HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">7</span>c0b9b5 (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> a <span class="hljs-type">line</span><br><span class="hljs-number">06</span>d21e9 HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span> (initial): <span class="hljs-keyword">write</span> a readme <span class="hljs-type">text</span><br></code></pre></td></tr></table></figure><h3 id="2-工作区和暂存区"><a href="#2-工作区和暂存区" class="headerlink" title="2.工作区和暂存区"></a>2.工作区和暂存区</h3><p>Git管理的文件分为工作区和版本库(.git隐藏目录)。版本库又分为暂存区stage和git为我们创建的第一个分支master。</p><p>我们把文件添加到git版本库分为两步：</p><ul><li>用git add把文件修改添加到暂存区</li><li>用git commit将暂存区的内容添加到当前分支</li></ul><p>可以理解为：将需要提交的文件修改先全都放到暂存区，然后，一次性提交暂存区的所有修改。</p><h3 id="3-撤销修改和删除文件"><a href="#3-撤销修改和删除文件" class="headerlink" title="3.撤销修改和删除文件"></a>3.撤销修改和删除文件</h3><p>如下命令可以用来撤销对工作区的修改</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- readme.txt</span><br></code></pre></td></tr></table></figure><p>有两种情况：</p><ul><li>readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul><p>总之，以上命令就是让这个文件工作区回到最近一次git commit或git add时的状态。</p><p>但是如果对工作区修改后还add到了暂存区该怎么办呢？</p><ol><li>先用如下命令可以撤销对暂存区的修改（unstage），然后重新放回工作区<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset HEAD readme.txt<br></code></pre></td></tr></table></figure></li><li>现在暂存区干净了，但是工作区还有修改，接下来再撤销掉工作区的修改：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- readme.txt</span><br></code></pre></td></tr></table></figure>总结撤销修改的三种情况：</li></ol><ul><li>当改乱了文件的内容并且还未add，想直接丢弃工作区的修改时，用命令git checkout – file</li><li>当改乱了文件的内容并且add到了暂存区时，想丢弃修改，第一步先用命令git reset HEAD file丢弃暂存区的修改，第二步再用命令git checkout – file丢弃工作区的修改。</li><li>当已经把改乱的文件commit到版本库时，想撤销提交，这时就需要版本回退。</li></ul><p>总结删除文件的两种情况：<br>当我们把工作区的一个文件删除时：</p><ul><li><p>如果我们确实要从版本库中删除该文件，那么就用git rm file删除掉，并且git commit</p></li><li><p>如果我们其实是不小心删错了，那就可以用git checkout – file将误删的文件恢复到最新版本。</p><p>注意：git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p></li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>Github用来提供Git仓库托管服务，它相当于一个服务器，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><ol><li>在github中添加本地计算机的SSH Key。这样GitHub就可以识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</li><li>在github中建立一个 repository。并在本地库中运行如下命令将本地版本库和github上的远程库关联起来（远程库的名字就叫origin）<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/wyh317/</span>learnGit.git<br></code></pre></td></tr></table></figure></li><li>将本地库的所有内容推送到远程库上,实际上是把当前分支master推送到远程。并且本地的master分支和远程的master分支关联了起来<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>由于远程库是空的，所以第一次推送master分支时，带了”-u”。之后，只要本地做了提交，就可以通过如下命令将本地的master分支的最近修改推送至Github<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>可以使用如下命令从github上克隆出一个本地库<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:wyh317/learnGit.git<br></code></pre></td></tr></table></figure>当从远程仓库克隆时，Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。可以用git remote或者git remote -v查看远程库的信息。</li></ol><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><ul><li>查看分支：git branch</li><li>创建分支：git branch name</li><li>创建一个分支并切换到它：git switch -c name</li><li>切换到某个分支：git switch name</li><li>合并某分支到当前分支：git merge name</li><li>删除分支：git branch -d name</li></ul><p>当两个分支的文件修改有冲突时，git无法完成自动合并，我们必须先手动把冲突解决然后提交，再合并。用git log –graph命令可以看到分支合并图。</p><p>通常在合并分支时，git会默认使用fast forward模式，但这种模式下删除分支后，会丢掉分支信息。如果使用以下命令行来merge(即将分支test合并到当前分支）：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">merge</span> --<span class="hljs-keyword">no</span>-ff -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;merge with no-ff&quot;</span> <span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><p>那么Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。（因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去），能看出来做过合并，而fast forward合并后就看不出来曾经做过合并</p><p><strong><em>分支策略</em></strong>：</p><ul><li>master分支应该是非常稳定的，仅用来发布版本，不能在上面工作</li><li>dev分支是不稳定的，用来工作用，到版本发布时，再把dev分支合并到master上</li><li>团队的每个成员都在dev的分支上工作，每个人有自己的分支，工作完往dev上合并即可。</li></ul><p><strong><em>Bug分支</em></strong>：<br>在修复bug时，我们通过创建新的bug分支来进行修复，修复完之后进行合并，最后将这个bug分支删除。</p><p>当手头上的工作还没有完成时，我们可以用git stash命令将当前工作现场“储藏”起来，然后去修复bug，修复后再用git stash pop命令恢复现场继续工作。</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用如下命令，把修复bug的commit（用其id表示）“复制”到当前分支，避免重复劳动。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git cherry-pick commitid</span><br></code></pre></td></tr></table></figure><p><strong><em>Feature分支</em></strong>：<br>每添加一个新功能，最好新建一个feature分支并在上面开发，完成后与主分支进行merge，最后删除该feature分支。</p><p><strong><em>多人协作</em></strong>：  </p><ul><li>首先，用git push origin <branch-name>向远程推送自己的更改</li><li>如果推送失败，说明队友的最新提交和我们正要试图的提交有冲突，那我们先用git pull抓取远程的新提交</li><li>在本地解决冲突，并在本地提交</li><li>将冲突解决后的分支提交到远程git push origin <branch-name></li></ul><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常会在版本库中打一个标签（tag），一个标签对应着一个commit，例如id为6a5819e的commit对应着标签为v1.2的版本，这样便与日后查找。</p><p>可以通过如下的命令进行打标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">3</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">2</span> <span class="hljs-number">6</span>a5819e<br></code></pre></td></tr></table></figure><p>第一行将标签v1.3打到当前分支最新提交的commit上，第二行将标签v1.2打到id为6a5819e的commit上。</p><p>命令git tag可以查看所有标签。git show <tagname>可以看到标签的说明文字。</p><p>删除一个本地标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>向远程推送一个本地标签：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;tagname&gt;<br></code></pre></td></tr></table></figure><p>向远程推送全部未推送过的本地标签:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br></code></pre></td></tr></table></figure><p>删除一个远程标签：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git push origin <span class="hljs-symbol">:refs/tags/&lt;tagname&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务</title>
    <link href="/2021/02/15/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/02/15/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="事物的概念"><a href="#事物的概念" class="headerlink" title="事物的概念"></a>事物的概念</h2><p>事物是访问并更新数据库中数据项的一组操作，它们要么都执行，要么都不执行。</p><p>可以通过commit提交一个事物，也可以通过rollback来进行回滚</p><p>MySQL默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每执行一个SQL语句后就会马上执行COMMIT操作。</p><h2 id="事物的四大特性ACID"><a href="#事物的四大特性ACID" class="headerlink" title="事物的四大特性ACID"></a>事物的四大特性ACID</h2><ul><li>原子性(Atomicity)：是指数据库事物是不可分割的最小工作单位，只有事物中的所有操作成功，事物才能进行提交。事物中有任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该回滚到执行事务之前的状态。</li><li>一致性(Consistency):在事物执行前后，数据库能从一个正确的状态转移到另一个正确的状态。依靠隔离性和原子性实现。</li><li>隔离性(Isolation)：一个事物在提交前对其他事物是不可见的。即在并发访问数据库时，各并发事物之间数据库是独立的。</li><li>持久性(Durability)：事物一旦提交，其所做的修改会永远保存到数据库中，即使系统崩溃，数据库也能通过重做日志(Redo log)将数据恢复。</li></ul><h2 id="事物的实现："><a href="#事物的实现：" class="headerlink" title="事物的实现："></a>事物的实现：</h2><ul><li>用锁来保证事物的一致性</li><li>redo log用来保证事物的原子性和持久性</li><li>undo log用来保证事物的一致性</li></ul><p>其中，redo恢复提交事务修改的页操作，而undo回滚行记录到某一个特定的版本。</p><p>当事物提交(commit)时,必须先将该事务的所有日志写入到重做日志文件(Redo log)中进行持久化。</p><p>在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。如果用户执行的事物或语句由于某种原因失败了，又或者用户用一条RollBack语句请求回滚，可以利用这些undo信息将数据回滚到修改前的样子。</p><p>保存点(Savepoint)用来通知系统应该记住事物当前的状态，以便之后发生错误时，事物能回到保存点当时的状态。注意：rollback to savepoint命令并不真正的结束事物。</p><h2 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h2><p>SQL标准定义了以下四种隔离级别：</p><ul><li>READ UNCOMMITTED（读取未提交）:最低的隔离级别，一个事务所做的修改，即使尚未提交，对其他事务也是可见的。<strong>会导致脏读、幻读或不可重复读</strong></li><li>READ COMMITTED（读取已提交）：一个事务所做的修改在提交之前对其他事务是不可见的。<strong>可以避免脏读，但不能避免幻读或不可重复读</strong></li><li>REPEATABLE READ（可重复读）：保证在同一个事务中多次读取同一数据的结果是一样的，除非该数据被这个事务自己所修改。为InnoDB默认的隔离级别。<strong>可以避免脏读和不可重复读，但不能避免幻读</strong></li><li>SERIALIZABLE（可串行化）：最高的隔离级别，强制事务串行执行，这样多个事务间就不会产生干扰，也就不会出现并发不一致问题（需要加锁实现）。<strong>可以避免脏读、不可重复读和幻读</strong>。</li></ul><p>隔离级别越低，事务请求的锁越少或保持锁的时间越短。</p><p>虽然InnoDB存储引擎在默认的隔离级别为REPEATABLE READ（可重读）但其在该事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以说InnoDB存储引擎的在默认的隔离级别下已经能完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化) 隔离级别。因此，InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。</p><p>此外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE(可串行化)</p><p><img src="/img/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 第2版[M]. 机械工业出版社, 2013.</li><li><a href="https://blog.csdn.net/qq_34337272/article/details/80611486">MySQL锁机制</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">Cyc2018:数据库系统原理</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md#%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8Einnodb%E9%94%81%E7%AE%97%E6%B3%95">JavaGuide；MySQL</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2021/02/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式确保一个类只有一个实例，并提供一个全局访问点</p><p>通常使用一个私有构造器、一个静态函数、一个私有静态变量来实现。</p><ul><li>为了保证类只有一个实例，所以就不能用new关键字和构造器来创建对象实例，因此需要将构造器声明为私有的，只有在类的内部才能调用构造器。</li><li>与此同时，需要一个私有静态变量来记录这个唯一的对象实例</li><li>还需要一个私有静态函数来返回这个唯一的私有静态变量。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-懒汉模式与饿汉模式"><a href="#1-懒汉模式与饿汉模式" class="headerlink" title="1.懒汉模式与饿汉模式"></a>1.懒汉模式与饿汉模式</h3><p>以下为单例模式中的懒汉模式代码。它的特点是：uniqueInstance被延迟实例化(lazy instantiaze)，也就是说如果我们不需要这个实例（不适用getUniqueInstance()函数），那么它就永远不会产生。可以节约资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有静态变量：记录这个唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-comment">//私有构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//私有静态函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但以上实现并非线程安全的。考虑线程A和线程B同时调用Singleton.getUniqueInstance(),进入以下的if语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure><p>此时实例并未被创建，所以A和B都通过了if判断，接下来A使用私有构造器构造了一个对象1。但B因为之前已通过了if判断，所以它也会构造一个对象2。如此一来就会多次实例化，在多线程的情况下无法保证只有一个实例对象。</p><hr><p>但如果我们在类初始化时就创建单例的话，就可以保证线程安全。以下为单例模式中的饿汉模式代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用这个做法，JVM在加载这个类时马上创建此唯一的单件实例。JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。</p><h3 id="2-双重校验锁："><a href="#2-双重校验锁：" class="headerlink" title="2.双重校验锁："></a>2.双重校验锁：</h3><p>首先检查实例uniqueInstance是否已经创建了，如果尚未创建，才对实例化语句进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//volatile关键字确保当uniqueInstacne被实例化时，多个线程能正确地处理uniqueInstacne变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstacne;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getIntance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;  <span class="hljs-comment">//同步锁</span><br>                <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)&#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重校验锁使用两个if语句来保证线程安全：</p><ul><li>第一个if语句保证了只有在第一次调用getIntance()方法的时候才进行加锁操作，之后直接return已被构造的单例即可，无需加锁。</li><li>第二个if语句避免了重复实例化对象。例如：两个线程同时进入synchronized临界区，若没有这步if判断，当线程A构建完对象，B由于已经通过了第一个if语句，不知道A已经构造好了对象，于是它也会再构造另一个对象。</li></ul><p><strong>对单例uniqueInstacne使用volatile关键字的原因</strong> ：<br>在Java中这样一句uniqueInstance = new Singleton()，会被JVM编译成如下指令：</p><ol><li><p>给uniqueInstance分配内存空间</p></li><li><p>初始化该内存空间的对象</p></li><li><p>将uniqueInstance指向已分配的内存地址</p><p>但这几步顺序也有可能经过JVM和CPU的优化，被重排成1、3、2的顺序。在多线程的情况下：当线程A完成指令1、3后，对象还未被初始化但是uniqueInstance已经不指向null。这时如果线程B走到了第一步if判断，会发现uniqueInstance不为null，于是直接return uniqueInstance，但这时单例还未被初始化。从而会返回一个尚未初始化完成的对象。</p></li></ol><p>使用volatile可以避免JVM的指令重排，如此一来将始终保证1、2、3的顺序。所以uniqueInstacne要么指向null，要么指向一个已初始化的对象，不会出现中间状态，保证了线程安全。</p><h3 id="3-静态内部类实现"><a href="#3-静态内部类实现" class="headerlink" title="3.静态内部类实现"></a>3.静态内部类实现</h3><p>从外部无法访问静态内部类LazyHolder，当调用Singleton.getInstance()方法时，才能得到单例对象INSTANCE。</p><p>当加载类Singleton时，类LazyHolder并没有被加载，因此单例INSTANCE并未被初始化。当调用Singleton.getInstance()方法时，内部类LazyHolder才被加载，INSTANCE才被实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Eric Freeman. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192251&idx=2&sn=4acce2985ab4fcc908235891c9213628&chksm=8c99f2e1bbee7bf7f64132bb58d3023f79b3c11fe2043dcd29fe07f4ddb5b3c7d375252d8555&mpshare=1&scene=1&srcid=10145YhZbl4txuQIh5xlFBqA&sharer_sharetime=1602674938022&sharer_shareid=63ec0aac0cd5411bee34cfcffcb8dd13&key=39efdee81dad78454480c9b361da08ead78bf35d989c6aaa0d4edc8e92fa7b9ce91a527f838f4b0a7d81f2828cee6ace059f058b1394c2b39c5ef15f877901053d8f24be422fb2ca4c912f2ade0b016cff8a88b43e2bd8dbd0db14269a57cf17c1ee40c4b58e63e3602182361d2442145db6c25d6eb6463c1042ac218a37da4e&ascene=1&uin=MjMwMzI4OTM4MA==&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AZ9HDfnHe+jxOhY62YWHjFM=&pass_ticket=MWeci50fAmUpNH9xi84lqGhymZw0Eks6tmCWWalvvtE8ydesOK9/2HCdSS9Ucqzv&wx_header=0">漫画：什么是单例模式？</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%20-%20%E5%8D%95%E4%BE%8B.md">Cyc2018:设计模式-单例</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2021/02/15/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2021/02/15/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><p>传输层包括以下两个协议：</p><ul><li><strong><em>TCP（Transmission Control Protocol）</em></strong>:TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li><li><strong><em>UDP（User Datagram Protocol）</em></strong>:UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li></ul><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><p>UDP从应用程序进程的得到数据，附加上用于多路复用/分解复用的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。</p><p>注意：使用UDP时，在发送报文段之前，发送方和接收方的传输层实体之间没有握手，因此UDP被称为是无连接的（DNS协议就是基于UDP的）</p><p>使用UDP的几个好处：</p><ul><li>因为实时应用通常要求最小的发送速率，不希望过分延迟报文段的传送，且能容忍一些数据丢失，这种情况用TCP就不太合适。</li><li>无需连接建立：UDP无需任何准备即可进行数据传输。因此，UDP不会引入建立连接的时延，这也是DNS使用UDP的原因。</li><li>无连接状态：TCP不仅要在端系统中维护连接状态，而且还要跟踪包括接收和发送缓存、拥塞控制参数以及序号与端口号的参数。而UDP不维护连接状态，也不跟踪这些参数。因此某些专门用于某种特定应用的服务器当应用程序运行在UDP之上时，一般都能支持更多的活跃用户。</li><li>分组首部开销小：UDP首部只有8字节的首部开销。而TCP首部则有20字节的首部开销。</li></ul><p><img src="/img/%E5%9B%BE%E7%89%873.1.jpg"></p><p>用UDP进行可靠数据传输的方法：<br>在应用程序自身中建立可靠性机制。这样的话，应用程序进程一方面可以进行可靠通信，另一方面也而无需受制由于TCP的拥塞控制带来的传输速率的限制。</p><p>TCP首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和（每个占2字节）。其中，长度指整个UDP报文段所占的字节数（首部+数据）</p><p><img src="/img/%E5%9B%BE%E7%89%873.2.jpg"> </p><p>注意：尽管UDP提供了差错检测，但它并没有提供恢复错误的机制。</p><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><p>TCP被称为是面向连接的，这是因为在两个进程互相发送数据之前，两个进程必须先相互握手。</p><h3 id="3-1-TCP报文段格式"><a href="#3-1-TCP报文段格式" class="headerlink" title="3.1 TCP报文段格式"></a>3.1 TCP报文段格式</h3><p><img src="/img/%E5%9B%BE%E7%89%873.3.jpg"></p><ul><li>序号(Sequence number)：一个报文段的序号是这个报文段的data字段的第一个字节的序号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li>确认号(Acknowledgement number)：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li>确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li>窗口(Receive window)：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="3-2-TCP的流量控制-Flow-Control"><a href="#3-2-TCP的流量控制-Flow-Control" class="headerlink" title="3.2 TCP的流量控制(Flow Control)"></a>3.2 TCP的流量控制(Flow Control)</h3><p>TCP为应用进程提供了流量控制服务，以消除发送方使接收方缓存溢出的可能性。流量控制服务是一个速度匹配服务，即让发送方发送的速率与接收方应用进程的读取速率相匹配，保证接收方来得及接收。而TCP发送方也可能因为IP网络的拥塞而被遏制，因为这种情况而对发送方的控制则是拥塞控制。</p><p><img src="/img/%E5%9B%BE%E7%89%873.4.jpg"></p><p>TCP通过让发送方维护一个称为接收窗口(receive window)的变量来提供流量控制，这个接收窗口用于告知发送方：该接收方还有多少可用的缓存空间。</p><p>由于TCP不允许已分配的缓存溢出，所以下式必须成立（不等式左边代表仍处在缓存中的数据量）：  </p><center>LastByteRcvd - LastByteRead <= RcvBuffer</center><p>接收窗口用rwnd表示，根据缓存空间的可用大小来设置：</p><center>rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)</center><p>由于该空间是随着时间变化的，所以rwnd是不断滑动的。</p><p>连接通过rwnd来提供流量控制的方式：主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段(reveive window)中，通知主机A它在该连接的缓存中还有多少可用空间。</p><p>而主机A也不断跟踪两个变量，LastByteSent和LastByteAcked,二者的差即是主机A发送到连接中但未被确认的数据量，通过将这个量控制在rwnd内，就可以保证主机A不会使主机B的缓存溢出。因此主机A必须始终保证：  </p><center>LastByteSent - LastByteAcked <= rwnd</center><p>注意：因为TCP仅当在它有数据或有ACK要发时才会发送报文段给A。因此当B的rwnd为0并且通知给A后，B不再向A发送带有rwnd的新报文段，即使之后B中rwnd不为0了，A也不会知道。所以TCP规范中要求：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段，这样B就能不断地回复A以ACK报文段，并向A通知rwnd状态。</p><h3 id="3-3-TCP的三次握手"><a href="#3-3-TCP的三次握手" class="headerlink" title="3.3 TCP的三次握手"></a>3.3 TCP的三次握手</h3><p>TCP的三次握手发生在连接建立时<br><img src="/img/%E5%9B%BE%E7%89%873.5.jpg"></p><p>假设 A 为客户端，B 为服务器端。  </p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。并且SYN被置0.</li><li>B 收到 A 的确认后，连接建立。在以后的报文段中，由于连接已建立，SYN都将是0.</li></ul><p><strong><em>三次握手的原因</em></strong><br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h3 id="3-4-TCP的四次握手"><a href="#3-4-TCP的四次握手" class="headerlink" title="3.4 TCP的四次握手"></a>3.4 TCP的四次握手</h3><p>TCP的三次握手发生在连接释放时</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认报文段，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><img src="/img/%E5%9B%BE%E7%89%873.6.jpg"></p><p><strong><em>四次挥手的原因</em></strong><br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong><em>TIME_WAIT</em></strong><br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>TIME_WAIT结束之后，连接就正式关闭，客户端所有资源将被释放。</p><h3 id="3-5-TCP拥塞控制"><a href="#3-5-TCP拥塞控制" class="headerlink" title="3.5 TCP拥塞控制"></a>3.5 TCP拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><strong><em>TCP如何限制发送速率</em></strong><br>运行在发送方的TCP拥塞控制机制跟踪一个称为拥塞窗口的变量，记为cwnd。它对一个TCP发送方能像网络中发送流量的速率进行限制。即，在一个发送方中未被确认的数据量不会超过cwnd和rwnd中的最小值，即：</p><center>LastByteSent - LastByteAcked <= min{cwnd, rwnd}</center>以上约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率。<p><strong><em>TCP如何察觉拥塞</em></strong><br>当出现过度的拥塞时，在沿着这条路径上的一台或多台路由器的缓存会溢出，引起一个数据报被丢弃，丢弃的数据报接着会引起发送方的丢包事件（要么超时要么收到3个冗余ACK），发送方就认为在发送方到达接收方的路径上出现了拥塞。</p><p>TCP通过慢启动、拥塞避免和快速恢复这三个部分来实现拥塞控制。</p><p><img src="/img/%E5%9B%BE%E7%89%873.7.jpg"></p><ul><li>慢启动：发送的最初执行慢启动，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li><li>拥塞避免：注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li><li>快速恢复：当丢包事件发生时，cwnd的值被设置成1个MSS，并且ssthresh的值设置为cwnd的一半，然后重新执行慢启动。</li></ul><p>上/img/图片中传输轮次1-4为慢启动过程，5-8为拥塞避免过程，之后为快速恢复过程。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理</title>
    <link href="/2021/02/15/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2021/02/15/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="1-地址空间"><a href="#1-地址空间" class="headerlink" title="1.地址空间"></a>1.地址空间</h2><p>就像进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。</p><p>即要做到的是：给每个程序一个自己的地址空间，使得一个程序中的地址28所对应的物理地址与另一个程序中的地址28所对应的物理地址不同。</p><p>一种为每个进程提供私有地址空间的简单方式是：使用两个寄存器，程序的起始物理地址装载到<strong>基址寄存器</strong>中，程序的长度装载到<strong>界限寄存器</strong>中。每个内存地址在送到内存之前，都会自动先加上基址寄存器的内容。</p><hr><p>如果把所有进程一直保存在内存中需要巨大的内存，如果内存不够，就做不到这一点。处理这种内存超载问题有以下两种方式</p><ul><li>交换技术<br>把一个进程完整地调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要在磁盘上，所以当它们不运行时就不会占用内存。但是受限于磁盘传输速率限制，将进程从磁盘调出和换入通常需要不短的时间。</li><li>虚拟内存（使得程序在只有一部分被调入内存的情况下运行）</li></ul><h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2.虚拟内存"></a>2.虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>虚拟内存的基本思想是：每个程序都有自己的地址空间，这个空间被分割成多个块，每个块称作一个页面(page)。每一页有自己连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的页时，由硬件执行必要的映射。当程序引用到不在物理内存中的页时，操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。、</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K，这些地址是虚拟地址。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p>注意：在使用虚拟内存的情况下，虚拟地址不是直接被送到内存总线上，而是被送到内存管理单元（MMU），MMU把虚拟地址映射成为物理内存地址。</p><p><img src="/img/%E5%9B%BE3.1.jpg" alt="avatar"></p><p>虚拟地址空间按照固定大小划分成称为页面(page)的若干单元。在物理内存中对应的单元成为页框(page frame)</p><p>如果程序访问到一个未映射的页面，内存管理单元MMU法线该页没有被映射（/img/图中用X表示），于是使CPU陷入到操作系统，这里称为**<em>缺页中断**</em> (page fault)。操作系统找到一个很少使用的页框且把它的内容写入磁盘，然后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表的目的是把虚拟页面映射为相应的页框。每个进程需要自己的页表（因为它有自己的虚拟地址空间）</p><p>虚拟内存的本质上是用来创造一个新的抽象概念——地址空间。这个概念是对物理内存的抽象，类似于进程是对物理机器(CPU)的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某一页。</p><h2 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3.页面置换算法"></a>3.页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最优页面置换算法"><a href="#1-最优页面置换算法" class="headerlink" title="1. 最优页面置换算法"></a>1. 最优页面置换算法</h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。<br>此算法是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1<br></code></pre></td></tr></table></figure><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-最近最久未使用页面置换算法"><a href="#2-最近最久未使用页面置换算法" class="headerlink" title="2. 最近最久未使用页面置换算法"></a>2. 最近最久未使用页面置换算法</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h3 id="3-先进先出"><a href="#3-先进先出" class="headerlink" title="3. 先进先出"></a>3. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。<br>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h3 id="4-第二次机会算法"><a href="#4-第二次机会算法" class="headerlink" title="4. 第二次机会算法"></a>4. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><h3 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h3><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><h3 id="7-工作集页面置换算法"><a href="#7-工作集页面置换算法" class="headerlink" title="7.工作集页面置换算法"></a>7.工作集页面置换算法</h3><p>一个进程正在使用的页面的集合称为它的工作集（working set）。如果整个工作集都被装入到了内存中，那么进程在运行到下一个阶段之前，不会产生很多缺页中断。若内存太小而无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断，导致运行速度也会变得很缓慢。若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了颠簸（thrashing）</p><p>不少分页系统都会跟踪进程的工作集，以确保在让进程运行之前，它的工作集就已经在内存中了。该方法称为工作集模型，其目的在于大大减少缺页中断。在让进程运行前预先装入其工作集页面也成为预先调页(prepaging)</p><p>基于工作集的页面置换算法的基本思路就是找出一个不在工作集中的页面并淘汰它。</p><p><img src="/img/%E5%9B%BE3.5.jpg" alt="avatar"></p><p>最好的两种算法是老化算法和工作集时钟算法</p><h2 id="4-分段"><a href="#4-分段" class="headerlink" title="4.分段"></a>4.分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与物理内存进行映射。</p><p><img src="/img/%E5%9B%BE3.2.jpg" alt="avatar"></p><p>下/img/图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p>分段的做法是把每个表分成段，一个段(segment)构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。它们既不会影响到其他的段，地址空间中也没有任何其他东西阻挡它增长。</p><p><img src="/img/%E5%9B%BE3.3.jpg" alt="avatar"></p><p>使用段的好处是：</p><ul><li>简化对长度经常变动的数据结构的管理</li><li>简化链接操作</li><li>简化修改</li><li>有助于在几个进程之间共享过程和数据</li></ul><h3 id="分段与分页的结合"><a href="#分段与分页的结合" class="headerlink" title="分段与分页的结合"></a>分段与分页的结合</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><p><img src="/img/%E5%9B%BE3.4.jpg" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2021/02/15/%E6%AD%BB%E9%94%81/"/>
    <url>/2021/02/15/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h2><p>在进程对设备、文件等资源取得了排他性的访问权时，有可能会出现死锁。</p><p>资源可以分为如下两类：</p><ul><li>可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用（比如存储器）</li><li>不可抢占资源：在不引起相关计算失败的情况下，无法把它从占有它的进程中抢占过来（比如CD刻录机）</li></ul><p>考虑这样一种情况：进程A获取了资源1，进程B获取了资源2，每个进程如果都想请求另一个资源就会被阻塞，那么每个进程都无法继续运行。这种情况就是死锁。</p><h2 id="2-死锁的条件"><a href="#2-死锁的条件" class="headerlink" title="2.死锁的条件"></a>2.死锁的条件</h2><ul><li><p><strong>互斥条件</strong>：每个资源要么已经分配给了一个进程，要么就是可用的。</p></li><li><p><strong>占有和等待条件</strong>：已经得到了某个资源的进程可以再请求新的资源。</p></li><li><p><strong>不可抢占条件</strong>：已经分配给一个进程的资源不能强制被抢占，它只能被占有它的进程显式地释放。</p></li><li><p><strong>环路等待条件</strong>：死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。</p><p>死锁发生时，以上四个条件必须同时满足。</p></li></ul><h2 id="3-处理方法"><a href="#3-处理方法" class="headerlink" title="3.处理方法"></a>3.处理方法</h2><p>有以下四种处理死锁的策略：</p><ul><li><strong>鸵鸟策略</strong>：忽略该问题</li><li><strong>死锁检测并恢复</strong>：让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。</li><li><strong>死锁避免</strong>：仔细对资源进行分配，动态地避免死锁。</li><li><strong>死锁预防</strong>：通过破坏死锁的四个条件，防止死锁的产生。</li></ul><h3 id="3-1-鸵鸟策略"><a href="#3-1-鸵鸟策略" class="headerlink" title="3.1 鸵鸟策略"></a><strong>3.1 鸵鸟策略</strong></h3><p>像鸵鸟一样，把头埋在沙子里，假装根本没发生问题。<br>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="3-2-死锁检测并恢复"><a href="#3-2-死锁检测并恢复" class="headerlink" title="3.2 死锁检测并恢复"></a><strong>3.2 死锁检测并恢复</strong></h3><p>核心思想：系统并不试/img/图阻止死锁的发生，而是允许死锁发生。当检测到死锁发生时，采取措施进行恢复。</p><p>死锁恢复：</p><ul><li>利用抢占恢复：将某一资源从一个进程强行取走给另一个进程使用，接着又送回。</li><li>利用回滚恢复：将一个进程复位到一个更早的状态，那是它还没有取得所需的资源，接着就把这个资源分配给一个死锁进程。如果复位后的进程试/img/图重新获得对该资源的控制，它就必须一直等到该资源可用时为止。</li><li>通过杀死进程恢复：杀掉环中的一个进程，打破死锁。</li></ul><h3 id="3-3-死锁避免"><a href="#3-3-死锁避免" class="headerlink" title="3.3 死锁避免"></a><strong>3.3 死锁避免</strong></h3><p>资源轨迹/img/图：</p><p><img src="/img/%E5%9B%BE6.1.jpg" alt="avatar"></p><p>/img/图中阴影部分表示该区域内两进程都拥有打印机或都拥有绘/img/图仪，互斥使用的规则决定了不可能进入该区域。</p><p>在点t，进程B请求资源。系统必须决定是否分配。如果系统把资源分配给B，系统进入不安全区域。要避免死锁，应该将进程B挂起，直到A请求并释放绘/img/图仪。</p><p><strong>安全状态和不安全状态</strong><br>如果死锁没有发生，并且即使所有进程突然请求对资源的最大需求，也让然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>下/img/图所示的状态即为安全状态：<br><img src="/img/%E5%9B%BE6.2.jpg" alt="avatar"></p><p>从/img/图 a 开始出发，先让 B 拥有所需的所有资源（/img/图 b），运行结束后释放 B，此时空闲数变为 5（/img/图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称/img/图 a 所示的状态时安全的。</p><p>如果任何分配资源实例的序列都无法保证工作的完成，则从安全状态进入到了不安全状态。如下/img/图所示：<br><img src="/img/%E5%9B%BE6.3.jpg" alt="avatar"></p><p>注意：**<em>不安全状态并不是死锁**</em>。<br>安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。</p><p><strong>银行家算法</strong><br>银行家算法将客服比作进程，将贷款单位比作资源，将银行家比作操作系统。</p><p>银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会达到安全状态。若是，那么就满足该请求；若否，那么久推迟对这一请求的满足。为了看状态是否安全，银行家看他是否有足够的资源满足某个客户。如果可以，那么这笔投资认为是能够收回的，并且接着检查最接近最大限额的一个客户，以此类推。如果所有投资最终都被收回，那么该状态是安全的，最初的请求可以被批准。</p><h2 id="3-4-死锁预防"><a href="#3-4-死锁预防" class="headerlink" title="3.4 死锁预防"></a><strong>3.4 死锁预防</strong></h2><p>通过破坏死锁的四个条件，防止死锁的产生。</p><ul><li>破坏互斥条件：如果资源不被一个进程独占，那么死锁肯定不会发生。</li><li>破坏占有和等待条件：要求当一个进程请求资源时，先暂时释放其当前占有的所有资源，然后再尝试一次获得所需的全部资源。</li><li>破坏不可抢占条件：可以通过将一些资源虚拟化的方式来实现。</li><li>破坏环路等待条件：将资源进行编号，制定规则：进程可以在任何时候提出资源请求，但是所有资源请求必须按照资源编号的顺序退出。任何时候总有一个已分配的资源是编号最高的。占用该资源的进程不可能请求其他已分配的各种资源。它或者会执行完毕，或者最坏的情况是去请求编号更高的资源，而编号更高的资源肯定是可用的。最终，它会结束并释放所有的资源，这时其他占有最高编号资源的进程也可以执行完。简而言之，存在一种所有进程都可以执行完毕的情景，所以不会产生死锁。</li></ul><p><img src="/img/%E5%9B%BE6.4.jpg" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2021/02/15/%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/02/15/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引也叫键，是帮助存储引擎快速找到记录的一种数据结构。相当于一个目录的作用。</p><p>索引的优点：</p><ul><li>加快数据的检索速度</li><li>通过创建唯一性索引，保证数据库表中每一行数据的唯一性</li></ul><p>索引的缺点：</p><ul><li>创建和维护索引需要耗费时间：当对表中数据进行修改时，如果数据有索引，那么索引也需要修改。</li><li>占用物存储空间</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是一颗搜索树，也是平衡树。<br>在B+树中，所有记录节点都是按照键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列。如下图所示：如果一个指针的左右相邻的key分别是3和5，则该指针所指向节点的所有key大于等于3小于等于5。</p><p>B树与B+树的区别：</p><ul><li>B树的所有节点既存放键(key)也存放数据(data);而B+树只有叶子节点存放key和data，其他内节点只存放key。</li><li>B树的叶子节点都是独立的;B+树的叶子节点有一条指针指向与它相邻的叶子节点。</li></ul><p><img src="/img/b+%E6%A0%91.jpg"></p><p>B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入内存中，再在内存中进行查找，最后得到要查找的数据。</p><p>此外，数据库系统将B+树的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p>由于B+树和红黑树相比有更低的树高度。一般B+树的高度都在2-4层，因此查找某一键值的行记录时最多只需要2-4次IO操作。</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>B+树索引可以分为聚集索引和辅助索引。</p><ul><li>二者相同点为：内部结构都为B+树，即高度平衡。叶子节点存放着所有的数据。</li><li>二者不同点为：​ 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。<h3 id="1-聚集索引"><a href="#1-聚集索引" class="headerlink" title="1.聚集索引"></a>1.聚集索引</h3>聚集索引即索引结构和数据一起存放的索引。聚集索引(clustered index)按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行数据，也将聚集索引的叶子节点称为数据页。</li></ul><p>因为无法把行数据存放在两个不同地方，因此一个表只能有一个聚集索引。</p><p>在数据页（叶子节点）上存放的是完整的每行的记录，而在非数据页（非叶子节点）的索引页中，存放的仅仅是键值及指向数据页的偏移量。</p><h3 id="2-辅助索引"><a href="#2-辅助索引" class="headerlink" title="2.辅助索引"></a>2.辅助索引</h3><p>对于辅助索引，叶子节点不包含行记录的数据<br>。叶子节点data中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚集索引中得到完整的一行记录。</p><p>即：有以下两步（<strong>回表查询</strong>：先定位主键值，再定位行记录）：</p><ul><li>先通过普通索引定位到主键值</li><li>再通过聚集索引定位到行记录</li></ul><p><strong>覆盖索引</strong>：如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引基于哈希表实现，简单地说就是把键值换算成hashcode，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快(O(1)时间复杂度）。</p><p>但有着如下缺点：</p><ul><li>哈希索引和B+树索引相比，丧失了有序性。因此无法排序和分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>自适应哈希索引是指：当InnoDB注意到某些索引被使用得很频繁时，会在内存中创键哈希索引，让 B+树 索引也具有哈希索引的一些优点。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 第2版[M]. 机械工业出版社, 2013.</li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md">Cyc2018:MySQL</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.md">JavaGuide:数据库索引总结2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2021/02/15/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2021/02/15/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层分为数据平面和控制平面。  </p><ul><li>数据平面的作用是在一个路由器中，将数据报从一个输入链路转移到一个适当的输出链路，即转发功能(forward)</li><li>控制平面的作用是协调一个网络中的每个路由器的转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送，即路由功能(routing)</li></ul><p>链路层交换机和路由器的区别：</p><ul><li>链路层交换机基于链路层帧中的字段值做出转发决定，交换机因此被称为链路层设备。</li><li>路由器基于网络层数据报中的首部字段做出转发决定，路由器因此被称为网络层设备</li></ul><p>当一个数据报从源被传送到目的地主机时，它通过了一些列的路由器。每个路由器都是用这个数据报的目的地地址来转发包。即，每个路由器都有一个转发表，其将目的地的IP地址与一个输出链路接口相对应。当一个数据报到达路由器时，路由器使用数据高的目的Ip地址在转发表中找到一个合适的输出链路接口(output link interface)</p><p>网络层协议概览：</p><p><img src="/img/%E5%9B%BE%E7%89%874.1.jpg"></p><h2 id="2-IP协议-Internet-Protocol"><a href="#2-IP协议-Internet-Protocol" class="headerlink" title="2.IP协议(Internet Protocol)"></a>2.IP协议(Internet Protocol)</h2><h3 id="2-1-IP数据报格式："><a href="#2-1-IP数据报格式：" class="headerlink" title="2.1 IP数据报格式："></a>2.1 IP数据报格式：</h3><p><img src="/img/%E5%9B%BE%E7%89%874.2.jpg" alt="IP数据报格式"></p><ul><li>header length：由于IPv4数据报中包含一些可变数量的选项(options),因此需要首部长度字段用来确定IP数据报中载荷从何处开始。大多数IP数据报不包含(option),所以**<em>一般的IP数据报具有20字节的首部**</em>。</li><li>TTL(Time-to-live):该字段用来确保数据报不会永远在网络中循环。每当一个路由器处理数据包时，该字段就减1.若TTL字段减为0，则该数据报被丢弃。</li><li>Protocol：该字段只有当一个IP数据报到达其最终目的地时才会有用，其指示了IP数据报的数据部分应该交给哪个特定的传输层协议。例如：值为6表明要将data交给TCP，值为17表明要将data交给UDP。这里Protoclo字段所起到的作用，类似于传输层报文段中的端口号的作用。**<em>协议号是将网络层与传输层绑定在一起的粘合剂，而端口号是将传输层与应用层绑定在一起的粘合剂**</em></li><li>首部检验和：路由器对收到的每个IP数据报计算其首部检验和，如果数据报首部中携带的检验和，与计算得到的检验和不一致，则检测出error，路由器一般会丢掉检测出error的数据报。</li></ul><h3 id="2-2-IP编址"><a href="#2-2-IP编址" class="headerlink" title="2.2 IP编址"></a>2.2 IP编址</h3><p>主机和物理链路之间的边界叫接口。IP要求每台主机和路由器接口拥有自己的IP地址。因此一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>每个IP地址长度为32比特（4字节），这些地址通常按所谓点分十进制记法表示，即地址中的每个字节用它的十进制形式书写，各字节间以句点隔开。</p><p><img src="/img/%E5%9B%BE%E7%89%874.3.jpg"></p><p>如/img/图片所示，在这个例子中，互联左上方的三个主机接口和一个路由器接口的网络形成一个子网。IP编址为这个子网分配一个地址223.1.1.0/24。其中的“/24”记法，称为子网掩码（subnet mask），指示32比特中的最左侧24比特定义了子网地址。一个子网中的所有设备拥有共同的子网地址。</p><p>形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组值的内部时，仅需要考虑该地址前面的x比特，这相当大地减少了在这些路由器中转发表的长度。</p><p>一个地址的剩余32-x比特可认为是用于区分该组织内部设备的，其中的所有设备具有相同的网络前缀。当该组织内部的路由器转发分组时，才会考虑这些比特。</p><p>IP广播地址是255.255.255.255。当一个主机发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机。</p><h2 id="3-DHCP协议"><a href="#3-DHCP协议" class="headerlink" title="3. DHCP协议"></a>3. DHCP协议</h2><p>DHCP(Dynamic Host Configuration Protocal)协议允许主机自动获取一个IP地址。网络管理员能够配置DHCP，以使某给定主机每次与网络连接时能得到一个相同的IP地址，或者某主机将被分配一个临时的IP地址，每次与网络连接时该地址也许是不同的。同时，DHCP还允许一台主机得知其他的一些信息，例如子网掩码、第一条路由器地址（默认网关）与它的本地DNS服务器的地址。</p><p>DHCP适合这样的情况：许多用户来来往往，并且只在有限的时间内需要地址。</p><p>每个子网一般都将具有一台DHCP服务器。如果在子网中没有服务器，则需要一个DHCP中继代理，这个代理知道用于该网络的DHCP服务器的地址。</p><p>DHCP协议的四个步骤（yiaddr:your Internet adress)：    </p><p><img src="/img/%E5%9B%BE%E7%89%874.4.jpg"></p><ul><li><strong>DHCP服务器发现</strong>：一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可以通过广播DHCP发现报文(DHCP discover message)来完成，客户在UDP分组中向端口67发送该发现报文。</li><li><strong>DHCP服务器提供</strong>：当DHCP服务器收到一个DHCP发现报文时，用DHCP提供报文（DHCP offer message）向客户做出响应，该报文向该子网中的所有节点广播，仍然使用广播地址255.255.255.255。每台DHCP服务器提供的报文含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP地址租用期（即IP地址有效的时间量）</li><li><strong>DHCP请求</strong>：新到达的客户从一个或多个服务器offer中选择一个，并向选中的服务器offer用DHCP请求报文（DHCP request message）进行响应，并回显配置的参数。</li><li><strong>DHCP ACK</strong>：服务器使用DHCP ACK报文（DHCP ACK message）对DHCP请求报文进行响应，证实所要求的参数。</li></ul><h2 id="4-网络地址转换（NAT）"><a href="#4-网络地址转换（NAT）" class="headerlink" title="4.网络地址转换（NAT）"></a>4.网络地址转换（NAT）</h2><p>NAT用于如下/img/图片所示的家庭网络等专用网络或具有专用地址的地域，一个具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络。</p><p><img src="/img/%E5%9B%BE%E7%89%874.5.jpg"></p><p>NAT路由器对于外部设备来说甚至不像一台路由器，相反它对外界的行为就像一个具有单一IP地址的设备。在/img/图片中，所有离开家庭路由器流向更大的因特网的报文都拥有一个源地址138.76.29.7,且所有进入家庭的报文都拥有一个目的地址138.76.29.7。NAT路由器对外界隐藏了家庭网络内的细节。</p><p>路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间的计算机提供地址。</p><p>例如：主机10.0.0.1指派了源端口号3345并将该数据报发送到LAN中，NAT路由器收到该数据报，为其生成一个新的源端口号5001，将源IP地址替代为其WAN一侧接口的IP地址138.76.29.7，且将源端口3345更换为新端口5001.<br>当报文到达NAT路由器时，路由器使用目的地址的IP地址与目的端口号从NAT转发表中检索出家庭网络浏览器使用的相应IP地址。于是，路由器重写该数据报的目的地址和目的端口号，并向家庭网络转发该数据报。</p><p>注：如果一个主机在NAT后面，那么它无法作为一个服务器接受TCP连接请求。</p><h2 id="5-ICMP（Internet-Control-Message-Protocol"><a href="#5-ICMP（Internet-Control-Message-Protocol" class="headerlink" title="5.ICMP（Internet Control Message Protocol)"></a>5.ICMP（Internet Control Message Protocol)</h2><p>主机和路由器用ICMP来彼此沟通网络层的信息。ICMP最典型的用途是差错报告。ICMP报文是承载在IP分组中的，因此从体系结构上讲它是位于IP之上的，但是它仍然被认为是网络层的协议而不是更高层的协议。当一台主机收到一个指明上层协议为ICMP的IP数据报时，它分解出该数据报的内容给ICMP，就像分解出一个数据报的内容给TCP或UDP一样。</p><p>ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8字节内容（以便发送方能确定引发该差错的数据报）<br>ICMP报文类型如下：</p><p><img src="/img/%E5%9B%BE%E7%89%874.6.jpg"></p><p>以下为两个ICMP的应用：</p><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo （Type类型为8，code类型为0）请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 报文段，并由目的主机发送终点不可达ICMP差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（Type3 code3）。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6.IPv6"></a>6.IPv6</h2><p>为了解决IPv4地址不够用的问题，IPv6将IP地址长度从32比特增加到128比特，且IPv6数据报的首部被固定为40字节。IPv6也不允许在中间路由器上进行分片和重新组装，这种操作只能在源和目的地上执行。</p><h3 id="IPv4向IPv6的过渡："><a href="#IPv4向IPv6的过渡：" class="headerlink" title="IPv4向IPv6的过渡："></a>IPv4向IPv6的过渡：</h3><p>IPv4向IPv6的过渡有两种方式，分别为双栈方法（dual-stack）和使用隧道（tunneling）</p><p><strong><em>双栈方法</em></strong>：<br>使用双栈方法的IPv6节点具有完整的IPv4实现，它具有发送和接受IPv4和IPv6两种数据报的能力。但是这种方法有一个缺点：如下/img/图片所示：如果不适用隧道的话，即使E和F之间能交换IPv5数据报，但从D到E的IPv4数据报中并不含有从A发出的初始IPv6数据报中的所有字段。因此E和F之间也只能交换IPv4.</p><p><strong><em>使用隧道</em></strong>：  </p><p><img src="/img/%E5%9B%BE%E7%89%874.7.jpg"></p><p>我们将两台IPv6路由器之间中间IPv4路由器的集合称为一个隧道(tunnel),借助于隧道，在隧道发送端的IPv6节点（如B）可将整个IPv6数据报放到一个IPv4数据报的数据(data)字段中。于是，该IPv4数据报的地址设为指向隧道接受端的IPv6节点(如E)。</p><p>在隧道接受端的IPv6节点最终收到该IPv4数据报，并确定该IPv4数据报含有一个IPv6数据报，于是从中取出IPv6数据报，再为该IPv6数据报提供路由，就好像它是从一个直接相连的IPv6邻居那里接收到该IPv6数据的一样。</p><h2 id="7-路由选择算法"><a href="#7-路由选择算法" class="headerlink" title="7.路由选择算法"></a>7.路由选择算法</h2><p>路由选择算法的目的：给定一组路由器以及连接路由器的链路，路由选择算法要找到一条从源路由器到目的路由器的最好路径。</p><p>其分为两类；</p><ul><li>全局式路由选择算法：用完整的、全局的网络信息计算出从源到目的地之间的最低费用路径。具有这种全局信息的算法常被称作<strong>链路状态(link state,LS)算法</strong></li><li>分散式路由选择算法： 没有节点拥有关于所有网络链路费用的完整信息，每个节点仅有与其直接相连链路的费用信息便可开始计算。常被称作<strong>距离向量(distance-vector,DV)算法</strong></li></ul><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。在一个AS内部，所有路由器运行同样的自治系统内部路由选择协议。在各AS之间，AS运行相同的AS间路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2021/02/15/%E9%94%81/"/>
    <url>/2021/02/15/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</p><h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。但锁的各种操作(获取锁、释放锁、检查锁状态)都会增加系统开销。因此锁的粒度越小，系统开销就越大。因此在选择锁的粒度时，需要在锁开销和并发程度做平衡。</p><p>MySQL数据库根据锁的粒度把锁分为表级锁和行级锁:</p><ul><li>表级锁：对当前操作的整张表加锁。锁的粒度大，系统开销小，加锁快，不会出现死锁。但发生锁冲突的概率高，并发程度低。</li><li>行级锁：只对当前操作的行进行枷锁。锁的粒度小，系统开销大，加锁慢，会出现死锁。但能大大减少数据库操作的冲突，并发度高。</li></ul><p>InnoDB支持行级锁和表级锁，默认为行级锁。而MyISAM存储引擎支持表级锁。</p><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>InnoDB实现了以下两种标准的行级锁：</p><ul><li>共享锁（S Lock）：也叫读锁。如果一个事务获得数据对象A的S锁，就可以对A进行读操作，但是不能进行写操作，加锁期间其他事务也可以获得A的S锁并读取它。但任何事务都不能获取数据上的X锁，直到A已释放所有共享锁。</li><li>排他锁（X Lock）：也叫写锁。如果一个事务获得数据对象A的X锁，就可以对A进行读和写操作。加X锁期间其他事务不能对A加任何锁，因此叫排他锁。</li></ul><p>锁的兼容性可以理解为：同一个数据对象可否同时获得两个不同的锁：</p><p><img src="/img/%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B.jpg"></p><p>为了支持在更细粒度上进行加锁，InnoDB支持意向锁。意向锁将锁定的对象分为多个层次。如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。</p><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。</p><p>而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p><p>意向锁是一种表锁，分为如下两种：</p><ul><li>意向共享锁（IS Lock）：表示事务准备给数据行记入共享锁，一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁。</li><li>意向共享锁（IX Lock）：表示事务准备给数据行加入排他锁，一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>注意：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</li></ul><h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过锁机制实现了事物的隔离性要求，使事物可以并发地工作。但在并发情况下，多个事物同时对同一事物进行操作，会带来以下几种并发不一致问题：</p><h3 id="1-丢失更新"><a href="#1-丢失更新" class="headerlink" title="1.丢失更新"></a>1.丢失更新</h3><p>即一个事务的更新操作会被另一个事务的更新操作所覆盖。例如；事务T1先将行记录r更新为v1，事务T2再将记录r更新为v2（当前两事务均为提交）。随后事务T1先提交，事务T2后提交。则最终记录r即为v2，事务T2的修改覆盖了事务T1的修改。</p><h3 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h3><p>要理解脏读，首先要理解脏数据。</p><p>脏数据是指事物对缓冲池中行记录的修改，并且还没有提交(commit)。(它和脏页不同，后者是在缓冲池中已经修改，但还没有刷新到硬盘中的页)</p><p>脏读指的是在不同的事物下，<strong>当前事务可以读到另外一个事物未提交的数据</strong>。</p><p>例如：事物1修改了数据但并未提交，事物2随后读取了这个数据，之后如果事物1回滚了此次修改，事物2读到的就是不正确的数据。</p><h3 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h3><p>不可重复读是指在一个事物内多次读取同一数据集合，在这个事物还没有结束时，另一个事物也访问了该数据集合并做了一些修改。因此，由于第二个事物的修改，第一个事物两次读取到的数据可能是不一致的。</p><p>例如：事物1先读取一次数据，之后事物2对数据进行了修改并提交，这样事物1再次读取这个数据时，读取结果就和第一次不同。</p><p>不可重复读和脏读的区别：</p><ul><li>脏读读到的是未提交的数据，不可重复读读到的是已提交的数据</li><li>脏读违反了数据库事物的隔离性，不可重复读违反了数据库事物的一致性。</li></ul><h3 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h3><p>幻读和不和重复读类似，是指当一个事务T1读取了几行数据后，另一个并发事务T2插入了一些数据，因此在之后的查询中，事务T1就会发现多了一些原本不存在的记录。</p><p>幻读和不可重复读的区别：</p><ul><li>幻读的关注点在于增删，比如多次读取一条记录发现记录增多或减少了。</li><li>不可重复读的关注点在于修改，比如多次读取一条记录发现其中某些列的值被修改。</li></ul><p>产生并发不一致问题的主要原因是破坏了事务的隔离性，数据库系统提供了多种事务的隔离级别供用户解决并发一致性问题。</p><h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><p>InnoDB存储引擎有三种行锁的算法，分别是：</p><ul><li>Record Lock:锁定一个记录上的索引，而不是记录本身。</li><li>Gap Lock:间隙锁，锁定索引间的间隙(一个范围)，但不包含索引本身(为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生)</li><li>Next-Key Lock: Record Lock和Gap Lock的结合。不仅锁定一个记录上的索引，也锁定索引之间的间隙。（InnoDB存储引擎使用这个机制来避免幻读,在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。）</li></ul><p>例如索引包含以下值：10，11，13，20。采用Next-Key Lock。那么将锁定如下区间：</p><pre><code>(-∞,10][10,11)[11,13)[13,20)[20,+∞]</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务</p><h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h2><p>一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式(multi versioning)的方式来读取当前执行时间数据库中行的数据。具体为：如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待该行上锁的释放。相反地、InnoDB存储引擎会去读取行的一个快照数据。</p><p>快照数据其实就是当前行数据之前的历史版本（通过undo来实现，快照数据不需要上锁，因为没有事物需要对历史数据进行修改操作），每行数据可能有多个快照数据（多个历史版本），一般称这种技术为行多版本技术，由此带来的并发控制，称为多版本并发控制。</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照（历史版本）。</p><p>MVCC可以实现提交读READ COMMITTED和可重复读REPEATABLE READ两种隔离级别。</p><ul><li>在READ COMMITTED隔离级别下，总是读取行的最新版本，如果行被锁定了（被另一个事物使用），则读取该行版本的一个快照。</li><li>而对于REPEATABLE READ的事物隔离级别，总是读取事务开始时的行数据版本。</li></ul><p>而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><ul><li>MVCC的SELECT操作读的是快照中的数据，不需要进行加锁操作。</li><li>MVCC的对于数据库进行修改的操作(INSERT、UPDATE、DELETE)需要读取最新的数据，因此需要进行加锁操作。</li><li>此外，在进行SELETE操作时，可以强制指定进行加锁操作。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的行记录加一个X锁，其他事物就不能对该行加上任何锁<br>SELETE...for update<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加一个S锁，其他事物可以向被锁定的行加S锁，但如果加X锁，则会被阻塞。<br>SELETE...lock <span class="hljs-keyword">in</span> share mode<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 第2版[M]. 机械工业出版社, 2013.</li><li><a href="https://blog.csdn.net/qq_34337272/article/details/80611486">MySQL锁机制</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">Cyc2018:数据库系统原理</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md#%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8Einnodb%E9%94%81%E7%AE%97%E6%B3%95">JavaGuide；MySQL</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机</title>
    <link href="/2021/02/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2021/02/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h1><p><img src="/img/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="Java运行时数据区"></p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<br>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p><h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的线程内存模型。每个方法被执行的时候，Java虚拟机会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直到执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。</p><p>该区域可能抛出的异常：</p><ul><li>若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li><li>若Java虚拟机的栈容量可以动态扩展，当栈扩展至无法申请到足够的内存会抛出OutOfMemoryError异常</li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p>本地方法栈和Java虚拟机栈类似，只是本地方法栈为执行本地方法服务，虚拟机栈为执行Java方法服务。<br>注：本地方法一般是用其他语言（C、C++、汇编）编写的，并且被编译为基于本机硬件和操作系统的程序。</p><h2 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h2><p>此区域的唯一目的就是存放对象实例，它也是垃圾收集器管理的内存区域。<br>Java堆在虚拟机启动时创建，被所有线程共享，是虚拟机管理的内存区域中最大的一块。</p><p>现代的垃圾收集器基本都采用分代收集算法，即针对不同类型的对象采取不同的垃圾回收策略。因此可以把Java堆分成新生代和老生代这两部分区域。</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p>用于存放类相关的信息，如类名、常量、静态变量、方法描述、即时编译器编译后的代码等数据。被所有线程共享。<br>这个区域的垃圾回收的主要目标是对常量池的回收和对类的卸载。</p><p>运行时常量池也是方法区的一部分，class文件中的常量池会在类加载后被放入这个区域。</p><h2 id="对象的创建、内存布局和访问"><a href="#对象的创建、内存布局和访问" class="headerlink" title="对象的创建、内存布局和访问"></a>对象的创建、内存布局和访问</h2><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h3><ul><li>给对象分配内存（两种方法：指针碰撞、空闲列表）</li><li>将分配到的内存空间都初始化为零值</li><li>用构造函数根据使用者的意愿对对象进程初始化</li></ul><h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中的存储布局可以分为以下三部分：</p><ul><li>对象头：包括Mark Word（哈希码、GC分代年龄等）和类型指针（虚拟机通过这个指针来确定该对象是哪个类的实例）</li><li>实例数据：对象真正存储的有用信息</li><li>对齐填充；任何对象的大小都必须是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通过填充对齐来补全。</li></ul><h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h3><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。对象的访问方式有以下两种：</p><ul><li>使用句柄访问：reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息。好处是reference存储的是稳定句柄地址，在对象被移动时只会改变句柄的实例数据指针，而reference本身不需要修改。</li><li>直接指针访问；reference中存储的直接就是对象地址。好处是节省了一次指针定位的时间开销，访问速度更快。</li></ul><p><img src="/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="对象的访问定位"></p><p>内存溢出和内存泄漏的区别：</p><ul><li>内存泄漏：已经分配的堆内存由于某些原因无法释放</li><li>内存溢出：没有足够的内存再供分配了</li></ul><h1 id="二、垃圾收集与内存分配"><a href="#二、垃圾收集与内存分配" class="headerlink" title="二、垃圾收集与内存分配"></a>二、垃圾收集与内存分配</h1><p>在Java的内存区域中：程序计数器、虚拟机栈、本地方法栈这三个区域属于线程私有，当线程结束时内存自然就跟着回收了。因此只需要对Java堆和方法区进行垃圾收集。</p><h2 id="判断哪些对象需要被回收"><a href="#判断哪些对象需要被回收" class="headerlink" title="判断哪些对象需要被回收"></a>判断哪些对象需要被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器就减一；计数器为0的对象可被回收。</p><p>缺陷：当两个对象存在循环引用时，引用计数器永不为0，导致无法对这两个对象进行回收。  正是因为这个缺陷的存在，Java虚拟机不使用引用计数算法来判断对象的存活与否。</p><p>例如：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h3><p>Java虚拟机使用可达性分析算法判断对象是否可被回收。其以GC Roots作为起始节点集开始根据引用关系向下搜索，可达的对象存活，不可达的对象可被回收。</p><p>GC Roots包括如下：</p><ul><li><p>虚拟机栈中引用的对象</p></li><li><p>方法区中类静态属性所引用的对象（例如引用类型静态变量）</p></li><li><p>方法区中常量引用的对象（字符串常量池中的引用）</p></li><li><p>所有被同步锁（synchronized关键字）所持有的对象</p></li><li><p>等等</p><p><img src="/img/GCRoot.jpg" alt="GCRoot.jpg"></p></li></ul><p><strong>四种引用关系：</strong></p><ul><li>强引用：使用new关键字创建的引用，例如Object obj = new Object()。只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。</li><li>软引用：在系统将要发生内存溢出异常之前，先将软引用关联的对象列进回收范围进行第二次回收。如果这次回收后还没获得足够的内存，才会抛出内存溢出异常。</li><li>弱引用：一旦垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象。</li><li>虚引用：又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</li></ul><p><strong>方法区的回收</strong><br>方法区的垃圾收集主要回收废弃的常量和不再使用的类型。</p><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。<br>设计者一般至少会把Java堆划分为新生代和老生代两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老生代中存放。</p><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h3><p>步骤：</p><ul><li>首先标记出所有需要回收的对象</li><li>在标记完成后，统一回收所有被标记的对象</li></ul><p>缺点：</p><ul><li>执行效率不稳定（标记和清除两个过程的执行效率随对象数量增长而降低）</li><li>会产生大量的内存碎片，导致无法给大对象分配内存</li></ul><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p><h3 id="2-标记-复制算法"><a href="#2-标记-复制算法" class="headerlink" title="2.标记-复制算法"></a>2.标记-复制算法</h3><p>此算法主要针对新生代。它将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img src="/img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="标记复制算法"></p><p>现在的商业虚拟机大都采用这种收集算法回收新生代的内存，但是并不是划分为大小相等的两块，而是把新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（老年代）进行分配担保，即借用老年代的空间存储放不下的对象。</p><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h3><p>此算法主要针对老年代。其中的标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p>此算法缺点在于：需要移动大量对象，处理效率比较低。优点在于不会产生内存碎片。</p><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></p><p>Java虚拟机为什么要划分为新生代和老年代？<br>分代收集可以让我们根据各个年代的特点选择合适的垃圾收集算法。在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器"></p><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><p>Serial收集器是一个单线程工作的收集器。它在进行收集时，必须暂停所有工作线程，直到它收集结束。</p><p><img src="/img/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p><p>Serial收集器对运行在客户端模式下的虚拟机来说是很好的选择。因为这种场景下内存不会特别大，停顿时间可以接收</p><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><p>多线程版本的Serial收集器。</p><p>适用于服务端模式的新生代垃圾收集。除了Serial之外，只有它能和CMS配合使用。也可以理解为，ParNew合并入CMS，成为它专门处理新生代的组成部分。</p><p><img src="/img/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p><p><strong>并行和并发区分</strong>：  </p><ul><li>并行：并行描述的是多条垃圾收集器线程之间的关系</li><li>并发：并发描述的是垃圾收集器线程与用户线程之间的关系<h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3>吞吐量优先收集器</li></ul><p>其他垃圾收集器的目标是尽可能缩短垃圾收集时用户线程的停顿时间。而此收集器的目标是达到一个可以控制的吞吐量。吞吐量是指CPU用于运行用户代码的时间和总时间（运行用户代码时间+运行垃圾收集时间）的比值。</p><p>顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p><p>垃圾收集停顿时间的缩短是以牺牲吞吐量和新生代空间为代价获取的。（新生代空间变小，虽然每次的垃圾回收时间缩短，但是垃圾回收变得频繁，进而导致吞吐量下降）</p><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h3><p>Serial的老年代版本，同样是一个单线程收集器。它有两大用途：</p><ul><li><p>在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用</p></li><li><p>作为 CMS 收集器的后备方案</p><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本</p></li></ul><p><img src="/img/Parallel_Scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel Scavenge收集器"></p><p>在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的老年代收集器。它是基于标记-清除算法实现的。</p><p>分为以下四个步骤：</p><ol><li>初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程。耗时最长但是不需要停顿，可以与用户线程并发运行</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要停顿。</li><li>并发清除：清除掉已经标记的死亡对象，不需要停顿。</li></ol><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以和用户线程一起工作，所以从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><img src="/img/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p><p>缺点如下：</p><ol><li>基于标记-清除算法，会产生很多内存碎片。往往会出现老年代还有大量空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次Full GC的情况。</li><li>无法处理浮动垃圾。浮动垃圾是指并发标记和并发清理阶段由于用户线程继续运行而产生的垃圾。这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时清理。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，这样停顿时间就长了。</li><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3>G1(Garbage First)收集器是一款面向服务端应用的垃圾收集器。在多CPU和大内存场景下有很好的性能。</li></ol><p>G1收集器不像其他收集器一样只对新生代或老年代进行回收，它可以直接对新生代和老年代一起回收。衡量标准不再是它属于哪一个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。这就是G1收集器的Mixed GC模式。</p><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），收集器能够对扮演不同角色的Region采用不同的策略处理。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>G1收集器的工作步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收<br>除了并发标记以外，其余步骤都要完全暂停用户线程<br><img src="/img/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器"></li></ul><p>G1收集器的特点：</p><ul><li>可预测的停顿：G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定消耗在 GC 上的时间不得超过 N 毫秒</li><li>空间整合：G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li></ul><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><ul><li>对象优先在新生代的Eden上分配，当Eden空间不够时，发起MinorGC</li><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li></ul><hr><h1 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a>三、类加载机制</h1><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中才能被运行和使用。而虚拟机如何加载这些Class文件、Class文件中的信息进入到虚拟机中会发生什么变化，这些是类加载机制要处理的内容。</p><p>虚拟机的类加载机制：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类。</p><p>在Java中，类加载是在程序运行期间完成的。即，第一次使用到一个类时才对其进行加载，而不是一次性加载所有类（会占用很大的内存）</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/img/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="类的生命周期"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类的生命周期中前五个阶段：加载、验证、准备、解析、初始化构成了类加载过程。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>在加载阶段，Java虚拟机完成了以下三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（可以通过ZIP包、网络、数据库等途径获取）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li></ul><p>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。此外所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>确保Class文件的字节流中包含的信息符合要求，不会危害虚拟机自身的安全。</p><p>Class文件并不一定只能从Java源码编译而来，虽然Java语言本身相对安全，但Java无法做到的事情在字节码层面上却有可能实现。所以如果虚拟机不检查输入的字节流的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致系统收到攻击。</p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>准备阶段是正式为类中定义的变量（静态变量）在方法区中分配内存并设置类变量初始值（通常为零值）的阶段。</p><p>注意：这个阶段只为静态变量分配内存，实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。因为实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p><p>在准备阶段设置的初始值一般为零值，例如下面的value变量在这个阶段将被初始化为0(之后的初始化阶段才会被具体赋值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>特殊情况：如果value是常量，那么它就会被初始化为表达式所定义的值123</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>解析阶段是Java虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>例如：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析阶段符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>在初始化阶段，Java虚拟机才真正开始执行类中编写的Java代码，将主导权从虚拟机移交给应用程序。</p><p>初始化阶段是执行类构造器 &lt; clinit &gt;() 的过程。在准备阶段，类变量已经赋过一次系统要求的初始零值，而在初始化阶段，根据使用者通过程序制定的主观计划去初始化类变量和其它资源。</p><p>&lt; clinit &gt;() 是由编译器自动收集类中所有静态变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        i = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 给变量赋值可以正常编译通过</span><br>        System.out.print(i);  <span class="hljs-comment">// 这句编译器会提示“非法向前引用”</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚拟机会保证一个类的 &lt; clinit &gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt; clinit &gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt; clinit &gt;() 方法完毕。</p><h2 id="类加载器与双亲委派模型"><a href="#类加载器与双亲委派模型" class="headerlink" title="类加载器与双亲委派模型"></a>类加载器与双亲委派模型</h2><p>Java虚拟机的设计者将类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader)</p><p>每一个类加载器，都有一个独立的类命名空间。即使两个类来源于同一个Class文件，被同一个Java虚拟机加载，但只要加载它们的类加载器不同，那这两个类就必定不相等。（两个类相互独立）</p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>从Java虚拟机的角度看，类加载器只分为以下两种：</p><ul><li>启动类加载器（Bootstrap ClassLoader)：使用C++实现，是虚拟机自身的一部分。</li><li>其他类加载器：使用Java语言实现，独立于虚拟机之外，全部继承自抽象类java.lang.ClassLoader</li></ul><p>从Java开发人员的角度看，类加载器可以分为以下的三层类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader): 这个加载器将存放在 <JAVA_HOME>\lib 目录下的，能被虚拟机识别的类库加载到虚拟机内存中（按照文件名识别，如 rt.jar）。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li><li>扩展类加载器（Extension ClassLoader)：这个加载器将 <JAVA_HOME>/lib/ext 目录中的、或者被 java.ext.dir 系统变量所指定的路径中所有的类库加载到虚拟机内存中。由于类加载器是Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application ClassLoader)：也称为“系统类加载器”，它负责加载用户类路径（ClassPath）上所有的类库。开发者同样可以直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>Java应用通过以上三种类加载器的相互配合来完成类加载，此外用户也可以加入自定义的类加载器来进行拓展。类加载器的层次关系如下所示，这种关系被称为双亲委派模型：</p><p><img src="/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。注意：类加载器的父子关系不是以继承(is-a)来实现的，而是以组合(has-a)来实现的。</p><p><strong>工作过程</strong>：<br>每个类加载器都先将类加载请求委派给父类加载器去处理，所以最后所有的加载请求都传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，自加载器才会尝试自己去完成加载。</p><p>Java官方API文档的描述如下：</p><blockquote><p>The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a “parent” class loader. When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p></blockquote><p><strong>好处</strong><br>Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，可以使基础类得到统一。</p><p>例如：存放在rt.jar中的类java.lang.Object，无论哪一个类加载器要加载这个类，最终都将委派给处于模型顶端的启动类加载器进行加载，因此能保证程序中加载的所有的Object类都是同一个类（正如前述：相同的类文件被不同的类加载器加载产生的是两个不同的类）。</p><p>反之，如果没有双亲委派模型，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，它将会被应用程序类加载器加载，这样程序中就会有多个Object类，造成混乱。</p><p><strong>实现</strong><br>双亲委派模型的代码全部集中在java.lang.ClassLoader的loadClass()方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过了</span><br>        Class c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c = findBootstrapClassOrNull(name);<br>            &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// 如果父类加载器抛出ClassNotFoundException</span><br>                <span class="hljs-comment">// 说明父类加载器无法完成加载请求</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 在父类加载器无法加载时</span><br>                <span class="hljs-comment">// 再调用本身的findClass方法来进行类加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);<br>    &#125;<br>&#125;<br>loadClass()方法的运行逻辑：先检查请求加载的类是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。只有当父加载器加载失败，抛出ClassNotFoundException异常时，才调用自己的findClass()方法尝试进行加载。<br></code></pre></td></tr></table></figure><p><strong>自定义类加载器</strong><br>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，就需要继承 ClassLoader。</p><ul><li>如果想打破双亲委派模型，就需要重写loadClass()方法，因为双亲委派模型的逻辑是由loadClass()方法体现的。</li><li>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2019.</li><li><a href="https://github.com/CyC2018/CS-Notes">Cyc2018/CS-Nodes</a></li><li><a href="https://github.com/Snailclimb/JavaGuide">Snailclimb/JavaGuide</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2021/02/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/02/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使得每个进程各运行几十或几百个毫秒。严格地说，在某一瞬间，CPU只能运行一个进程。但在1秒钟期间，它可能运行多个进程，这样就产生并行的错觉。</p><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><p>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p><p><img src="/img/%E5%9B%BE2.1.jpg" alt="avatar"></p><p>停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程成为守护进程。</p><h3 id="进程的层次："><a href="#进程的层次：" class="headerlink" title="进程的层次："></a>进程的层次：</h3><p>当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。（注意：父进程和子进程有着不同的地址空间）</p><p>在UNIX中，进程和它的所有子女以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组的所有成员。而Windows中没有进程层次的概念。</p><h3 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h3><p>进程的三个状态为：</p><ul><li>运行态（该时刻进程实际占用CPU）</li><li>就绪态（可运行，但由于其他进程正在运行而暂时停止）</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）</li></ul><p><img src="/img/%E5%9B%BE2.2.jpg" alt="avatar"></p><p>调度程序的主要工作就是决定应当运行哪个进程、何时运行以及它应该运行多长时间（即/img/图中的转换2和转换3）</p><h3 id="进程的实现："><a href="#进程的实现：" class="headerlink" title="进程的实现："></a>进程的实现：</h3><p>为了实现进程模型，操作系统维护着一张进程表（process table)。每个进程占用一个进程表项。该表象包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态和调度信息，以及其他在进程中运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><h3 id="2-1-线程概述"><a href="#2-1-线程概述" class="headerlink" title="2.1 线程概述"></a>2.1 线程概述</h3><p>线程是独立调度的基本单位。传统的操作系统中，每个进程有一个地址空间，并且只有一个控制线程。但由于以下原因需要使用多线程：  </p><ol><li>多个线程之间共享同一个地址空间和所有可用数据。</li><li>由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销。</li><li>若多个线程都是CPU密集的，那么并不能获得性能的增强。但如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，可以加快应用程序执行的速度。</li></ol><p>例如：假设字处理软件被编写为含有两个线程的程序。一个线程与用户交互，而另一个线程在后台重新进行格式处理。一旦第一页的语句被删除掉，交互线程就立即通知格式化线程对整本书重新进行处理。进一步考虑，可以再增加一个处理磁盘备份的线程。<br>如果程序是单线程的，那么在进行磁盘备份时，来自键盘和鼠标的交互命令就会被忽略，直到备份工作停止为止。如果使用三个线程，程序设计模型就很简单了。第一个和线程只是和用户交互；第二个线程在得到通知时进行文档的重新格式化；第三个线程周期性地将RAM中的内容写到磁盘上。<br>但是在这里若使用三个进程是行不通的，这是因为三个线程都需要在同一个文件上进行操作。通过让三个线程代替三个进程，三个线程共享公共内存，于是它们都可以访问同一个正在编辑的文件。</p><p>再例如，对于那些必须处理极大量数据的应用。通常的单线程处理方式是，读进一块数据、对其处理、然后再写出数据。这里的问题是，如果只能使用阻塞系统调用，那么在数据写入和数据输出时，会阻塞进程。而在有大量计算需要处理的时候，让CPU空转显然是浪费，应该尽可能避免。<br>但多线程提供了一个解决方案，有关的进程可以用一个输入线程、一个处理线程和一个输出线程构造。输入线程把数据读入到输入缓存区中，处理线程从输入缓存区读取数据、处理数据、并把结果放到输出缓存区中；处理线程从输入缓存区中读取数据、处理数据、并把结果放到输出缓存区中；输出线程再把这些结果写道磁盘上。按照这种方式工作，输入、处理和输出可以全部同时进行。当然，这种模型只有当系统调用只阻塞调用线程而不是调用进程时，才能正常工作。  </p><h3 id="2-2-经典的线程模型"><a href="#2-2-经典的线程模型" class="headerlink" title="2.2 经典的线程模型"></a>2.2 经典的线程模型</h3><p>理解进程的一个角度是：用某种方法把相关的资源集中在一起，进程有存放程序正文和数据以及其他资源的地址空间。另一个概念是：进程拥有一个执行的线程(thread)。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p><p>可以这样理解：**<em>进程用于把资源集中在一起，而线程则是在CPU上被调度执行的实体。**</em><br>即：在同一进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘、打印机和其他资源。</p><p><img src="/img/%E5%9B%BE2.3.jpg" alt="avatar"></p><p>进程中的不同线程不像不同进程之间那样存在着很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写、甚至清除另一个线程的堆栈。</p><ul><li>线程概念试/img/图实现的是：共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一个任务而共同工作。</li><li>由于每一个线程都会调用不同的过程，从而有一个各自不同的执行历史，因此每个线程都有其自己的堆栈</li><li>所有线程都是平等的，不论有无层次关系。</li></ul><h3 id="2-3-线程的实现方式"><a href="#2-3-线程的实现方式" class="headerlink" title="2.3 线程的实现方式"></a>2.3 线程的实现方式</h3><ul><li>在用户空间实现线程：此时，每个进程都有一个其专用的线程表(thread table)，用来跟踪该进程中的线程。</li><li>在内核实现线程：每个进程中没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。</li></ul><p><img src="/img/%E5%9B%BE2.4.jpg" alt="avatar"></p><h2 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3.进程间通信"></a>3.进程间通信</h2><h3 id="3-1-临界区"><a href="#3-1-临界区" class="headerlink" title="3.1 临界区"></a>3.1 临界区</h3><p>即：**<em>对共享内存进行访问的程序片段**</em></p><p>如果两个或多个进程同时读写某些共享数据，其最后的结果会取决于进程运行的精确时序，称为竞争条件(race condition)。</p><p>要避免竞争条件，关键是要找出某种途径来阻止多个进程同时读写共享的数据。换言之，我们需要的是互斥(mutual exclusion),即以某种手段确保当一个进程使用一个共享变量或文件时，其他进程不能做同样的操作。</p><h3 id="3-2-同步与互斥"><a href="#3-2-同步与互斥" class="headerlink" title="3.2 同步与互斥"></a>3.2 同步与互斥</h3><ul><li>互斥： 当一个进程在临界区内更新共享内存时，其他进程将不会进入其临界区。即：多个进程在同一时刻只有一个进程能进入临界区。</li><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li></ul><p>注：连续测试一个变量直到某个值出现为止，称为忙等待(busy waiting)。由于这种方式浪费CPU时间，所以通常应该避免。</p><h3 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。如果每个进程在进入临界区前都执行一个down操作，并在退出后都执行一个up操作，就能够实现互斥。</p><ul><li>  <strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>  <strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。所谓原语，即原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<br>semaphore mutex = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P1</span><span class="hljs-params">()</span> </span>&#123;<br>    down(&amp;mutex);<br>    <span class="hljs-comment">// 临界区</span><br>    up(&amp;mutex);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P2</span><span class="hljs-params">()</span> </span>&#123;<br>    down(&amp;mutex);<br>    <span class="hljs-comment">// 临界区</span><br>    up(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-互斥量"><a href="#3-4-互斥量" class="headerlink" title="3.4 互斥量"></a>3.4 互斥量</h3><p>互斥量（mutex）是信号量的一个简化版本。<br>互斥量是一种可以处于两态之一的变量：解锁和加锁。0表示解锁，其他所有的值则表示加锁。互斥量使用两个过程，当一个线程（或进程）需要访问临界区时，它调用mutex_lock。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入临界区，并且互斥量被自动锁定以防止其他线程进入。另一方面，如果该互斥量当前已经加锁，则调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock。</p><p><font size=3>   <strong>使用信号量实现生产者-消费者问题</strong>   </font> </br></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去，造成死锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore empty = N;<br>semaphore full = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        <span class="hljs-keyword">int</span> item = produce_item();<br>        down(&amp;empty);<br>        down(&amp;mutex);<br>        insert_item(item);<br>        up(&amp;mutex);<br>        up(&amp;full);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        down(&amp;full);<br>        down(&amp;mutex);<br>        <span class="hljs-keyword">int</span> item = remove_item();<br>        consume_item(item);<br>        up(&amp;mutex);<br>        up(&amp;empty);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-屏障"><a href="#3-5-屏障" class="headerlink" title="3.5 屏障"></a>3.5 屏障</h3><p>屏障这一同步机制是准备用于进程组而不是用于双进程的生产者-消费者类情形的。它规定：除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。</p><p>可以在通过每个阶段的结尾安置屏障(barrier)来实现这种行为，当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p><p><img src="/img/%E5%9B%BE2.5.jpg" alt="avatar"></p><h2 id="4-调度"><a href="#4-调度" class="headerlink" title="4.调度"></a>4.调度</h2><p>如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序(scheduler)，该程序使用的算法称为调度算法(scheduler algorithm)。</p><p>调度算法分为两类：</p><ul><li>非抢占式调度算法：先挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放CPU,即使该进程运行了若干个小时，它也不会被强迫挂起。</li><li>抢占式调度算法：先挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。</li></ul><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="4-1-批处理系统"><a href="#4-1-批处理系统" class="headerlink" title="4.1 批处理系统"></a>4.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1 先来先服务 first-come first-serverd（FCFS）</strong>  </p><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>2 短作业优先 shortest job first（SJF）</strong>  </p><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>3 最短剩余时间优先 shortest remaining time next（SRTN）</strong>  </p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="4-2-交互式系统"><a href="#4-2-交互式系统" class="headerlink" title="4.2. 交互式系统"></a>4.2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>1 轮转调度</strong><br>每个进程被分配一个时间片，允许该进程在该时间段内运行。如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。</p><p>这个时间片若设计得过短，则会导致过多的进程切换，降低了CPU效率。若设计过程又可能引起对短的交互请求的响应时间边长。</p><p><strong>2 优先级调度</strong><br>核心思想：为每个进程分配一个优先级，按优先级进行调度。  </p><p>将一组进程按优先级分为若干类，并在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。<br>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><strong>3 多级队列</strong><br>属于最高优先级类的进程运行1个时间片，属于次高优先级类的进程运行2个时间片，再次以及运行4个时间片.以此类推，当一个进程用完分配的时间片后，它被移到下一个类。</p><h3 id="4-3-实时系统"><a href="#4-3-实时系统" class="headerlink" title="4.3 实时系统"></a>4.3 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="4-4-线程调度"><a href="#4-4-线程调度" class="headerlink" title="4.4 线程调度"></a>4.4 线程调度</h3><p>首先，对于用户级线程。由于内核并不知道有线程的存在，所以它还是像以前那样操作。在这种情况下，线程无时间片，进程有时间片。多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程运行。</p><p>其次，对于内核级线程。内核选择一个特定的线程运行，它不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，而且超过的时间片，就会强制挂起线程。</p><p><img src="/img/%E5%9B%BE2.6.jpg" alt="avatar"></p><p>此外，从进程A的一个线程切换到进程B的一个线程，其代价高于运行进程A的第2个线程（因为必须修改内存映像，清除内存高速缓存的内容）</p><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><h2 id="5-经典的IPC问题"><a href="#5-经典的IPC问题" class="headerlink" title="5.经典的IPC问题"></a>5.经典的IPC问题</h2><h3 id="5-1-生产者-消费者问题"><a href="#5-1-生产者-消费者问题" class="headerlink" title="5.1 生产者-消费者问题"></a>5.1 生产者-消费者问题</h3><p>如3.4节所述</p><h3 id="5-2-哲学家就餐问题"><a href="#5-2-哲学家就餐问题" class="headerlink" title="5.2 哲学家就餐问题"></a>5.2 哲学家就餐问题</h3><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。  </p><p><img src="/img/%E5%9B%BE2.7.jpg" alt="avatar"></p><p>一种错误的解法时，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h3 id="5-3-读者-写者问题"><a href="#5-3-读者-写者问题" class="headerlink" title="5.3 读者-写者问题"></a>5.3 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h2><p>为了隐蔽中断的影响，操作系统提供了一个由并行运行的顺序进程组成的概念模型。进程可以动态地创建和终止。每个进程都有自己的地址空间。</p><p>在一个进程中使用多个控制线程是有益的。这些线程被独立调度，每个线程都有自己的堆栈，但在一个进程中的所有线程共享一个公共地址空间。线程可以在用户空间或内核中实现。</p><p>进程之间通过进程间通信原语彼此童心，如信号量、管程和消息。这些原语用来确保同一时刻不会有两个进程在临界中。进程可以处在运行、就绪和阻塞状态。</p><p>进程间通信原语可以用来解决诸如生产者-消费者问题、哲学家就餐问题和读者-写者问题等。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/14/hello-world/"/>
    <url>/2021/02/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode：72.编辑距离</title>
    <link href="/2021/02/14/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2021/02/14/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符     </p><pre><code>示例 1：输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)示例 2：输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义dp[i][j] 为 word1的前i个字符word1[0…i-1]转换成word2的前j个字符word2[0…j-1]需要的最少操作数</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><ul><li>首先，空串到到空串不需要任何操作。因此dp[0][0] = 0</li><li>i=0时，要找空串word1匹配到word2前j个字符的最小步数，也即对word1进行插入操作的数量,也就是j</li><li>j=0时，要找word1前i个字符匹配到空串word2的最小步数，也即对word1进行删除操作的数量，也就是i</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><ul><li>当word1[i-1]等于word2[j-1]时，相当于在这一步不需要任何操作，因此dp[i][j] = dp[i-1][j-1]</li><li>当word1[i-1]不等于word2[j-1]，可以对word1[i-1]进行替换、插入、删除三种操作<ol><li><p>替换：将word1[i-1]替换成word2[j-1],需要一次操作。替换后二者相等，于是：dp[i][j] = dp[i - 1][j - 1] + 1</p></li><li><p>插入：在word1[i-1]后面插入与word2[j-1]相等的字符，需要一次操作，插入的字符和word2[j-1]匹配，二者抵消，在word2中就不用再考虑word2[j-1]位置了。于是：dp[i][j] = dp[i][j - 1] + 1</p></li><li><p>删除：既然word1[i-1]与word2[j-1]不相等，那我们就删除掉word1[i-1]这个字符，需要一次操作。于是：dp[i][j] = dp[i - 1][j] + 1  </p><p>最后取上述三种操作的最小值即为dp[i][j],即：<br>$$dp[i][j] = min(dp[i - 1][j - 1],dp[i - 1][j - 1],dp[i - 1][j]) + 1$$</p></li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
