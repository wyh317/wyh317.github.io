<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式分为三种，分别为：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>接下来以pizza店的例子阐述三种模式</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>一句话描述：简单工厂模式将对象的创建封装了起来</strong></p><p>通过工厂类创建对象，并且根据传入参数决定具体要实例化哪种子类对象的做法，叫简单工厂模式(Simpe Factory Pattern)<br>以下代码描述了产品类，包括一个抽象接口和两个具体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Pizza类为接口，description方法由具体的pizza类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//有两种pizza类实现了上面的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am cheesepizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am veggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们构建一个pizza工厂专门负责构造pizza对象。从而把本应在PizzaStore中构造并初始化pizza对象的代码迁移到pizza工厂类的创建方法createPizza中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//pizza工厂类。这个类只做一件事：帮客户创建pizza</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePizzaFactory</span></span>&#123;<br>    <span class="hljs-comment">//在创建方法中传入参数type，根据参数来判断要创建哪种pizza对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String type)</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;cheese&quot;</span>))<br>            pizza = <span class="hljs-keyword">new</span> CheesePizza();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;veggie&quot;</span>))<br>            pizza = <span class="hljs-keyword">new</span> VeggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在客户端（也就是PizzaStore类）中，想要创建哪种对象，只需传入对应的名称即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">(String type)</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个工厂对象factory</span><br>        SimplePizzaFactory factory = <span class="hljs-keyword">new</span> SimplePizzaFactory();<br>        <span class="hljs-comment">//再利用工厂factory创建与type相对应的工厂对象</span><br>        Pizza pizza = factory.createPizza(type);<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法（均可以调用createPizza方法创建pizza对象）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过简单工厂模式，我们可以把客户类和具体子类的实例化解耦，客户端不再需要用众多if else语句根据type判断自己应该实例化哪个子类。现在客户端只需要用将type传入工厂类中的创建方法，即可在在这个方法的返回值中得到想要的对象。</p><p>这样做有什么好处呢？   </p><blockquote><p>设想如果未使用简单工厂模式，在客户端用if else判断并实例化产品对象。当我们有多个客户端的时候，这些客户端就都需要知道产品的细节（即有哪些产品以及需要构建哪种产品对象）。而且如果我们多增加一项产品，那么这么多客户端都需要进行修改（再增加一条if else语句）</p></blockquote><p>简单工厂模式的缺陷：  </p><blockquote><p>即使使用了简单工厂模式，当我们多增加一项产品时，还是要在工厂类的构建方法中增加一条if else语句。这样就不符合”对扩展开放，对修改封闭”的OO原则。</p></blockquote><p>因此就引入了工厂方法模式，我们将在这个模式中解决以上缺陷带来的问题。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>一句话描述：每一个产品子类都有一个对应的工厂子类</strong></p><p>在工厂方法模式中，我们为每一个Pizza子类创建对应的工厂子类，工厂方法模式将构建产品的细节封装进具体的工厂子类中。注意：</p><ul><li>每一个Pizza子类都实现Pizza接口</li><li>每一个工厂子类都实现工厂接口</li></ul><p>因此，我们可以使用某一种具体工厂子类创建其对应的Pizza对象。当新增一种pizza时，我们构建一种和它对应的新工厂子类，就可以构造这种pizza对象。而不用在工厂类中修改代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象的工厂接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-function">Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//以下为两种工厂子类:CheesePizza工厂和VeggiePizza工厂</span><br><span class="hljs-comment">//它们分别实现了工厂接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizzaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">new</span> CheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeggiePizzaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">new</span> VeggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于客户端PizzaStore，想得到哪种Pizza对象，只需要构造与其对应的工厂子类对象，并使用其创建方法即可。连简单工厂模式中的传入type参数这一步都免了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个cheese披萨工厂</span><br>        PizzaFactory cheesefactory = <span class="hljs-keyword">new</span> CheesePizzaFactory();<br>        <span class="hljs-comment">//再利用这个工厂创建我们想要的cheese披萨</span><br>        Pizza pizza = cheesefactory.createPizza();<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg"></p><p>工厂方法模式的缺陷：  </p><blockquote><p>如果我们的产品子类越来越多，那么我们就要为每一个产品子类都创建一个工厂子类，这样类就会越来越多，非常繁琐。</p></blockquote><p>为了解决这个问题，以下引入抽象工厂模式</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>一句话描述：把产品分组，每组配备一个工厂，组内不同产品对应于这个工厂中的不同方法</strong></p><p>在抽象工厂模式中，我们不为每一个产品子类配备一个工厂子类。而是将产品进行分组，每组组内的不同产品由同一个工厂类的不同方法创建。</p><p>假设我们当前有四种pizza产品，分别为：</p><ul><li>大份cheese披萨</li><li>小份cheese披萨</li><li>大份蔬菜披萨</li><li>小份蔬菜披萨</li></ul><p>工厂方法模式的做法是：为这四种产品类都配备一个对应的具体工厂子类。</p><p>而对于抽象工厂模式，我们将产品分为两组：大份组和小份组。每组配备一个工厂。</p><p>以下为产品类：包括cheese披萨和蔬菜披萨两种抽象接口，每种接口分别由大份和小份两个具体类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">cheesePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigcheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cheesePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a BigcheesePizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallcheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cheesePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a SmallcheesePizza&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">veggiePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigveggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">veggiePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a BigveggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallveggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">veggiePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a SmallveggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是工厂类，先定义一个抽象的工厂接口。由于产品有两种（大份披萨和小份披萨），因此我们实现两种工厂类BigFactory和SmallFactory，分别用来构建大披萨对象和小披萨对象。</p><p>此外，每个工厂对应产品分类中的所有产品，工厂类都有一个与其对应的构建方法。例如：我们想得到一个大份cheese披萨对象，那么只需要使用大份pizza工厂中的createCheesePizza()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-function">cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//大份披萨工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>&#123;<br>        cheesePizza pizza = <span class="hljs-keyword">new</span> BigcheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>&#123;<br>        veggiePizza pizza = <span class="hljs-keyword">new</span> BigveggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//小份披萨工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>&#123;<br>        cheesePizza pizza = <span class="hljs-keyword">new</span> SmallcheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>&#123;<br>        veggiePizza pizza = <span class="hljs-keyword">new</span> SmallveggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是客户端代码，通过使用不同的工厂，并调用该工厂中不同的创建方法，我们就可以创造出不同的产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个大份披萨工厂</span><br>        Factory1 BigFactory = <span class="hljs-keyword">new</span> BigFactory();<br>        <span class="hljs-comment">//再利用这个工厂中的相应方法创建我们想要的cheese披萨</span><br>        Pizza pizza = BigFactory.createCheesePizza();<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>一句话描述：控制对其他对象的访问</strong></p><p>代理模式创建代理(Pxory)，让代理控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg"></p><p>RealSubject和Pxory都实现了Subject接口，因此Pxory可以在RealSubject出现的地方取代它。</p><p>代理模式有以下几个代表：</p><ul><li>远程代理：控制访问远程对象</li><li>虚拟代理：控制访问创建开销大的资源</li><li>保护代理：基于权限控制对资源的访问</li></ul><h2 id="远程代理："><a href="#远程代理：" class="headerlink" title="远程代理："></a>远程代理：</h2><p>如果我们要访问的对象在另一个JVM堆中（即在不同的地址空间中运行的远程对象），我们就没办法通过引用来得到这个对象。</p><pre><code>注：Subject a = XXX对于这种语句，a只能引用与当前代码语句所在同一个堆空间的对象。</code></pre><p>对于这种情况，远程代理就可以作为另一个JVM上对象的本地代表。调用代理的方法会被代理利用网络转发给远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>保护代理根据访问权限决定客户是否可以访问对象。</p><p>例如：有一个雇员对象，保护代理允许一个雇员自己调用对象上的某些方法（如setName()),但不允许雇员自己调用类似于setSalary()的方法。<br>而保护代理允许经理调用setSalary()方法，但不允许经理调用setName()方法。<br><img src="%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86.jpg"></p><h2 id="虚拟代理："><a href="#虚拟代理：" class="headerlink" title="虚拟代理："></a>虚拟代理：</h2><p>虚拟代理作为创建开销大的对象的代表。虚拟代理在我们真正需要使用一个对象时才创建这个对象。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。当对象创建后，代理就会将请求直接委托给对象。</p><p><img src="%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86.jpg"></p><h3 id="以下为虚拟代理的实现："><a href="#以下为虚拟代理的实现：" class="headerlink" title="以下为虚拟代理的实现："></a>以下为虚拟代理的实现：</h3><p><strong>背景说明</strong>：当加载一张图片时，限于连接带宽和网络负载，加载可能需要一些时间，所以在等待图像加载的时候，应该显示一些东西。（同时也不希望在显示这些东西时整个应用被挂起）一旦图像被加载完成后，刚才显示的东西应该消失，图像显示出来。</p><p>先定义一个接口Image，代理和真正的图片对象都要实现Image接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Image</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImagePxory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RealImage realImage;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImagePxory</span><span class="hljs-params">(RealImage realImage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.realImage = realImage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//当realImage加载完成时，显示realImage</span><br>        <span class="hljs-comment">//否则显示:Image is loading, please wait</span><br>        <span class="hljs-keyword">while</span>(!realImage.isLoad())&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println((<span class="hljs-string">&quot;Image is loading, please wait&quot;</span>));<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                e.printStackTrace();;<br>            &#125;<br>        &#125;<br>        realImage.showImage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实图片类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> URL imageURL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> startTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealImage</span><span class="hljs-params">(URL imageURL)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.imageURL = imageURL;<br>        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">this</span>.startTime = System.currentTimeMillis();<br>    &#125;<br>    <span class="hljs-comment">//模拟图片加载过程，假定图片加载需要三秒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoad</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">return</span> endTime - startTime &gt; <span class="hljs-number">3000</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(imageURL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    String image = <span class="hljs-string">&quot;http://image.jpg&quot;</span>;<br>    URL url = <span class="hljs-keyword">new</span> URL(image);<br>    RealImage realImage = <span class="hljs-keyword">new</span> RealImage(url);<br>    ImagePxory imagePxory = <span class="hljs-keyword">new</span> ImagePxory(realImage);<br>    imagePxory.showImage();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md">CyC2018: CS-Notes:设计模式</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态地为对象扩展功能。</p><p>在扩展功能这一方面，装饰者模式比继承更有弹性</p><p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>实现背景</strong>：一家咖啡店有多种饮料(如咖啡、豆浆），还有多种调料可以添加（如Whip、Mocha）。每种饮料都有一个基础价格，加完调料后，价格即为基础价格加上调料价格。要求我们要计算一杯加过调料的饮料的价格。</p><p>所有的装饰者和被装饰者都要继承自抽象类Beverage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    String description;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象调料类（装饰者），所有的调料类都需继承自这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CondimentDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-comment">//beverage为被装饰者的引用</span><br>    <span class="hljs-keyword">protected</span> Beverage beverage;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下为两个调料类(装饰者类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下是两个调料类（装饰者）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mocha</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage = beverage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Mocha&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Whip</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Whip</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage = beverage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Whip&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是两个饮料类（被装饰者类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Coffee</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Coffee&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soybean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Soybean</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Soybean&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.6</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    Beverage beverage = <span class="hljs-keyword">new</span> Soybean();<br>    beverage = <span class="hljs-keyword">new</span> Mocha(beverage);<br>    beverage = <span class="hljs-keyword">new</span> Whip(beverage);<br>    System.out.println(beverage.getDescription() + <span class="hljs-string">&quot;, $&quot;</span> + beverage.cost());<br>    Beverage beverage2 = <span class="hljs-keyword">new</span> Coffee();<br>    beverage2 = <span class="hljs-keyword">new</span> Mocha(beverage2);<br>    beverage2 = <span class="hljs-keyword">new</span> Whip(beverage2);<br>    System.out.println(beverage2.getDescription() + <span class="hljs-string">&quot;, $&quot;</span> + beverage2.cost());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode：1143.最长公共子序列</title>
    <link href="/2021/02/15/Leetcode%201143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/02/15/Leetcode%201143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>注：两个字符串的「公共子序列」（Longest Common Subsequence，简称 LCS）是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p><pre><code>示例 1:输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。示例 2:输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。示例 3:输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>遇到子序列相关的问题，可以往动态规划上考虑。这道题让我们在<strong>两个字符串</strong>中寻找共同拥有的最长子序列，因此很容易想到用二维动态规划来解决。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义$dp[i][j]$为：$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度。</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>根据上述dp数组的定义，可以写出如下Base Case：</p><ul><li>i为0时，str1[0…i-1]不构成一个字符串，因此不存在与str2的公共子序列，因此dp[0][j]为0</li><li>j为0时，str2[0…j-1]不构成一个字符串，因此不存在于str1的公共子序列，因此dp[i][0]为0</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><p>当str1遍历到i - 1，str2遍历到j - 1时，即要求$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度时，需要考虑以下的几种情况：</p><ul><li><p>如果str1[i - 1]与str2[j - 1]相等，那么肯定要将其放入str1[0…i−1]和str2[0…j−1]的LCS当中，有了这个字符，LCS的长度就会加1，因此<br>$$dp[i][j] = dp[i - 1][j - 1] + 1$$</p></li><li><p>如果str1[i - 1]与str2[j - 1]不等，则又会分为以下的三种情况：</p><ul><li><p>str1[i - 1]与str2[j - 1]都不放入LCS当中，那么LCS的长度不会产生变化，即dp[i][j] = dp[i - 1][j - 1]</p></li><li><p>str1[i - 1]放入LCS中，但str2[j - 1]不放。这时dp[i][j] = dp[i][j - 1]</p></li><li><p>str1[i - 1]不放入LCS中，但str2[j - 1]放。这时dp[i][j] = dp[i - 1][j]</p><p> 由于在dp[i][j]这个位置可以做上述三种选择，因此取三种选择可能产生的最大值，即为dp[i][j]。即：<br> $$dp[i][j] = max(dp[i - 1][j - 1],dp[i][j - 1],dp[i - 1][j])$$</p></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length() + <span class="hljs-number">1</span>][str2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case,其实可以不用，因为数组初始化时全体元素就为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= str2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= str1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= str1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= str2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1.charAt(i - <span class="hljs-number">1</span>) == str2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[str1.length()][str2.length()];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度:O(m * n)</li><li>空间复杂度:O(m * n)<br>其中，m和n分别为str1和str2的长度</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Morris遍历</title>
    <link href="/2021/02/15/Morris%E9%81%8D%E5%8E%86/"/>
    <url>/2021/02/15/Morris%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h1><p>经典的二叉树遍历，无论是递归还是非递归。其空间复杂度都是O(h),其中h为二叉树的高度。<br>而Morris遍历可以做到时间复杂度O(N), 空间复杂度O(1)</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>记当前来到的节点引用为cur</p><ul><li>如果cur没有左孩子，那么cur向右移动：cur = cur.right</li><li>如果cur有左孩子，那么找到它左子树上最右的节点，记为mostright<ul><li>如果mostright的右指针right指向空，那么让其指向cur，然后cur向左移动：cur = cur.left</li><li>如果mostright的右指针right指向cur, 那么让其指向空，然后cur向右移动：cur = cur.right</li></ul></li></ul><p>举例说明：</p><pre><code>给定二叉树：          1        /   \       2     3      / \   /  \     4   5 6    7Morris遍历流程：1. cur在1：首先cur指向根节点1，当前cur有左孩子，所以找到左子树的最右节点5，5的右指针right现在为空，所以让其指向cur（5的right指向1），然后cur向左移动来到22. cur在2：cur有左孩子，找到其左子树的最右节点4，4的right为空，于是让其指向cur（4的right指向2），然后cur向左移动来到43. cur在4：当前cur没有左孩子，因此向右移动，回到24. cur在2：当前cur左子树的最右节点为4，4的right现在指向cur，于是让它指回空，然后cur向右移动来到55. cur在5：当前cur没有左孩子，因此向右移动，回到16. cur在1：cur左子树的最右节点为5，5的right现在指向cur，于是让它指回空，然后cur向右移动来到37. cur在3：cur左子树的最右节点为6，6的right指向空，于是让它指向cur，然后cur向左移动来到68. cur在5：当前cur没有左孩子，因此向右移动，回到39. cur在3：cur左子树的最右节点为6，6的right指向cur，于是让它指向空，然后cur向右移动来到710. cur在7：当前cur没有左孩子，因此向右移动，发现来到的位置上是空，于是整个遍历结束。总结下来：cur分别经过了1 2 4 2 5 1 3 5 3 7</code></pre><h2 id="Morris遍历的本质"><a href="#Morris遍历的本质" class="headerlink" title="Morris遍历的本质"></a>Morris遍历的本质</h2><p>在经典递归版的遍历中，只要一个节点不空，遍历会来到这个节点三次：</p><ul><li>首先来到这个节点</li><li>遍历完它的左子树后再回到这个节点</li><li>遍历完它的右子树后再回到这个节点</li></ul><p>如果把对这个节点的操作放在第一次来到这个节点的时候，就是先序遍历。<br>如果把对这个节点的操作放在第二次来到这个节点的时候，就是中序遍历。<br>如果把对这个节点的操作放在第三次来到这个节点的时候，就是后序遍历。  </p><p>而在Morris遍历中：</p><ul><li>如果一个节点有左子树，那么Morris遍历会回到它两次。并且第二次回到这个节点时，其左子树上所有的节点一定都已经遍历完了。Morris遍历根据左子树最右节点mostRight的右指针right指向谁来判断是第几次来到当前这个节点（指向空则是第一次，指向cur节点本身则是第二次）。</li><li>如果一个节点没有左子树，那么Morris遍历只会回到它一次</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Morris遍历的先序和中序思想一致，只是对节点操作（以打印为例）的时机不一致。在第一次来到节点时操作为先序，在第二次来到节点时操作为中序。</p><p>Morris遍历的中序遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(TreeNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode cur = head;<br>    TreeNode mostRight = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        mostRight = cur.left;<br>        <span class="hljs-comment">//如果cur有左孩子</span><br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//首先找到cur的左子树的最右节点</span><br>            <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;<br>                mostRight = mostRight.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;<br>                mostRight.right = cur;<br>                cur = cur.left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mostRight.right = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//若该节点有左子树，当把左子树处理完第二次回到这个节点时进行打印行为，即为中序遍历。</span><br>        <span class="hljs-comment">//如果该节点没有左子树，那么只会来到这个节点一次，在这时候打印即可。</span><br>        System.out.print(cur.val + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-comment">//如果cur没有左孩子，cur直接向右移动</span><br>        cur = cur.right;<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>Morris遍历的先序遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(TreeNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode cur = head;<br>    TreeNode mostRight = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        mostRight = cur.left;<br>        <span class="hljs-comment">//如果cur有左孩子</span><br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//首先找到cur的左子树的最右节点</span><br>            <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;<br>                mostRight = mostRight.right;<br>            &#125;<br>            <span class="hljs-comment">//若一个节点有左子树，那么当mosRight的right为空时，为第一次到达这个节点的时候。</span><br><span class="hljs-comment">//在此时进行打印行为，即为先序遍历</span><br>            <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;<br>                mostRight.right = cur;<br>                System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>                cur = cur.left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mostRight.right = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果一个节点没有左子树，那么只会来到这个节点一次，在这个时候打印即可。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果cur没有左孩子，cur直接向右移动</span><br>        cur = cur.right;<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/02/15/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法目的"><a href="#KMP算法目的" class="headerlink" title="KMP算法目的"></a>KMP算法目的</h2><p>在str1中寻找str2出现的位置<br>假设str1长度为N，str2长度为M  </p><p>暴力方法：尝试从str1的每一个位置开始，让str2来匹配，暴力方法时间复杂度：O(MN)</p><h2 id="KMP算法流程："><a href="#KMP算法流程：" class="headerlink" title="KMP算法流程："></a>KMP算法流程：</h2><p><img src="/img/kmp.jpg"></p><ul><li>i1代表str1的索引，i2代表str2的索引。二者都从零位置开始尝试匹配。每一次匹配成功，i1和i2都右移</li><li>当匹配失败时（以图中为例：X != Y)，有一个推论为：在str1从i到j中任何一个位置开始，都匹配不出str2。既然明知匹配不出，那就不用再像暴力法那样从str1中i的下一个位置开始尝试匹配str2。只需从下一个不确定能不能匹配的位置（即j）开始尝试匹配str2。即i1从j开始，i2从0开始。<br>又因为str1中从j到x的字符与str2中Y的前next[Y]个字符相等（曾经匹配成功过），str2中Y的前next[Y]个字符与str2的前next[Y]个字符相等（next数组的定义）。因此可以推出：str1中从j到x的字符与str2中Y的前next[Y]个字符相等。<br>所以str1中从j开始的next[Y]个字符和str2中从0开始的前next[Y]个字符是肯定相等、不用匹配的。因此i1可以直接从X处开始（匹配失败的位置），i2可以直接从next[Y]处开始。</li><li>还需注意一个特殊情况：当i2为str2的第一个位置（next[i2] == -1），且str2中i2与str1中i1对应字符不相等时，意味着str2中第一个位置和str1的i1处都不匹配。那么从str1的i1开始肯定匹配不出str2，于是i1++。</li><li>当while循环退出时，说明str1或str2中的任意一个走到末尾了。如果str2走到末尾了，则说明匹配成功了，返回str2在str1中出现位置的索引：i1-i2。否则，str2没走到末尾str1却走到了末尾，说明匹配失败，str2中没有str1,返回-1。</li></ul><p>Q &amp; A<br>问：为什么当匹配失败时可以说：在str1中从i到j任何一个位置开始，都匹配不出str2？<br>答：假设从str1中i到j的一个位置k开始，可以匹配出str2。即从k到X的这n个字符应该和str2中从0开始的前n个字符匹配（注意：n &gt; next[Y])。又因为str1中k到X的这n个字符已经和str2中Y的前n个字符匹配过了，它们是相等的。于是str2中从0开始的前n个字符（前缀）应该和Y前面的n个字符相等（后缀）。但由next数组的定义可知，它们是不相等的。因此这种假设不成立。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String s, String m)</span></span>&#123;<br>    <span class="hljs-comment">//在s中找不到m，返回-1</span><br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || m == <span class="hljs-keyword">null</span> || m.length() &lt; <span class="hljs-number">1</span> || s.length() &lt; m.length())<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span>[] str1 = s.toCharArray();<br>    <span class="hljs-keyword">char</span>[] str2 = m.toCharArray();<br>    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//根据str生成next数组</span><br>    <span class="hljs-keyword">int</span>[] next = getNextArray(str2);<br>    <span class="hljs-keyword">while</span>(i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length)&#123;<br>        <span class="hljs-keyword">if</span>(str1[i1] == str2[i2])&#123;<br>            i1++;<br>            i2++;<br>        &#125;<br>        <span class="hljs-comment">//next[i2]为1代表i2是str2中的第一个位置，即如果str2中第一个位置和str1的i1位置都不匹配</span><br>        <span class="hljs-comment">//那么让i1加1，让str2和在str1从i1的后一个位置开始匹配</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(next[i2] == -<span class="hljs-number">1</span>)<br>            i1++;<br>        <span class="hljs-keyword">else</span><br>            i2 = next[i2];<br>    &#125;<br>    <span class="hljs-keyword">return</span> i2 == str2.length ? i1 - i2 : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="next数组的构建"><a href="#next数组的构建" class="headerlink" title="next数组的构建"></a>next数组的构建</h2><p>next数组表示str2中任意一个字符<strong>前面的字符串的最长前缀和最长后缀的匹配长度</strong></p><p>比如：str2为abkababkabF,那么F在next数组中对应的数值就为5（F前面字符串的最长前缀和最长后缀最长匹配5个位置，abkab）</p><p>构建next数组的步骤：<br>例如str2为ababcababaK,那么K前面这个a对应的next值为4（最长前缀和最长后缀abab的长度）。现在已知这个next[a]，想要求next[K],于是我们比较next[a]对应的最长前缀的后一个字符c与next[a]对应的最长后缀的后一个字符a,发现二者不等。于是我们再将这个a与next[c]的最长前缀的后一个字符a相比，发现二者相等。于是next[K] = next[c] + 1,即2+1= 3</p><p>注：这里next[K]和next[c]都是简写，实际应该为next[11]和next<a href="%E5%8D%B3%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95%E5%80%BC">5</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(<span class="hljs-keyword">char</span>[] str)&#123;<br>    <span class="hljs-keyword">if</span>(str.length == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];<br>    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//i为当前来到的位置索引</span><br>    <span class="hljs-comment">//cn为i-1对应的最长前缀的下一个字符的位置索引</span><br>    <span class="hljs-comment">//cn可以看作next[i-1]</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; next.length)&#123;<br>        <span class="hljs-keyword">if</span>(str[i - <span class="hljs-number">1</span>] == str[cn])<br>            <span class="hljs-comment">//相当于next[i]=next[i-1]+1</span><br>            next[i++] = ++cn;<br>        <span class="hljs-comment">//如果前一个位置的字符与cn处不等，那么cn往前跳</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cn &gt; <span class="hljs-number">0</span>)<br>            cn = next[cn];<br>        <span class="hljs-comment">//如果不等且cn不能往前跳了(其最长前缀和最长后缀为0）</span><br>        <span class="hljs-keyword">else</span><br>            next[i++] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BFPRT算法</title>
    <link href="/2021/02/15/BFPRT%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/BFPRT%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h1><h2 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h2><p>在无序数组中找到第K小的数，时间复杂度O(N)</p><h2 id="基于partition思路的算法"><a href="#基于partition思路的算法" class="headerlink" title="基于partition思路的算法"></a>基于partition思路的算法</h2><p>和快速排序中partition的思想有些相像。比如说我们要在长度为1000的数组中找到第n小的数，于是我们现在数组中随机找一个数进行partition的过程，小于它的放左边，等于它的放中间，大于它的放右边。完成后的情况如下图所示，等于区域范围为500-600</p><p><img src="/img/BFPRT.jpg"></p><p>因为我们要找第n小的数，因此：</p><ul><li>如果500 &lt; n &lt; 600,因此这个第n小的数就在等于区域，即我们进行partition的基准元素。</li><li>如果n &lt; 500, 那么这个第n小的数肯定在小于区域，我们继续对小于区域进行partition过程。</li><li>如果n &gt; 600，那么这个第n小的数肯定在大于区域，我们继续对大于区域进行partition过程。</li></ul><p>该算法的平均时间复杂度基于概率，其长期期望为:O(N)</p><h2 id="BFPRT算法-1"><a href="#BFPRT算法-1" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><p>BFPRT算法的时间复杂度不基于概率，严格O(N)</p><p>BFPRT与上述算法的唯一区别在于：<strong>选择partition基准元素的这一步不是随机选取的</strong>。一旦选好了这个基准元素，之后的过程和上述算法相同。 </p><p>选择基准元素的方式：</p><ol><li>先将长度为N的数组进行分组，每5个元素一组</li><li>在每一组的组内进行排序(组间不排序)，也即将每一个长度为5的小组排序，小组内排序的时间复杂度为O(1)，一共有N/5个小组，因此这一步的时间复杂度为O(N)</li><li>将每一小组的中位数拿出来，构成一个长度为N/5的新数组</li><li>递归调用BFPRT算法，找到新数组中的中位数num</li><li>将这个元素num作为基准元素，进行partition</li></ol><p>为什么要这么选基准元素：<br>num在长度为N/5的新数组中是中位数，因此这个新数组中有N/10个数比num大，这N/10个数中的每个数a在它的原数组里又是中位数，即长度为5的原数组中有2个数比a大。因此，所有比num大的数统计起来，至少有$3N/10$个，也即最多有$7N/10$个数比num小.</p><p>同理，如果统计比num小的数，发现至少也有$3N/10$个数比它小，即最多有$7N/10$个数比num大.</p><p>那么我们用这个num做划分进行partition，会发现最多就有$7N/10$个数比它大，也最多有$7N/10$个数比它小。因此，下一步partition的范围最多也就是$7N/10$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>选基准元素的代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在arr中从begin到end间的元素范围内，选基准元素的过程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">medianOfMedians</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num = end - begin + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> offset = num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//mArr为中位数构成的新数组</span><br>    <span class="hljs-keyword">int</span>[] mArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num / <span class="hljs-number">5</span> + offset];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mArr.length; i++)&#123;<br>        <span class="hljs-comment">//beginI和endI为每个长度为5的小组的首尾</span><br>        <span class="hljs-keyword">int</span> beginI = begin + i * <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">int</span> endI = beginI + <span class="hljs-number">4</span>;<br>        <span class="hljs-comment">//取出每个小组的中位数，构成新数组</span><br>        mArr[i] = getMedian(arr, beginI, Math.min(end, endI));<br>    &#125;<br>    <span class="hljs-comment">//返回新数组的中位数</span><br>    <span class="hljs-keyword">return</span> bfprt(mArr, <span class="hljs-number">0</span>, mArr.length - <span class="hljs-number">1</span>, mArr.length / <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">//返回数组arr中从begin到end间所有元素的中位数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - begin + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)<br>        res[index++] = arr[i];<br>    Arrays.sort(res);<br>    <span class="hljs-keyword">return</span> res[res.length / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>获得基准元素pivot后，以它为基准进行partition操作，并进入BFPRT流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinKthByBFPRT</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] copyArr = Arrays.copyOf(arr, arr.length);<br>    <span class="hljs-keyword">return</span> bfprt(copyArr, <span class="hljs-number">0</span>, copyArr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//bfprt算法主体，在begin和end间的范围里求第i小的数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfprt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(begin == end)<br>        <span class="hljs-keyword">return</span> arr[begin];<br>    <span class="hljs-comment">//求每个小组中位数组成的新数组的中位数</span><br>    <span class="hljs-keyword">int</span> pivot = medianOfMedians(arr, begin, end);<br>    <span class="hljs-comment">//将pivot作为基准元素进行partition，返回等于区域的范围</span><br>    <span class="hljs-keyword">int</span>[] pivotRange = partition(arr, begin, end, pivot);<br>    <span class="hljs-keyword">if</span>(i &gt;= pivotRange[<span class="hljs-number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> arr[i];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; pivotRange[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> bfprt(arr, begin, pivotRange[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> bfprt(arr, pivotRange[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, end, i);<br>&#125;<br><br><span class="hljs-comment">//在数组arr中从begin到end的范围内以pivot为基准元素进行划分，返回等于区域范围</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> pivot)&#123;<br>    <span class="hljs-comment">//用small分别代表小于区域的右边界和大于区域的左边界，初始化时两个区域都没有元素</span><br>    <span class="hljs-keyword">int</span> small = begin - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> big = end + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cur = begin;<br>    <span class="hljs-keyword">while</span>(cur != big)&#123;<br>        <span class="hljs-keyword">if</span>(arr[cur] &lt; pivot)<br>            swap(arr, ++small, cur++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[cur] &gt; pivot)<br>            swap(arr, --big, cur);<br>        <span class="hljs-keyword">else</span><br>            cur++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;small + <span class="hljs-number">1</span>, big - <span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Manacher遍历</title>
    <link href="/2021/02/15/Manacher%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/Manacher%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><h2 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h2><p>一个字符串中找到最长回文子串</p><h2 id="暴力方法（中心扩展法）"><a href="#暴力方法（中心扩展法）" class="headerlink" title="暴力方法（中心扩展法）"></a>暴力方法（中心扩展法）</h2><p>假设字符串的长度为N，那么回文串可能的中心有2N-1种。其中，每个单字符串都可作为回文串的中心，这种情况有N种。其次，双字符串也可作为回文串的中心，这种情况有N-1种。单字符中心负责扩展成长度为奇数的字符串，双字符串中心可以扩展成长度为偶数的字符串。例如：</p><ul><li><p>字符串“aba”有5种可能的中心：a、b、c、ab、ba  </p></li><li><p>字符串“abba”有7种可能的中心：a、b、b、a、ab、bb、ba</p><p>中心扩展法的基本思想为：对于每一个中心都计算一次以其为中心的最长回文串长度</p></li></ul><p>具体算法：对于每一个可能的回文中心，都尽可能地扩展它对应的回文区间[left, right]，直到left=N或者S[left]不等于S[right]为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.length();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> left = i / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> right = left + i % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>            String tmp = s.substring(left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (tmp.length() &gt; res.length()) &#123;<br>                res = tmp;<br>            &#125;<br>            left--;<br>            right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li></ul><h2 id="Manacher算法-1"><a href="#Manacher算法-1" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>一些概念：</p><ul><li>回文半径数组：记录以每一个位置为中心的回文半径的长度</li><li>最右回文右边界：所有位置对应的回文半径中最靠右的位置</li><li>回文右边界的中心：得到最右回文右边界的回文半径的回文中心是哪里（由哪个中心向右扩展得到最右回文右边界）</li></ul><p>在回文右边界和回文左边界中的字符串是回文串。假设最右回文右边界R的中心是c，当前位置i关于c在其左边的对称位置为i’。</p><p><img src="/img/Manacher.jpg"></p><p>算法步骤：<br>分析四种情况</p><ol><li>i在R外，用暴力法扩展。</li><li>i在R里，i’的回文半径整体彻底在L（回文左边界）和R的内部，那么以i为中心的回文半径等于以i’为中心的回文半径</li><li>i在R里，i’的回文半径在L和R的外面，那么以i为中心的回文半径等于i到R的距离</li><li>i在R里，i’的回文左边界和L压线，那么要将i’的回文半径继续向外扩展（i到R的区域肯定在i的回文半径里，不需扩展。R右边是否在i的回文半径里还不清楚，需要扩展才知道)</li></ol><p>上面四种情况中，需要扩展的只有情况1和情况4，对于情况2和情况3，以i为中心的回文半径可以用O(1)的时间开销直接得出。而情况1和情况4在扩展时，R不断向右扩。只要进行一次成功的扩展，R都必然会增加。也就是说R最多就是从0位置到n位置（n为字符串长度)且R不会回退，所以**<em>整个Manacher算法的时间复杂度为O(N)**</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给定一个字符串，返回它的最长回文字串长度</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//将字符串扩展为manacher字符串（每个字符中间和字符串前后加#)</span><br>    <span class="hljs-comment">//因为扩展后字符串长度翻倍，因此求扩展后的字符串的最大回文半径，即求原来字符串的最大回文直径</span><br>    <span class="hljs-keyword">char</span>[] charArr = manacherString(str);<br>    <span class="hljs-comment">//pArr为回文半径数组</span><br>    <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[charArr.length];<br>    <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//max记录最长的回文半径长度</span><br>    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != charArr.length; i++) &#123;<br>        <span class="hljs-comment">//i在R里时：对于情况2和3，在i&#x27;的回文半径和i与R的距离中取较小值，即为i的回文半径</span><br>                 <span class="hljs-comment">//对于情况4，先将回文半径设为R-i，再在之后while循环中将回文半径继续向外扩展</span><br>        <span class="hljs-comment">//i在R外时，先将i位置的回文半径置为1，之后再在while循环里扩展</span><br>        pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//情况2和情况3即使进入了该while循环，但是第一次if都不会成立，会直接break退出循环</span><br>        <span class="hljs-comment">//只有情况1和情况4会在while循环里进行回文半径的扩展。</span><br>        <span class="hljs-keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])<br>                pArr[i]++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//更新最大回文右边界R和其对应的回文中心C</span><br>        <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;<br>            R = i + pArr[i];<br>            C = i;<br>        &#125;<br>        <span class="hljs-comment">//更新max</span><br>        max = Math.max(max, pArr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//生成manacher字符串，将给定字符串str的两端和每个字符中间全加上特殊符号#</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;<br>    <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();<br>    <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> C = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;<br>        res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[C++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2021/02/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了一簇算法，并把它们分别封装起来，让它们之间可以相互替换。此模式让算法的变化独立于使用算法的客户。</p><p><img src="/img/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义一个算法簇：描述鸭子的不同飞行行为.算法簇包含两个具体的算法(行为)：FlyWithWings和FlyNoWay。它们都实现自接口FlyBehavior</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I can fly with wings&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyNoWay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I can&#x27;t fly&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下为鸭子类，它不需要知道飞行行为的具体细节。因为它已将飞行行为委托给别人处理，而不是在Duck类内部定义这些行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span></span>&#123;<br>    <span class="hljs-comment">//FlyBehavior实例变量是一个接口类型，我们能在运行时利用多态为它指定不同的具体实现类。</span><br>    <span class="hljs-keyword">private</span> FlyBehavior flyBehavior;<br>    <span class="hljs-comment">//不在乎flyBehavior接口的对象是什么，只关心该对象知道如何进行fly动作就够了。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performFly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(flyBehavior != <span class="hljs-keyword">null</span>)<br>            flyBehavior.fly();<br>    &#125;<br>    <span class="hljs-comment">//为这个鸭子类设置给定的飞行行为</span><br>    <span class="hljs-comment">//在运行时想改变鸭子的飞行行为，只需调用这个方法即可</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlyBehavior</span><span class="hljs-params">(FlyBehavior flyBehavior)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flyBehavior = flyBehavior;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，因为飞行行为已经和鸭子类解耦（实际上二者为组合关系），因此飞行动作也可以被其他类的对象复用。而且当我们新增飞行行为时，只需要多创建一个实现飞行接口的具体行为类即可，不会影响到既有的具体行为类，也不会影响使用到飞行行为的Duck类。</p><p>以下为客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Duck duck = <span class="hljs-keyword">new</span> Duck();<br>        duck.setFlyBehavior(<span class="hljs-keyword">new</span> FlyWithWings());<br>        duck.performFly();<br>        duck.setFlyBehavior(<span class="hljs-keyword">new</span> FlyNoWay());<br>        duck.performFly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出将依次为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">I can fly <span class="hljs-keyword">with</span> wings<br>I can<span class="hljs-symbol">&#x27;t</span> fly<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/14/hello-world/"/>
    <url>/2021/02/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode：72.编辑距离</title>
    <link href="/2021/02/14/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2021/02/14/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符     </p><pre><code>示例 1：输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)示例 2：输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义dp[i][j] 为 word1的前i个字符word1[0…i-1]转换成word2的前j个字符word2[0…j-1]需要的最少操作数</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><ul><li>首先，空串到到空串不需要任何操作。因此dp[0][0] = 0</li><li>i=0时，要找空串word1匹配到word2前j个字符的最小步数，也即对word1进行插入操作的数量,也就是j</li><li>j=0时，要找word1前i个字符匹配到空串word2的最小步数，也即对word1进行删除操作的数量，也就是i</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><ul><li>当word1[i-1]等于word2[j-1]时，相当于在这一步不需要任何操作，因此dp[i][j] = dp[i-1][j-1]</li><li>当word1[i-1]不等于word2[j-1]，可以对word1[i-1]进行替换、插入、删除三种操作<ol><li><p>替换：将word1[i-1]替换成word2[j-1],需要一次操作。替换后二者相等，于是：dp[i][j] = dp[i - 1][j - 1] + 1</p></li><li><p>插入：在word1[i-1]后面插入与word2[j-1]相等的字符，需要一次操作，插入的字符和word2[j-1]匹配，二者抵消，在word2中就不用再考虑word2[j-1]位置了。于是：dp[i][j] = dp[i][j - 1] + 1</p></li><li><p>删除：既然word1[i-1]与word2[j-1]不相等，那我们就删除掉word1[i-1]这个字符，需要一次操作。于是：dp[i][j] = dp[i - 1][j] + 1  </p><p>最后取上述三种操作的最小值即为dp[i][j],即：<br>$$dp[i][j] = min(dp[i - 1][j - 1],dp[i - 1][j - 1],dp[i - 1][j]) + 1$$</p></li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
