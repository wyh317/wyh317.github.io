<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Data Mesh</title>
    <link href="/2024/03/13/Data-Mesh/"/>
    <url>/2024/03/13/Data-Mesh/</url>
    
    <content type="html"><![CDATA[<h2 id="What-is-Data-Mesh"><a href="#What-is-Data-Mesh" class="headerlink" title="What is Data Mesh"></a>What is Data Mesh</h2><p>A set of principles to build a modern data architecture. Like microservice is a set of principles to build a modern software.</p><p>We can think about data mesh as a network (include nodes and connections) to exchange data about the business. The nodes in the mesh are data products, which are grouped into domains. The nodes will produce and consume high-quality data within the mesh. The interoperability between nodes is under <strong>centralized governance **and standardization and enabled by a shared and **centralized self-serve data infrastructure</strong><br /></p><p><img src="/img/DataMesh.jpg"></p><h2 id="Why-we-need-data-mesh"><a href="#Why-we-need-data-mesh" class="headerlink" title="Why we need data mesh"></a>Why we need data mesh</h2><p>Generally, an enterprise always has a centralized data platform, with a centralized team who owns and curates the data from all domains. However, this approach has some disadvantages:</p><ul><li>The centralized data team has less understanding about the product data than the product domain team.</li><li>The increasing sources need to be ingested by the centralized data platform team.</li><li>The increasing consumer needs need to be satisfied by the centralized data platform team</li></ul><p>The ingest, process and serve are coupled. So the monolithic platform, is the smallest unit that must change to cater for a new functionality: unlocking a new dataset and making it available for new or existing consumption. This limits our ability to achieve higher velocity and scale in response to new consumers or sources of the data.<br />The motivation behind breaking a system down into its architectural quantum is to create independent teams who can each build and operate an architectural quantum. Parallelize work across these teams to reach higher operational scalability.</p><h2 id="Data-mesh-principles："><a href="#Data-mesh-principles：" class="headerlink" title="Data mesh principles："></a>Data mesh principles：</h2><p>In short：</p><ul><li><p><strong>Decentralized Ownership</strong>: Data ownership by domain. Data in data mesh is broken down around a specific domain. Data is closely related with the microservice that produce that data.</p></li><li><p><strong>Data as a product</strong>: Data is considered as a product by each domain team that publish it. The domain team has to engage in product thinking for that data.</p></li><li><p><strong>Centralized Infrastructure</strong>: Data is available and self-serve anywhere in the company using the centralized infrastructure.</p></li><li><p><strong>Centralized Governance</strong></p><h3 id="Decentralized-Ownership"><a href="#Decentralized-Ownership" class="headerlink" title="Decentralized Ownership"></a>Decentralized Ownership</h3><p>Data ownership by domain<br />Distributed data products owned by independent domain teams who have embedded data engineers and data product owners, using common data infrastructure as a platform to host, prep and serve their data assets.</p><h3 id="Data-as-a-product"><a href="#Data-as-a-product" class="headerlink" title="Data as a product"></a>Data as a product</h3><p>In operational domains，Domain teams provide their capabilities as APIs to the rest of the developers in the organization, as building blocks of creating higher order value and functionality. The teams strive for creating the best developer experience for their domain APIs; including discoverable and understandable API documentation, API test sandboxes, and closely tracked quality and adoption KPIs. For a distributed data platform to be successful, domain data teams must apply product thinking with similar rigor to the datasets that they provide; considering their data assets as their products and the rest of the organization’s data scientists, ML and data engineers as their customers.</p><h3 id="Centralized-Governance"><a href="#Centralized-Governance" class="headerlink" title="Centralized Governance"></a>Centralized Governance</h3><p>From a single platform team extracting and owning the data for its use, to each domain team providing its data as a product in a discoverable fashion. </p></li><li><p>Discoverability: Each domain data product must register itself with this centralized data catalog for easy discoverability.</p></li><li><p>Inter-operable and governed by global standards: For example, to be able to correlate the data about an tenant across different domain data products,  we need to consider ‘tenant’ with a federated entity and a unique global federated entity identifier for the ‘tenant’.</p><h3 id="Centralized-Infrastructure"><a href="#Centralized-Infrastructure" class="headerlink" title="Centralized Infrastructure"></a>Centralized Infrastructure</h3><p>A data infrastructure team can own and provide the necessary technology that the domains need to capture, process, store and serve their data products.<br />The key to building the data infrastructure as a platform is:</p></li><li><p>Not to include any domain specific concepts or business logic</p></li><li><p>Make sure the platform hides all the underlying complexity and provides the data infrastructure components in a self-service manner.</p></li></ul><p>A success criteria for self-serve data infrastructure is lowering the time to create a new data product on the infrastructure. </p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>History of data platform architecture</title>
    <link href="/2024/03/12/History-of-data-platform-architecture/"/>
    <url>/2024/03/12/History-of-data-platform-architecture/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/DataPlatformHistory.jpg"></p><h1 id="Data-warehousing"><a href="#Data-warehousing" class="headerlink" title="Data warehousing:"></a>Data warehousing:</h1><p>The history of data warehousing started with helping business leaders get analytical insights by collecting data from operational databases into centralized warehouses, which then could be used for decision support and business intelligence (BI). Data in these warehouses would be written with schema-on-write, which ensured that the data model was optimized for downstream BI consumption.  </p><p><img src="/img/DataWarehouse.jpg"></p><h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge:"></a>Challenge:</h3><ul><li><strong>Couple compute and storage</strong>, can not scale respectively.</li><li>More and more datasets were completely <strong>unstructured</strong>, e.g., video, audio, and text documents, which data warehouses could not store and query at all.</li><li>Most organizations are now deploying machine learning and data science applications, but these are not well served by data warehouses. None of the leading machine learning systems, such as TensorFlow, PyTorch and XGBoost, work well on top of warehouses. Unlike BI queries which extract a small amount of data, these systems need to process large datasets using complex non-SQL code. Reading this data via ODBC/JDBC is inefficient, and there is no way to directly access the internal warehouse formats.</li></ul><h1 id="Data-lake"><a href="#Data-lake" class="headerlink" title="Data lake"></a>Data lake</h1><p>Starting from 2010s,<br />Low-cost storage systems with a file API that hold data in generic open file formats, such as Apache Parquet and ORC. This approach started with the Apache Hadoop movement, using the Hadoop File System (HDFS) for cheap storage. Starting from 2015, cloud data lakes, such as S3, ADLS and GCS, started replacing HDFS. The data lake was a schema-on-read architecture that enabled the agility of storing any data at low cost, but on the other hand, caused the problem of <strong>data quality and governance</strong>. The use of open formats made data lake data directly accessible to a wide range of other analytics engines, such as machine learning systems. And a small subset of data in the lake would later be ETLed to a downstream data warehouse (such as Teradata, Redshift or Snowflake) for the most important decision support and BI applications. This two-tier data lake + warehouse architecture is now dominant in the industry.<br /><img src="/img/DataLake.jpg"><br /><img src="/img/DataLakeAzure.jpg"></p><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge:"></a>Challenge:</h3><ul><li>In the first generation platforms, all data was ETLed from operational data systems directly into a warehouse. In today’s architectures, data is first ETLed into lakes, and then again ELTed into warehouses. The increased number of ETL/ELT jobs, spanning multiple systems, increases the complexity and the probability of failures and bugs.</li><li>Reliability: Keeping the data lake and warehouse consistent is difficult and costly</li><li><strong>Data staleness</strong>. The data in the warehouse is stale compared to that of the data lake, with new data frequently taking days to load.</li><li>Cost: Apart from paying for continuous ETL, users pay double the storage cost for data copied to a warehouse, and commercial warehouses lock data into internal formats that increase the cost of migrating data or workloads to other systems.</li><li>Lack of <strong>data management</strong>: Such as ACID transactions, data versioning and indexing</li></ul><h1 id="Lakehouse"><a href="#Lakehouse" class="headerlink" title="Lakehouse"></a>Lakehouse</h1><p>Currently, cloud datawarehouse systems have all added support to read external tables in data lake formats. However, these systems cannot provide any management features over the data in data lakes (e.g., implement ACID transactions over it) the same way they do for their internal data. </p><p>A more feasible way is building the metadata layer based on data lake, to combine these advantage of both data lake and data warehouse.</p><ul><li>SQL Performance and management features of data warehouses</li><li>Low cost, open format accessible by a variety of systems , and machine learning/data science support of data lake</li></ul><p><img src="/img/LakeHouse.jpg"><br />Apache Hive metastore also can tracks which data files are part of a Hive table at a given table version using an OLTP DBMS(metadata layer) and allows operations to update this transactionally. Buy there are some difference between LakeHouse solution and Apache Hive:</p><ul><li>Data Quality and Governance: Hive does not provide built-in mechanisms for data quality checks or schema enforcement, making it less suitable for enforcing data governance policies. Lakehouse solution such as Delta Lake, on the other hand, provides schema enforcement and supports data quality checks through the use of constraints, allowing users to ensure data integrity and enforce governance policies.</li><li>Data Consistency and Reliability: Hive provides eventual consistency, meaning that changes made to the data may not be immediately reflected in queries until the data is fully loaded, making it suitable for batch processing. Lakehouse solution such as Delta Lake, on the other hand, provides strong consistency and reliability by supporting ACID transactions, ensuring that data operations are atomic and isolated. This makes it suitable for both batch and real-time processing scenarios.</li><li>Data Operations: Hive supports SQL-like queries and a high-level language called HiveQL for processing and analyzing data. Lakehouse solution such as Delta lake and Iceberg not only support SQL operation like SparkSQL, but also support dataframe API for machine learning system to interact with it.</li><li>Hive needs to an independent OLTP DBMS metastore as metadata layer. When the data partition is particularly large, theperformance of metastore is insufficient, which causes the query performance can not meet the business needs. Lake house solutions such as Delta lake and Iceberg, on the other hand, build its metadata layer based on blob storage, which can easily scale.</li></ul><p>Key techniques for Lakehouse solutions to implement SQL performance optimizations:</p><ul><li>Caching: cache files from the cloud object store on faster storage devices such as SSDs and RAM on the processing nodes</li><li>Auxiliary data: Lakehouse solution such as Delta Lake will maintain column min-max statistics for each data file, which enables data skipping optimizations when the base data is clustered by particular columns</li><li>Data layout: records are clustered together and hence easiest to read together. Lakehouse solution such as Delta Lake support ordering records using individual dimensions or spacefilling curves such as Z-order</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据发展历程</title>
    <link href="/2023/11/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <url>/2023/11/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>大数据技术在过去几十年中取得了巨大的发展。从最初的数据仓库概念，到后来的Hadoop技术和数据湖、再到如今的大数据平台和数据中台，每一个阶段带动着技术和业务的变革。</p><p>本文将梳理大数据发展的历程，包含数据仓库、数据湖、大数据平台和数据中台四个阶段。并运用”Why-What-How”的结构分别梳理每个阶段的演变原因，要解决的问题以及支撑技术。</p><h1 id="数据仓库："><a href="#数据仓库：" class="headerlink" title="数据仓库："></a>数据仓库：</h1><ul><li>Why：随着企业信息化程度的不断提高，企业需要已有的数据转化为知识，帮助管理者做出经营分析决策。因此，在上世纪90年代数据仓库应运而生。需要集成企业多个业务系统的数据，进行大数据量的查询。</li><li>What: 数据仓库是在企业管理和决策中面向主题的、集成的、与事件相关的、不可修改的数据集合。</li><li>How: <ul><li>使用ETL（Extract, Transform, Load）过程，将来自不同业务系统的数据集成到一起，使得数据能够被高效地管理</li><li>OLAP技术使得数据分析师可以从不同维度进行高效的数据分析和查询。</li></ul></li><li>特点：<ul><li>当面临海量规模的数据时，传统的数据仓库难以扩展。</li><li>传统的数据仓库只能处理有严格schema的结构化数据，无法处理半结构化和非结构化数据。<h1 id="数据湖："><a href="#数据湖：" class="headerlink" title="数据湖："></a>数据湖：</h1></li></ul></li><li>Why：随着互联网时代的来临，由于数据规模进一步扩大，数据也不仅仅是结构化的数据，传统的数据仓库无法支撑。2000年代初，Google的三驾马车以及开源的Hadoop技术将大数据的发展带入了数据湖时代。</li><li>What: 数据湖是一个以原始格式存储海量结构化和非结构化数据的存储系统。</li><li>How：由以下技术支撑<ul><li>分布式存储：Hadoop Distributed File System（HDFS），Amazon S3，Azure Data Lake Storage（ADLS）等</li><li>分布式计算：Apache Hadoop、Apache Spark、Apache Flink等</li><li>SQL查询引擎：Hive、Impala、Spark SQL等</li><li>任务调度框架：Azkaban、Oozie等</li><li>数据迁移工具：Sqoop等</li><li>日志收集框架：Flume等</li><li>集群资源管理框架：Yarn等</li><li>分布式协调服务：Zookeeper等</li></ul></li><li>特点：<ul><li>完全分布式，易扩展</li><li>可以存储结构化、非结构化、半结构化数据<h1 id="大数据平台："><a href="#大数据平台：" class="headerlink" title="大数据平台："></a>大数据平台：</h1></li></ul></li><li>Why：数据开发涉及的技术和流程繁多。技术方面，Hadoop生态圈技术繁多，技术门槛限制了其易用性。流程方面，数据开发流程包括但不限于：数据集成，数据开发，数据测试，任务部署及运维，数据质量监测等。面对如此复杂的流程，如果没有高效的平台作为支撑，就如同写代码没有IDE，效率低下。大数据平台就是为了提高数据开发的效率，降低数据开发的门槛，让数据能够快速地被加工。</li><li>What: 大数据平台是面向数据研发场景的、覆盖数据研发完整工作链路的工具集合和数据工作台</li><li>How: 大数据平台一般具有以下组件<ul><li>大数据基础设施（存储，计算，任务调度）</li><li>数据集成工具</li><li>数据开发工具（离线，实时）</li><li>数据测试工具</li><li>任务监控及运维中心<h1 id="数据中台："><a href="#数据中台：" class="headerlink" title="数据中台："></a>数据中台：</h1></li></ul></li><li>Why：随着企业数据规模的进一步扩大以及数据需求的快速增长，当报表、数据资产、指标越来越多时，出现了数据质量差、取数效率低、数据重复建设等问题，阻碍数据进一步产生价值。企业需要应对数据治理的挑战</li><li>What: 数据中台强调数据治理以及数据的规范化建设，通过构建统一的公共数据层，打造统一、标准、共享、安全的数据体系。</li><li>How：数据中台一般具有以下组件（自顶向下）<ul><li>数据应用</li><li>数据服务：支持通过API暴露数据给数据应用</li><li>公共数据层</li><li>数据治理：元数据管理，数据质量，数据地图（Data Catalog)，数据安全与合规。</li><li>大数据平台（包括大数据基础设施及数据集成、开发、测试，任务运维等工具）</li><li>大数据基础设施</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spark数据缓存机制及错误容忍机制</title>
    <link href="/2023/07/06/Spark%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E9%94%99%E8%AF%AF%E5%AE%B9%E5%BF%8D%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/07/06/Spark%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E9%94%99%E8%AF%AF%E5%AE%B9%E5%BF%8D%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>本文将重点介绍Spark框架中两个关键特性：数据缓存机制和错误容忍机制。数据缓存机制使得数据能够在内存中共享和重复使用，从而极大地提高了任务的执行速度。错误容忍机制则保证了即使在分布式环境中出现故障或错误，Spark仍能保持稳定运行，从而提供可靠的数据处理。</p><h1 id="Spark数据缓存机制"><a href="#Spark数据缓存机制" class="headerlink" title="Spark数据缓存机制"></a>Spark数据缓存机制</h1><p>理解Spark的数据缓存机制，首先需要回答以下几个问题：</p><ul><li>哪些数据需要缓存：多个job共同依赖的、会被重复使用的中间数据。这类数据一旦缓存起来可以避免重复计算以减少job的执行时间。此外，被缓存的数据也不宜过大，数据过大内存不足时虽然可以存在磁盘，但磁盘I/O同样是个耗时操作，有时甚至不如重新计算快。</li><li>缓存操作会立即执行吗：缓存操作cache()是个lazy操作，不会立即执行。即执行到cache()操作时，只标记这个RDD需要被缓存到内存中，并不执行真正的缓存操作，只有等到遇到action()操作触发job运行时才会实际执行缓存操作。当需要缓存的RDD中的record被计算出来时，及时进行缓存。</li><li>包含缓存时如何生成DAG图：Spark首先假设应用没有数据缓存，照常生成DAG。然后将被缓存的RDD前所有的RDD都去掉，得到削减后的DAG图。最后按照正常的规则将DAG图转为stage和task。</li></ul><h2 id="缓存写入与缓存读取（memoryStore"><a href="#缓存写入与缓存读取（memoryStore" class="headerlink" title="缓存写入与缓存读取（memoryStore)"></a>缓存写入与缓存读取（memoryStore)</h2><p>Spark在每个Executor进程中分配一个区域(memoryStore)来进行数据缓存，该区域由BlockManager来管理。由下图所示，menoryStore中包含了一个LinkedHashMap，用来存储RDD的分区。该LinkedHashMap的Key是blockId，即rddId+partitionId，value是分区中的数据</p><p><img src="/img/%E5%9B%BE7.9.png"></p><p>在上图的例子中，mappedRDD的partition0和partition1被worker节点1中的BlockManager缓存，而partition2被worker节点2中的BlockManager缓存。对于图中的第2个job来说，它的3个task都被分到了worker节点1上，其中task3和task4对应的CachedPartition在本地，因此可以直接通过Worker节点1的menoryStore读取，而task5对应的CachedPartition在节点2上，需要远程访问。</p><p>注：缓存机制只适用于每个Spark应用内部，即缓存数据只能在job之间共享，应用之间不能共享缓存数据</p><h2 id="缓存的替换与回收"><a href="#缓存的替换与回收" class="headerlink" title="缓存的替换与回收"></a>缓存的替换与回收</h2><ul><li>  自动缓存替换：缓存替换指的是当需要缓存的RDD大于当前可利用的空间时，使用新的RDD替换掉旧的以腾出空间。Spark采用LRU(Least Recently Used)替换算法，即优先替换掉当前最长时间没有被使用过的RDD。</li><li>  主动缓存回收：除了自动缓存替换外，Spark还允许用户通过unpersist()操作自己设置回收的RDD和回收时间。不同于persist()的延时生效，unpersist()是立即生效的。</li></ul><h2 id="与MapReduce缓存机制的对比"><a href="#与MapReduce缓存机制的对比" class="headerlink" title="与MapReduce缓存机制的对比"></a>与MapReduce缓存机制的对比</h2><ul><li>  它的缓存机制主要基于磁盘存储，将中间计算结果写入磁盘，以便后续任务可以从磁盘读取并继续处理。这种机制可以减少重复计算和提高任务的容错能力，但由于涉及磁盘读写，对于迭代式算法和需要频繁访问中间结果的任务来说，性能不够高效</li><li>  Spark提供了内存缓存机制。Spark的RDD可以在集群的内存中持久化，以便后续任务可以更快地访问它们。因为数据可以在内存中共享和重复使用，避免了磁盘读写的开销，可以实现更高的性能。此外，Spark的缓存机制也更加灵活，它允许开发人员在需要时手动选择哪些数据需要缓存，以及选择缓存数据的存储级别。</li></ul><h1 id="错误容忍机制"><a href="#错误容忍机制" class="headerlink" title="错误容忍机制"></a>错误容忍机制</h1><p>错误容忍机制就是在应用执行失败时能够自动恢复应用执行，并且执行结果与正常执行时得到的结果一致。</p><p>Spark通过以下两个方法实现错误容忍：</p><ul><li>  重新计算机制，主要用来解决软硬件故障导致的job执行失败问题</li><li>  Checkpoint机制，主要用来解决计算链很长情况下的数据丢失问题</li></ul><h2 id="重新计算机制"><a href="#重新计算机制" class="headerlink" title="重新计算机制"></a>重新计算机制</h2><p>这种机制通过重新执行计算任务来实现错误容忍。当job抛出异常不能继续执行时，重新启动计算任务，再次执行。</p><ul><li>  从哪里开始重新计算：Spark将会以Stage的粒度进行重新计算。原因在于：Spark采用了延时删除的策略，即将上游stage的Shuffle Write的结果写入本地磁盘，这部分数据只有在job完成后才会删除。因此即使当前stage计算失败，上一个stage由于输出数据还在磁盘上无需重复计算，只需重复计算当前stage即可。由此可见，Spark根据宽依赖切分出的stage既保证了task的独立性，也方便了错误容忍的重新计算。</li><li>  怎样计算丢失数据：Spark采用了一种称为lineage的数据溯源方法，其核心是在每个RDD中记录其上游数据是什么，以及当前RDD是如何通过上游RDD得到的。这样在错误发生时，可以根据lineage找到计算当前RDD所需的计算链以进行重复计算。</li></ul><h2 id="Checkpoint机制"><a href="#Checkpoint机制" class="headerlink" title="Checkpoint机制"></a>Checkpoint机制</h2><h3 id="Checkpoint机制的意义"><a href="#Checkpoint机制的意义" class="headerlink" title="Checkpoint机制的意义"></a><strong>Checkpoint机制的意义</strong></h3><p>重新计算机制有一个缺点，如果某个RDD的计算链过长，那么重新计算该数据的代价比较高。对于这一问题，Spark同时提供了Checkpoint机制，它可以将计算过程中某些重要数据进行持久化，这样在再次执行时可以从检查点执行，从而减少重新计算的开销。</p><p>Checkpoint的目的就是对重要数据进行持久化，在节点宕机时也能够恢复，因此需要可靠地存储。此外checkpoint的数据量可能很大，因此需要大的存储空间，一般使用HDFS来进行持久化。</p><p>在已经有了缓存机制的情况下，并且前一个Stage的输出也会存在磁盘上，为什么还需要checkpoint机制呢？</p><ul><li>  首先, 前一个stage虽然通过Shuffle Write将输出写到磁盘上，但是磁盘并不可靠，可能随着节点宕机而丢数据。并且这部分在磁盘上的数据会随着job完成而被清空，无法被下一个job使用</li><li>  其次，被缓存的数据由于内存大小的限制，容易被替换和回收而丢失，也不能提供充足的可靠性。</li></ul><p>所以，对于串联执行的job，尤其是迭代型job，需要每隔几个job就对一些中间数据进行checkpoint，这样在出错时可以从最近的checkpoint数据恢复执行。</p><h3 id="Checkpoint机制的实现"><a href="#Checkpoint机制的实现" class="headerlink" title="Checkpoint机制的实现"></a><strong>Checkpoint机制的实现</strong></h3><p>用户设置rdd.checkpoint()后只是标记了这个rdd需要持久化，这时计算过程也像正常一样计算。不同的是，一旦设置了checkpoint，等到当前job计算结束后，会再重新启动一个专门的job重新计算一遍这个rdd，并将其checkpoint。在这个专门的job中，每计算出一个record，就将其持久化写入HDFS。</p><p>由此可见，checkpoint额外启动job来进行持久化的过程会增加计算开销。为了解决这个问题，最好先将需要被checkpoint的数据进行缓存，这样额外启动的job只需要对缓存数据进行checkpoint即可，无需重新计算这个RDD，以便节约计算开销。</p><p>当一个RDD完成checkpoint之后，Spark会建立一个新的RDD，类型为ReliabeCheckpointRDD，用来表示被checkpoint到磁盘上的RDD。由于Spark认定这个RDD已经被持久化到稳定的HDFS上，之后无需被重复计算，因此会将这个新的ReliabeCheckpointRDD的lineage截断，不再保留它的计算链。</p><h3 id="Checkpoint机制与缓存机制的区别"><a href="#Checkpoint机制与缓存机制的区别" class="headerlink" title="Checkpoint机制与缓存机制的区别"></a><strong>Checkpoint机制与缓存机制的区别</strong></h3><ul><li>  目的不同：缓存机制的目的是加速计算，checkpoint机制的目的是为了错误容忍。</li><li>  存储位置不同：缓存机制为了读写速度快，主要使用内存。checkpoint为了数据的可靠性，主要使用HDFS</li><li>  写入数据速度不同：缓存数据写入较快，对job执行影响小，会在job运行时进行缓存。checkpoint时写入速度慢，为了避免影响当前job的计算时延，会额外启动专门的job来进行持久化。</li><li>  对lineage的影响不同：checkpoint机制将切断被持久化了的RDD的lineage，而缓存机制会保留被缓存的RDD的lineage。因为Spark认为缓存的数据并不可靠，一旦丢失还需要根据lineage重新计算，而通过checkpoints持久化了的数据是可靠的</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark Shuffle机制</title>
    <link href="/2023/07/05/Spark-Shuffle%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/07/05/Spark-Shuffle%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Shuffle机制"><a href="#Shuffle机制" class="headerlink" title="Shuffle机制"></a>Shuffle机制</h1><p>Apache Spark是一个强大的分布式计算框架，它能够高效地处理大规模数据集并加速数据处理过程。其中一个关键的特性就是其Shuffle机制，理解Spark的Shuffle机制对于理解Spark作业的执行至关重要。本文将分别介绍Spark的Shuffle Write阶段和Shuffle Read阶段，并在最后与MapReduce Shuffle机制进行比较。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shuffle解决的是上下游stage之间传递数据的问题。Shuffle机制分为Shuffle Write和Shuffle Read两个阶段，前者主要解决上游Stage输出数据的分区问题，后者主要解决下游Stage从上游Stage获取数据、重新组织、并为后续操作提供数据的问题。</p><p>以join操作为例的Spark Shuffle过程：</p><p><img src="/img/%E5%9B%BE6.2.png"></p><h2 id="Shuffle-Write"><a href="#Shuffle-Write" class="headerlink" title="Shuffle Write"></a>Shuffle Write</h2><p>Spark的Shuffle Write过程包含数据聚合，排序，分区三个步骤，其中分区是必备步骤，聚合和排序是可选步骤。</p><ul><li> 聚合：进行聚合combine操作的目的是减少Shuffle的数据量。只有包含聚合函数的数据操作才需要进行Shuffle Write时的combine，例如aggregateByKey(), reduceByKey(), distinct()等。</li><li> 排序：可根据partitionId+key或者只根据partitionId进行排序</li><li> 分区（Required）。在partition时，Spark根据partitionId将record依次输出到不同的buffer中，每当buffer填满就将record溢写到磁盘上的分区文件中。使用buffer的原因是map()输出record的速度很快，需要进行缓冲来减少磁盘I/O</li></ul><p>下图展示了一个包含聚合和排序操作的Shuffle Write流程：</p><p><img src="/img/%E5%9B%BE6.7.png"></p><p>注：Shuffle Write的分区个数与下游Stage的task个数一致，这个分区个数可以由用户自定义，如groupByKey(numPartitions)中的numPartitions。如果用户没有定义，则默认分区个数是父RDD的分区个数的最大值</p><h2 id="Shuffle-Read"><a href="#Shuffle-Read" class="headerlink" title="Shuffle Read"></a>Shuffle Read</h2><p>Spark的Shuffle Read过程包含数据获取，聚合，排序三个步骤。其中数据获取是必备步骤，聚合和排序是可选步骤。</p><ul><li> 数据获取（Required）：从上一个stage中的task获取record，并将record输出到buffer中，下一步操作就可以直接从buffer中获取数据。</li><li> 聚合：获取record后，Spark建立一个类似HashMap的数据结构（ExternalAppendOnlyMap）对buffer中的record进行聚合。HashMap中的key是record中的key，value是经过聚合函数计算后的结果。</li><li> 排序：如果需要对key进行排序，则建立一个Array结构，读取HashMap中的record，并对record按key进行排序。</li></ul><p>下图展示了一个包含聚合和排序操作的Shuffle Read流程：</p><p><img src="/img/%E5%9B%BE6.11.png"></p><p>注：Shuffle中使用的数据结构都试图在内存中进行聚合和排序，如果内存放不下，则进行扩容。如果扩容还放不下，就将数据spill到磁盘上，最后将磁盘和内存中的数据进行merge得到最终结果。</p><h2 id="与MapReduce-Shuffle的区别"><a href="#与MapReduce-Shuffle的区别" class="headerlink" title="与MapReduce Shuffle的区别"></a>与MapReduce Shuffle的区别</h2><p><img src="/img/%E5%9B%BE6.15.png"></p><ul><li>  MapReduce不能在线聚合，即无论是map端还是reduce端，都是先将数据存到buffer或spill到磁盘后，再执行聚合操作。而Spark是随着map的不断输出，在内存中使用hashMap来进行聚合的。</li><li>  MapReduce在shuffle write时严格按照key排序，但对于groupByKey()这样的操作不需要严格按照key进行排序。而Spark在shuffle write时的排序比较灵活，可以根据partitionId+key排序，也可以根据partitionId排序，或者不排序。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>许利杰，方亚芬. 大数据处理框架Apache Spark设计与实现[M]. 电子工业出版社, 2021.</li></ol>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Autofac：.NET平台上的依赖注入容器</title>
    <link href="/2023/06/28/Autofac%EF%BC%9A-NET%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/06/28/Autofac%EF%BC%9A-NET%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Autofac：-NET平台上的依赖注入容器"><a href="#Autofac：-NET平台上的依赖注入容器" class="headerlink" title="Autofac：.NET平台上的依赖注入容器"></a>Autofac：.NET平台上的依赖注入容器</h1><p>在现代软件设计中，依赖注入（Dependency Injection，简称DI）已经被广泛应用。使用DI可以带来如下好处：</p><ul><li>实现对象之间的松耦合：依赖注入容器能够将对象之间的依赖关系从代码中解耦，通过容器管理对象之间的依赖关系。这使得代码更加灵活、可维护且易于扩展。</li><li>提高可测试性：在单元测试时，使用依赖注入容器可以轻松注入mock的依赖项。</li><li>便于对象生命周期管理：依赖注入容器可以管理对象的生命周期，确保对象在需要时正确地创建、使用和销毁。避免不必要的对象创建。</li></ul><p>本文将聚焦于Autofac这个.NET平台上的依赖注入容器，介绍其在实际应用中的用法以及几种常见的依赖注入方式</p><h2 id="GetStarted-Example"><a href="#GetStarted-Example" class="headerlink" title="GetStarted Example"></a>GetStarted Example</h2><p>下面是一个示例，演示了Autofac如何管理一个订单处理系统中的依赖关系</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IOrderProcessor</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessOrder</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IInventoryService</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateInventory</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">INotificationService</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendNotification</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrderProcessor</span> : <span class="hljs-title">IOrderProcessor</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IInventoryService inventoryService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> INotificationService notificationService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderProcessor</span>(<span class="hljs-params">IInventoryService inventoryService, INotificationService notificationService</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.inventoryService = inventoryService;<br>        <span class="hljs-keyword">this</span>.notificationService = notificationService;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProcessOrder</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 处理订单逻辑</span><br>        inventoryService.UpdateInventory();<br>        notificationService.SendNotification();<br>        Console.WriteLine(<span class="hljs-string">&quot;Order processed successfully.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InventoryService</span> : <span class="hljs-title">IInventoryService</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateInventory</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Updating inventory...&quot;</span>);<br>        <span class="hljs-comment">// 更新库存逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NotificationService</span> : <span class="hljs-title">INotificationService</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendNotification</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Sending notification...&quot;</span>);<br>        <span class="hljs-comment">// 发送通知逻辑</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，我们有三个接口：IOrderProcessor，IInventoryService和INotificationService，分别代表订单处理器、库存服务和通知服务。OrderProcessor实现了IOrderProcessor接口，并在构造函数中注入了IInventoryService和INotificationService。在ProcessOrder方法中，它使用这两个依赖组件来处理订单。InventoryService和NotificationService分别实现了IInventoryService和INotificationService接口，它们负责具体的库存更新和通知发送逻辑。现在，让我们看看如何使用Autofac来配置和解析这些复杂的依赖关系：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> Autofac;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 创建容器构建器</span><br>        <span class="hljs-keyword">var</span> builder = <span class="hljs-keyword">new</span> ContainerBuilder();<br><br>        <span class="hljs-comment">// 注册依赖关系</span><br>        builder.RegisterType&lt;OrderProcessor&gt;().As&lt;IOrderProcessor&gt;();<br>        builder.RegisterType&lt;InventoryService&gt;().As&lt;IInventoryService&gt;();<br>        builder.RegisterType&lt;NotificationService&gt;().As&lt;INotificationService&gt;();<br><br>        <span class="hljs-comment">// 构建容器</span><br>        <span class="hljs-keyword">var</span> container = builder.Build();<br>        <span class="hljs-keyword">var</span> orderProcessor = container.Resolve&lt;IOrderProcessor&gt;();<br>        orderProcessor.ProcessOrder();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Autofac使用反射来创建对象实例，并自动解析其依赖项。在这个例子中，当我们使用 builder.RegisterType<OrderProcessor>() 将 OrderProcessor 类型注册到 Autofac 容器时，Autofac会分析 OrderProcessor 类的构造函数，找出它所依赖的其他组件，并尝试自动解析这些依赖项。其中，OrderProcessor 类的构造函数接受两个参数：IInventoryService 和 INotificationService。因此，Autofac会尝试解析这两个依赖项。Autofac会递归地查找这些依赖项的解析方式，也就是说，它会查找 IInventoryService 和 INotificationService 的注册信息并解析它们的依赖项（如果有的话）。这个过程会一直持续，直到所有依赖项都被解析为止。一旦所有依赖项都被解析，Autofac就会使用反射创建 OrderProcessor 类的实例，并将解析到的依赖项传递给它的构造函数。这样，当我们通过调用 container.Resolve<IOrderProcessor>() 来请求解析 IOrderProcessor 接口的实例时，Autofac会自动创建一个 OrderProcessor 对象，并将其构造函数所需的依赖项自动注入。通过这种方式，Autofac可以自动管理对象的创建和依赖关系，简化了依赖注入的过程，使代码更加简洁和可扩展。</p><h3 id="Autofac几种常见注册方式"><a href="#Autofac几种常见注册方式" class="headerlink" title="Autofac几种常见注册方式"></a>Autofac几种常见注册方式</h3><ul><li><code>RegisterType</code>: 最常见的注册方式之一。例如下面示例将MyService 类型注册为 IMyService 接口的实现类  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">builder.RegisterType&lt;MyService&gt;().As&lt;IMyService&gt;();<br></code></pre></td></tr></table></figure></li><li><code>RegisterInstance</code>: 使用 RegisterInstance 方法可以将一个已经存在的对象实例注册到容器中。适用于单例对象或在特定场景下需要手动创建的对象。例如下面示例将instance 对象注册为 IMyService 接口的实现。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> MyService();<br>builder.RegisterInstance(instance).As&lt;IMyService&gt;();<br></code></pre></td></tr></table></figure></li><li><code>RegisterGeneric</code>:使用 RegisterGeneric 方法可以注册泛型类型的依赖关系。例如下面示例将 MyGenericService<T> 类型注册为 IGenericService<T> 接口的实现类。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">builder.RegisterGeneric(<span class="hljs-keyword">typeof</span>(MyGenericService&lt;&gt;)).As(<span class="hljs-keyword">typeof</span>(IGenericService&lt;&gt;));<br></code></pre></td></tr></table></figure></li><li><code>Register</code>: Register也是一种常用的注册方式，它允许以更灵活的方式进行依赖关系的注册。builder.Register() 方法接受一个 lambda 表达式作为参数，在 lambda 表达式中你可以执行更复杂的注册逻辑  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#">builder.Register(ctx =&gt;<br>&#123;<br>    <span class="hljs-comment">// 在 lambda 表达式中执行注册逻辑</span><br>    <span class="hljs-keyword">var</span> dependency = ctx.Resolve&lt;IDependency&gt;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService(dependency);<br>&#125;).As&lt;IMyService&gt;();<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive安装指南</title>
    <link href="/2023/02/27/Hive%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <url>/2023/02/27/Hive%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-下载Hive"><a href="#1-下载Hive" class="headerlink" title="1.下载Hive"></a>1.下载Hive</h2><p>下载Hive并解压：<a href="https://dlcdn.apache.org/hive/">https://dlcdn.apache.org/hive/</a></p><h2 id="2-修改环境变量"><a href="#2-修改环境变量" class="headerlink" title="2. 修改环境变量"></a>2. 修改环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /etc/profile<br></code></pre></td></tr></table></figure><p>添加如下（需将HIVE_HOME修改为本地Hive路径）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">export HIVE_HOME=/home/Yihua/App/apache-hive-2.3.9-bin<br>export PATH=$HIVE_HOME/bin:$PATH<br><br>export CLASSPATH=$CLASSPATH:$HADOOP_HOME/lib/*:.<br>export CLASSPATH=$CLASSPATH:$HIVE_HOME/lib/*:<br></code></pre></td></tr></table></figure><p>使用<code>source /etc/profile</code>命令使对环境变量的修改立即生效</p><h2 id="3-修改Hive配置文件"><a href="#3-修改Hive配置文件" class="headerlink" title="3. 修改Hive配置文件"></a>3. 修改Hive配置文件</h2><p>默认的配置文件为hive-default.xml.template，我们copy一份新的hive-site并在其上面做修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp hive-default.xml.template hive-site.xml<br></code></pre></td></tr></table></figure><p>检查配置内容：</p><ul><li>ConnectionURL：表明我们想使用什么数据库作为metastore, 这里我们配置为使用Hive内置的数据库Derby<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&lt;property&gt;<br>    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;<br>    &lt;value&gt;jdbc:derby:;databaseName=metastore_db;create=true&lt;/value&gt;<br>    &lt;description&gt;<br>        JDBC connect string for a JDBC metastore.<br>        To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.<br>        For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.<br>    &lt;/description&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure></li><li>Warehouse.dir：配置数据在HDFS上存储的路径<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&lt;property&gt;<br>    &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;<br>    &lt;value&gt;/user/hive/warehouse&lt;/value&gt;<br>    &lt;description&gt;location of default database for the warehouse&lt;/description&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure></li><li>替换${system:java.io.tmpdir}为/tmp/hive_io，这是Hive存储其临时文件的位置<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">:%s#$&#123;<span class="hljs-built_in">system</span>:java.io.tmpdir&#125;#/tmp/hive_io#g<br></code></pre></td></tr></table></figure></li><li>替换${system:user.name}为UserName<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">%s/$&#123;<span class="hljs-built_in">system</span>:user.name&#125;/Yihua/g<br></code></pre></td></tr></table></figure><h2 id="4-创建HDFS路径并赋权限"><a href="#4-创建HDFS路径并赋权限" class="headerlink" title="4. 创建HDFS路径并赋权限"></a>4. 创建HDFS路径并赋权限</h2>在创建前，需使用jps命令检查Hadoop进程是否都在运行，其中NameNode DataNode和SecondaryNameNode是HDFS进程，NodeManager和ResourceManager是Yarn进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop fs -mkdir /tmp<br>hadoop fs -mkdir /user<br>hadoop fs -mkdir /user/hive<br>hadoop fs -mkdir /user/hive/warehouse<br>hadoop fs -chmod g+w /tmp<br>hadoop fs -chmod g+w /user/hive/warehouse<br></code></pre></td></tr></table></figure><h2 id="5-Metastore-db"><a href="#5-Metastore-db" class="headerlink" title="5. Metastore_db"></a>5. Metastore_db</h2>在运行Hive的目录下会有一个Metastore_db文件，是一个derby数据库，包含Hive table的所有metadata。我们将现有的metastore做一个备份，并用schematool去实例化metastore, 为metastore初始化schema，表明数据库是derby。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv metastore_db metastore_db.tmp<br>schematool -initSchema -dbType derby<br></code></pre></td></tr></table></figure><h2 id="6-运行Hive或者在bin目录下运行beeline-u-jdbc-hive2"><a href="#6-运行Hive或者在bin目录下运行beeline-u-jdbc-hive2" class="headerlink" title="6. 运行Hive或者在bin目录下运行beeline -u jdbc:hive2://"></a>6. 运行Hive或者在bin目录下运行beeline -u jdbc:hive2://</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算</title>
    <link href="/2023/02/12/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/02/12/%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>如今，云计算作为一个无所不包的信息技术服务平台，它抽象了多个大型数据中心内的海量计算存储资源，对外提供了从基础设施到托管平台不同层次、不同粒度的在线服务和组件。其分为Iaas，PaaS和SaaS三个层次：</p><h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p>IaaS 的本质，是对云上各类 IT 基础设施的抽象</p><p>区域（Region）：表示云计算厂商在某个地理位置提供的所有云服务的组合</p><p>可用区（Availability Zone),：表示一个完整而独立的数据中心单元。一个区域通常由多个可用区高速互联组成，通过多个可用区来解决区域的高可用性问题。</p><ul><li>计算：云虚拟机体现了计算存储分离思想。传统虚拟机往往是对单一物理机器资源的纵向切割，计算、存储、网络等各方面的能力都是一台物理机的子集，可伸缩性受限。云虚拟机除了CPU 与内存部分仍属于一台宿主机外，它的网络、硬盘等其他部分可以超脱于宿主机之外，享受云端其他基础设施的能力，从而有更好的可扩展性和故障隔离能力。</li><li>存储：云硬盘是云虚拟机可以挂载和使用的云端磁盘服务，也叫块存储（Block Storage）。作为云虚拟机的主要持久化存储，其与宿主机往往是分离的</li><li>网络：虚拟私有网络：构建在云上、相互隔离的、用户可以自主控制的私有网络环境。虚拟机的网卡一面和虚拟机本体绑定，另一面嵌入某个私有网络的子网，从而把虚拟机“放置”在这个虚拟网络中。</li></ul><h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p>云计算提供的平台类服务，在IaaS的基础上又做了进一步的抽象与封装，让用户更方便地在更上层进行应用的构建，而无需关心底层的基础设施。</p><ul><li><p>对象存储：能存储任意二进制文件（对象）的存储服务。对象存储内本身不存在一个真正的文件系统，而是更接近一个键值（Key-Value）形式的存储服务。例如亚马逊的S3，Azure的Blob Storage。</p></li><li><p>应用托管服务：用于构建云上Web应用，例如Azure的App Service</p></li><li><p>云数据库：得益于云的优势，云数据库具有更强的可扩展性和更高的可用性和可靠性</p><ul><li>RDS（Relational Database Service），云上数据库让实现读写分离，自动调优更加容易</li><li>NoSQL：AWS Aurora，阿里PolarDB，Azure CosmosDB</li></ul><p><img src="/img/%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="云数据库"></p></li><li><p>大数据服务：云上大数据服务最大的特点就是简便易用，方便管理，提供弹性。例如AWS Elastic MapReduce（EMC），Azure HDInsight。通过这些产品和服务的组合，可以轻松构建数据仓库和数据湖解决方案。</p></li></ul><p><img src="/img/%E4%BA%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1.png" alt="云数据库"></p><ul><li>容器服务：云是容器的最佳载体，容器也非常适合在云上运行。</li></ul><p><img src="/img/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1.png" alt="容器服务"></p><ul><li>无服务器计算：让用户完全感觉不到服务器的存在，从而专注于业务逻辑编写，无需关心任何基础设施。通常可以支持用户每一个具有独立功能的函数作为服务来单独部署和运行，不需要硬件配置、完全按需服务，因此也称函数即服务（Function as a Service，FaaS）。例如AWS的Lanbda，阿里云的函数计算，Azure的Azure Functions。无服务器计算本身是无状态的，所有的持久化需求都要借助外部存储来实现，所以经常需要和数据库、对象存储等服务配合。</li><li>云上AI服务：云上提供的计算机视觉、自然语言处理、语音类服务等，例如Azure的认知服务Congnitive Service。</li></ul><h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p>例如：Outlook，Calendar，M365，Azure DevOps</p><p>SaaS与传统Web应用的区别：</p><ul><li>多租户（不同租户间完全隔离）</li><li>订阅制（按年、按月付费，而不是一次性付费）</li><li>中心化部署</li></ul><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>云原生的本质是用于构建现代云端应用的一系列架构理念，以及帮助这些理念落地的技术支撑和最佳实践。云原生的核心理念包括无状态、分布式、服务化、弹性扩展等等</p><p>狭义的云原生定义，特指的是容器化、容器编排和微服务架构。各类厂商在宣传 Kubernetes 服务和产品时所说的“云原生”</p><p>从更广义的视角来看，只要是适合在云上运行，具备和符合云上架构特点的应用，都可以说是属于“云原生”范畴。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】32.最长有效括号</title>
    <link href="/2021/05/05/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/05/05/32.%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h1><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>     示例 1：</p><pre><code>输入：s = &quot;(()&quot;输出：2解释：最长有效括号子串是 &quot;()&quot;示例 2：输入：s = &quot;)()())&quot;输出：4解释：最长有效括号子串是 &quot;()()&quot;示例 3：输入：s = &quot;&quot;输出：0</code></pre><h2 id="方法一（栈）"><a href="#方法一（栈）" class="headerlink" title="方法一（栈）"></a>方法一（栈）</h2><ul><li><p>用栈来找出所有匹配的左右括号，并用一个列表来记录匹配括号的索引。</p></li><li><p>于是这个列表中最长连续子序列的长度就是最长有效括号的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    List&lt;Integer&gt; indexList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            stack.push(i);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                indexList.add(stack.pop());<br>                indexList.add(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(indexList.size() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//寻找列表中最长连续子序列的长度</span><br>    Collections.sort(indexList);<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(index &lt; indexList.size() - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(index &lt; indexList.size() - <span class="hljs-number">1</span> &amp;&amp; indexList.get(index) == indexList.get(index + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>)&#123;<br>            count++;<br>            index++;<br>        &#125;<br>        max = Math.max(count, max);<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>时间复杂度：O(nlogn)</p></li><li><p>空间复杂度：O(n)  栈和列表所需的额外空间</p><h2 id="方法二（动态规划）"><a href="#方法二（动态规划）" class="headerlink" title="方法二（动态规划）"></a>方法二（动态规划）</h2><h3 id="1-定义状态"><a href="#1-定义状态" class="headerlink" title="1.定义状态"></a>1.定义状态</h3><p>定义<code>dp[i]</code>为以位置i结尾的最长有效括号的长度</p></li></ul><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><ul><li><p>一个单括号不可能形成有效括号，因此dp[0] = 0</p></li><li><p>如果1位置为右括号，0位置为左括号，那么dp[1] = 2</p><h3 id="3-状态转移"><a href="#3-状态转移" class="headerlink" title="3.状态转移"></a>3.状态转移</h3></li><li><p>如果i位置为左括号，那么没有以这个位置结尾的有效括号，dp[i] = 0</p></li><li><p>如果i位置为右括号，分两种情况：</p><ul><li><p>如果i-1位置为左括号，那么i-1位置和i位置能组成一个长度为2的有效括号，再加上以i-2位置结尾的最长有效括号的长度，即为以i位置结尾的最长有小括号的长度。<code>dp[i] = dp[i-2] + 2</code></p></li><li><p>如果i-1位置为右括号，那么以它结尾可能会有一定长度的有效括号，我们先越过这些位置，来到这些匹配好的有效括号前面一个位置，如果这个位置是左括号，那么<code>dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]</code></p><p>例如：<code>&quot;())(())&quot;</code>，对于位置5，其前面的位置4已经有长度为2的匹配好的有效括号<code>&quot;()&quot;</code>，并且它们前面的位置2为左括号，可以与位置5的右括号匹配，因此dp[i]肯定能在dp[i-1]的位置上加2。但如例子所示，以位置1结尾还有长度为2的有小括号，与之后的有小括号连上了，这时我们就需要把这部分有效括号的长度dp[i - dp[i - 1] - 2]也加上。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];<br>    <span class="hljs-comment">//Base Case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> max = Math.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            dp[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                dp[i] = dp[i - <span class="hljs-number">2</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                    dp[i] += i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        max = Math.max(max, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n) </li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习笔记</title>
    <link href="/2021/05/05/CSharp/"/>
    <url>/2021/05/05/CSharp/</url>
    
    <content type="html"><![CDATA[<h1 id="1-NET框架"><a href="#1-NET框架" class="headerlink" title="1 .NET框架"></a>1 .NET框架</h1><p>.NET框架由三部分组成：</p><ul><li>编程工具：包括Visual Studio集成开发环境，调试器，.NET兼容的编译器等</li><li>CLR（Common Language Runtime，公共语言运行库）：在运行时管理程序的执行，包括内存管理和垃圾收集、代码安全验证、代码执行线程管理及异常处理等</li><li>BCL（Base Class Library，基类库）：包括通用基础类（文件操作、字符串操作等相关的类）、集合类（列表、字典、散列表）、线程和同步类、XML类。</li></ul><p>以下图片说明了3个用不同语言编写的程序的完整编译时和运行的过程</p><p><img src="/img/1.5.jpg" alt="NET框架"></p><h1 id="2-C-编程概述"><a href="#2-C-编程概述" class="headerlink" title="2. C#编程概述"></a>2. C#编程概述</h1><p>一个简单的C#程序，这段程序会输出“Hi there！”</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//告诉编译器这个程序使用了System命名空间的类型</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-comment">//声明一个新命名空间，名称为Simple</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Simple</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hi there!&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C#中，WirteLine相当于java中的println，Write相当于java中的print</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;Three integers are &#123;1&#125;, &#123;0&#125; and &#123;1&#125;.&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>以上语句将在屏幕上显示：<br>Three integers are 6, 3 and 6.</p><h2 id="类型存储和变量"><a href="#类型存储和变量" class="headerlink" title="类型存储和变量"></a>类型存储和变量</h2><p>命名空间是一种把相关的类型声明分组并命名的方法。既然程序是一组相关的类型声明，那么通常会把程序声明在你创建的命名空间内部。</p><h2 id="预定义类型"><a href="#预定义类型" class="headerlink" title="预定义类型"></a>预定义类型</h2><p>C#提供了16种预定义类型，包括13种简单类型和3种非简单类型</p><p>简单类型：<br>| 名称      | 含义 |<br>| ———– | ———– |<br>| int      | 32位有符号整数       |<br>| uint   | 32位无符号整数        |<br>| long      | 64位有符号整数 |<br>| ulong      | 62位无符号整数       |<br>| short   | 16位有符号整数        |<br>| ushort      | 16位无符号整数 |<br>| byte | 8位有符号整数 |<br>| sbyte      | 8位无符号整数       |<br>| float   | 单精度浮点数        |<br>| double | 双精度浮点数 |<br>|decimal|高精度小数类型|<br>| bool      | 布尔型       |<br>| char   | Unicode字符串        |</p><p>非简单类型：</p><ul><li>object：所有其他类的基类</li><li>string：多个Unicode字符组成的序列</li><li>dynamic：在使用动态语言编写的程序集时使用</li></ul><p>C#语言是静态的，但基于.NET的一些其他语言却是动态的，也就是说变量的类型直到运行时才会被解析。由于它们是.NET语言，所以C#程序需要使用这些语言编写的程序集。问题是程序集中的类型直到运行时才会被解析，而C#又要引用这样的类型并且需要在编译的时候解析类型。为了解决这个问题，有了dynamic关键字。</p><p>在编译时，编译器不会对dynamic类型的变量进行类型检查。相反，它将与该变量及该变量的操作有关的所有信息打包。在运行时会对这些信息进行检查，以确保它与变量所代表的实际类型保持一致性，否则将在运行时抛出异常。</p><h2 id="用户定义类型"><a href="#用户定义类型" class="headerlink" title="用户定义类型"></a>用户定义类型</h2><p>C#中有6种用户自定义类型</p><ul><li>类类型class</li><li>结构类型struct</li><li>数组类型array</li><li>枚举类型enum</li><li>委托类型delegate</li><li>接口类型interface</li></ul><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="类型推断和var关键字"><a href="#类型推断和var关键字" class="headerlink" title="类型推断和var关键字"></a>类型推断和var关键字</h2><p>var关键字不是特定类型变量的符号，它是从等号右边推断出的实际类型的速记。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//在下面的第一个声明中，var是int的速记</span><br><span class="hljs-comment">//第二个声明中，var是MyExcellentClass的速记</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> total = <span class="hljs-number">15</span>;  <br>    <span class="hljs-keyword">var</span> mec = <span class="hljs-keyword">new</span> MyExcellentClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用var关键字有一些重要的条件：</p><ul><li>只能用于本地变量，不能用于字段</li><li>只能在变量声明中包含初始化的时候使用</li><li>一旦编译器推断出变量的类型，它就是固定且不能更改的</li></ul><h2 id="本地常量"><a href="#本地常量" class="headerlink" title="本地常量"></a>本地常量</h2><p>用const修饰符来修饰（类似于java中的final）</p><p>常量和变量的语法除了以下两点外都相同：</p><ul><li>常量在类型之前增加关键字const</li><li>常量必须有初始化语句，也就是说初始值不能在编译期确定。因此，它不能是某个对象的引用（但可以是null的引用），因为对象的引用是在运行时决定的。</li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>首先区分下<strong>形参</strong>和<strong>实参</strong>的概念：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//以下函数的参数声明中，x和y均为形参</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">float</span> y</span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//以下函数的调用中，5和someInt均为实参,实参的值用于初始化形参</span><br>PrintSum(<span class="hljs-number">5</span>, someInt)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-值参数"><a href="#1-值参数" class="headerlink" title="1.值参数"></a>1.值参数</h3><p>Java中的参数传递类型（值传递），即：值参数是把实参的值复制给形参，二者在栈中的不同位置。</p><ul><li>在方法被调用前，用作实参的变量a2已经在栈中了</li><li>在方法开始时，系统在栈中为形参分配空间，并从实参复制值<ul><li>因为a1是引用类型，所以a1的值（即指向对象的地址）被复制，形参和实参都指向堆中的同一个对象</li><li>因为a2是值类型的，所以值被复制，产生了一个独立的数据项</li></ul></li><li>在方法中，f2和对象f1的字段都被加上了5</li><li>方法结束后，形参从栈中弹出</li></ul><p><img src="/img/%E5%80%BC%E5%8F%82%E6%95%B0.jpg" alt="值参数"></p><h3 id="2-引用参数"><a href="#2-引用参数" class="headerlink" title="2.引用参数"></a>2.引用参数</h3><p>对于引用参数，系统不会在栈中为形参分配新的空间，形参的参数名将作为实参的别名，指向相同的内存位置</p><ul><li>使用引用参数时，必须在方法的声明和调用中都使用ref修饰符</li><li>实参必须是变量，在用作实参前必须被赋值</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//方法声明中要使用ref修饰符</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> val</span>)</span>&#123;<br><br>&#125;<br><br><span class="hljs-built_in">int</span> y = <span class="hljs-number">1</span>;<br>MyMethod(<span class="hljs-keyword">ref</span> y)   <span class="hljs-comment">//使用y前必须赋值</span><br>MyMethod(<span class="hljs-keyword">ref</span> <span class="hljs-number">3</span> + <span class="hljs-number">5</span>)   <span class="hljs-comment">//会报错，因为引用参数作为实参必须是变量，不能是表达式</span><br></code></pre></td></tr></table></figure><ul><li>在方法调用前，将要被用作实参的变量a1和a2已经在栈里了</li><li>在方法的开始，形参名被设置为实参的别名。引用相同的内存位置</li><li>在方法结束后，f2和f1的对象的字段都被加上了5</li></ul><p><img src="/img/%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0.jpg" alt="引用参数"></p><p>对比将引用类型对象作为值参数和引用参数传递的两种情况：</p><ul><li>将引用类型对象作为值参数传递：如果在方法内创建一个对象并赋值给形参，将切断形参和实参之间的关联，并且在方法调用结束后，新对象将不复存在</li><li>将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，会让实参也引用该新对象，并且在方法结束后该对象仍然存在。</li></ul><h2 id="3-输出参数"><a href="#3-输出参数" class="headerlink" title="3.输出参数"></a>3.输出参数</h2><p>输出参数用于从方法体内把数据传出到调用代码，修饰符为out。和引用参数非常类似</p><p>和引用参数一样，输出参数的形参担当实参的别名，方法内对形参的任何改变在方法完成后通过实参变量都是可见的。</p><p>唯一和引用参数不同的是：<strong>方法内的代码在读取输出参数之前必须先对其写入</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> outValue</span>)</span>&#123;<br>    <span class="hljs-comment">//以下这句会报错，因为输出参数outValue在方法中被读取前没有被赋值</span><br>    <span class="hljs-built_in">int</span> var1 = outValue + <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参数数组"><a href="#4-参数数组" class="headerlink" title="4.参数数组"></a>4.参数数组</h2><p>参数数组允许0个或多个实参对应一个特殊的形参,修饰符为params</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//形参inVals可以代表0个或多个实参</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListInts</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] inVals</span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在参数列表中只能有一个参数数组，并且是列表中的最后一个</li><li>由参数数组表示的所有参数必须具有相同的类型</li></ul><p>参数数组在方法声明中需要params修饰符，而在调用时不需要（不同于引用参数和输出参数，它们在以上两个地方都需要修饰符）</p><p>可以有如下两种方式为参数数组提供实参：</p><ol><li>用一个逗号分隔的该数据类型元素的列表,使用这种方法时，编译器做如下的事：<ul><li>接收实参列表，用它们在堆中创建并初始化一个数组</li><li>把数组的引用作为形参保存在栈中<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">ListInts(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>用数组作为实参<br> 在这种情况下，编译器会直接使用传入的数组，也就是说栈中的形参指向内存中intArray的位置 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>ListInts(intArray);<br></code></pre></td></tr></table></figure><h2 id="5-命名参数"><a href="#5-命名参数" class="headerlink" title="5.命名参数"></a>5.命名参数</h2>在使用命名参数时，需要在方法调用中包含参数名。而方法的声明无需任何改变<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;<br>    <span class="hljs-comment">//方法中的参数声明一如平常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Calc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> c</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> a + b + c;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>        MyClass mc = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-built_in">int</span> result = mc.Calc(c: <span class="hljs-number">2</span>, a: <span class="hljs-number">4</span>, b: <span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-可选参数"><a href="#6-可选参数" class="headerlink" title="6.可选参数"></a>6.可选参数</h3>所谓可选参数就是在调用方法的时候可以包含这个参数，也可以忽略它。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;<br>    <span class="hljs-comment">//b为可选参数，默认值为3</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Calc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b = <span class="hljs-number">3</span></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>        MyClass mc = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-built_in">int</span> ro = mc.Calc(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-built_in">int</span> r1 = mc.Calc(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;, &#123;1&#125;&quot;</span>, ro, r1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>上述代码会输出11，8</li></ol><p>只要值类型的默认值在编译的时候可以确定，就可以使用值参数作为可选参数。而只有在默认值为null的时候，引用参数才可以作为可选参数。</p><p>总结下来，一个方法的声明中，参数要按照必填参数、可选参数、params参数的先后顺序声明。</p><p>可以忽略最后一个可选参数，或者最后n个可选参数，但是不可以随机选择省略任意的可选参数，省略必须从最后开始。</p><p><strong>参数类型总结：</strong>  </p><table><thead><tr><th>参数类型</th><th>修饰符</th><th>是否在声明时使用</th><th>是否在调用是使用</th><th>执行</th></tr></thead><tbody><tr><td>值参数</td><td>无</td><td></td><td></td><td>系统把实参的值复制给形参，二者在栈中位置不同</td></tr><tr><td>引用参数</td><td>ref</td><td>是</td><td>是</td><td>形参是实参的别名，二者在栈中位置相同</td></tr><tr><td>输出参数</td><td>out</td><td>是</td><td>是</td><td>在读取输出参数前必须对其写入，除此之外和引用参数类似</td></tr><tr><td>参数数组</td><td>params</td><td>是</td><td>否</td><td>允许传递可变数目的实参到方法</td></tr></tbody></table><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>在调用方法的时候，内存从栈的顶部开始分配，保存和方法关联的一些数据项。这块内存叫做方法的栈帧</p><p>栈帧保存如下的内容：</p><ul><li><p>返回地址</p></li><li><p>为参数分配的内存</p></li><li><p>各种和方法调用相关的其他管理数据项</p><p>在方法调用的时候，整个栈帧都会压入栈。在方法退出的时候，整个栈帧都会从栈上弹出。</p></li></ul><p><img src="/img/%E6%A0%88%E5%B8%A7.jpg" alt="栈帧"></p><h1 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h1><p>类成员包括数据成员（保存数据）和函数成员（执行代码）<br>其中数据成员包括：</p><ul><li>字段</li><li>常量（用const修饰，包括本地常量和成员常量，本地常量声明在方法内，成员常量声明在类中）</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>成员常量表现的和静态量相似，但唯一不同的是，成员常量没有自己的存储位置，而是在编译时被编译器替换。此外，不能将成员常量声明为static。与const有着相同作用的是readonly，不同的是，const字段只能在字段的声明语句中初始化，而readonly也可以在构造函数中初始化。因此const字段的值必须在编译时确定，而randonly字段的值可以在运行时决定。</p><p>函数成员包括：</p><ul><li>方法</li><li>属性</li><li>构造函数、析构函数</li><li>运算符</li><li>索引</li><li>事件</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性是一组称为访问器的方法（set访问器为属性赋值，get访问器从属性中获取值）。它是类中的函数成员，因此不需为属性分配内存。</p><p>写入和读取属性的代码和访问字段一样。属性会根据是写入还是读取，来隐式地调用适当的访问器</p><p>属性通常和字段关联，一种常见的方式是在类中将字段声明为private以封装字段，并声明一个public属性用get和set访问器来控制对该字段的访问。和属性关联的字段成为后备字段</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> TheRealValue = <span class="hljs-number">10</span>;   <span class="hljs-comment">//后备字段：分配内存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyValue&#123;              <span class="hljs-comment">//属性：不分配内存</span><br>        <span class="hljs-keyword">set</span>&#123;<br>            TheRealValue = <span class="hljs-keyword">value</span>;    <span class="hljs-comment">//设置字段的值</span><br>        &#125; <br>        <span class="hljs-keyword">get</span>&#123;<br>            <span class="hljs-keyword">return</span> TheRealValue;     <span class="hljs-comment">//获取字段的值</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//对属性的读和写如同对字段的读和写</span><br>        C1 c = <span class="hljs-keyword">new</span> C1();<br>        Console.WriteLine(<span class="hljs-string">&quot;MyValue: &#123;0&#125;&quot;</span>, c.MyValue);<br><br>        c.MyValue = <span class="hljs-number">20</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;MyValue: &#123;0&#125;&quot;</span>, c.MyValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，属性也可以只有get访问器（只读属性），或者只有set访问器（只写属性）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">RightTriangle</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> A = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> B = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//只读属性，计算直角三角形的第三边</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Hypotenuse&#123;<br>        <span class="hljs-keyword">get</span>&#123;<br>            <span class="hljs-keyword">return</span> Math.Sqrt((A * A) + (B * B));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>        RightTriangle c = <span class="hljs-keyword">new</span> RightTriangle();<br>        Console.WriteLine(<span class="hljs-string">&quot;Hypotenuse: &#123;0&#125;&quot;</span>, c.Hypotenuse);<br>    &#125;<br>&#125;<br><br>上述代码将输出<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>可以认为索引器是为类的多个数据成员提供get和set访问器的属性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Temp0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Temp1;<br>    <span class="hljs-comment">//和属性不同的是，索引器有参数（索引参数），并且使用this而不是名称</span><br>    <span class="hljs-comment">//索引器声明</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span> [<span class="hljs-built_in">int</span> index]&#123;    <br>        <span class="hljs-keyword">get</span>&#123;<br>            <span class="hljs-keyword">return</span> (index == <span class="hljs-number">0</span>) ? Temp0 : Temp1;<br>        &#125;<br>        <span class="hljs-keyword">set</span>&#123;<br>            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)<br>                Temp0 = <span class="hljs-keyword">value</span>;   <span class="hljs-comment">//value为set访问器的隐式变量</span><br>            <span class="hljs-keyword">else</span><br>                Temp1 = <span class="hljs-keyword">value</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>&#123;<br>        Class1 a = <span class="hljs-keyword">new</span> Class1();<br>        <span class="hljs-comment">//使用索引参数0或1读取数据成员</span><br>        Console.WriteLine(<span class="hljs-string">&quot;T0: &#123;0&#125;, T1 : &#123;1&#125;&quot;</span>, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//使用索引参数0或1对数据成员进行写入</span><br>        a[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span>;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;T0: &#123;0&#125;, T1 : &#123;1&#125;&quot;</span>, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br>以上代码会输出：<br>T0: <span class="hljs-number">0</span>, T1: <span class="hljs-number">0</span><br>T0: <span class="hljs-number">15</span>, T1: <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h1 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h1><p>如果类OtherClass继承自SomeClass，则应按如下表示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类只能继承自一个基类，所有的类都是Object类的派生类</p><h2 id="屏蔽基类的成员"><a href="#屏蔽基类的成员" class="headerlink" title="屏蔽基类的成员"></a>屏蔽基类的成员</h2><p>虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员（如果是函数成员，则要求签名相同，签名指名称和参数列表，不包括返回类型）。此外还要使用new修饰符来告诉编译器我正在故意屏蔽继承的成员。</p><p>另外，即使派生类屏蔽了基类的成员，也可以使用基类访问表达式访问隐藏的继承成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span>&#123;    <span class="hljs-comment">//基类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;Field1--In the base class&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">OtherClass</span> : <span class="hljs-title">SomeClass</span>&#123;    <span class="hljs-comment">//派生类</span><br>    <span class="hljs-comment">//使用new修饰符隐藏基类中的Field1字段</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Field1 = <span class="hljs-string">&quot;Field1--In the derived class&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintField1</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//访问派生类中的Field1，会输出&quot;Field1--In the derived class&quot;</span><br>        Console.WriteLine(Field1);   <br>        <span class="hljs-comment">//使用基类访问来访问基类中的Field1，会输出&quot;Field1--In the base class&quot; </span><br>        Console.WriteLine(<span class="hljs-keyword">base</span>.Field1); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用基类的引用"><a href="#使用基类的引用" class="headerlink" title="使用基类的引用"></a>使用基类的引用</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">MyDerivedClass derived = <span class="hljs-keyword">new</span> MyDerivedClass();   <span class="hljs-comment">//创建一个派生类对象</span><br>MyBaseClass mybc = (MyBaseClass)derived;        <span class="hljs-comment">//让基类引用指向派生类对象</span><br></code></pre></td></tr></table></figure><p>对于如上代码，派生类的引用derived可以看到完整的MyDerivedClass对象，而基类引用mybc只能看到对象的MyBaseClass部分（只能看到基类成员）<br><img src="/img/%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8.jpg" alt="使用基类的引用"></p><p>另外，也可以使用基类引用调用派生类的方法，但要满足如下条件：</p><ul><li>派生类的方法和基类方法有着相同的签名和返回类型</li><li>基类的方法用virtual标注</li><li>派生类的方法用override标注<br>在这种情况下，当使用基类引用（mybc）调用方法时，方法会被传递到派生类执行</li></ul><p>注意：</p><ul><li>覆写（override）和被覆写的方法应该有相同的访问性</li><li>不能覆写static方法和非虚（virtual）方法</li></ul><p>当使用对象的基类引用调用一个覆写的方法时，方法的调用被沿着派生层次上溯执行，一直到标记为override的方法的最高派生版本。<br>如果在更高派生级别有该方法的其他声明，但没有被标记为override，那么它们不会被调用。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数初始化语句"><a href="#构造函数初始化语句" class="headerlink" title="构造函数初始化语句"></a>构造函数初始化语句</h3><p>两种形式：</p><ul><li>关键字base：指明使用哪一个基类的构造函数</li><li>关键字this：指明使用哪一个当前类的构造函数<br>以下构造函数使用了构造函数初始化语句，构造函数初始化语句指明了要使用第一个参数是string，第二个参数是int型的那个基类构造函数</li></ul><p>当声明一个不带构造函数初始化语句的构造函数时，它实际上是使用了无参数的基类构造函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">string</span> s</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">s, x</span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如下代码中的MyClass类包含一个有一个int型参数的构造函数，这个构造函数使用了同一个类中具有两个参数的构造函数，并为第二个参数提供了一个默认值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>) : <span class="hljs-title">this</span>(<span class="hljs-params">x, <span class="hljs-string">&quot;Using Default String&quot;</span></span>)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类有好几个构造函数，并且它们都需要在构造对象的过程中执行一些公共代码。这时可以把公共代码提取出来作为一个构造函数，被其他所有的构造函数作为构造函数初始化语句使用。</p><h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>类有两种访问级别：</p><ul><li>public：可以被任何程序集中的代码访问</li><li>internal：默认的访问级别，仅可以被自己所在的程序集中的类看到</li></ul><p>类中的成员有5种访问级别：</p><ul><li>私有的（private）：只能被自己类中的成员访问，不能被其他的类访问，即使是继承自它的类也不行</li><li>公有的（public）：所有的类都可以自由访问</li><li>受保护的（protected）：和private类似，唯一不同的是，它允许该类的派生类来访问</li><li>内部的（internal）：对程序集内部的所有类可见，对程序集外部的所有类不可见</li><li>受保护内部的（protected internal）：相当于internal与protected的并集，即对程序集内部的类可见，也对继承自该类的类可见。</li></ul><h2 id="抽象成员"><a href="#抽象成员" class="headerlink" title="抽象成员"></a>抽象成员</h2><p>类似于Java中的抽象方法。它使用abstract标记，并且必须是函数成员（方法、属性、事件、索引）。不能有实现代码块，抽象成员的实现用分号表示。即每一个抽象成员的声明后都要带一个分号</p><p>如：以下声明了两个抽象成员，一个名为PrintStuff的抽象方法和一个名为MyProperty的抽象属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintStuff</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty&#123;<br>    <span class="hljs-keyword">get</span>;    <span class="hljs-comment">//分号代替实现</span><br>    <span class="hljs-keyword">set</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>抽象类：只能被继承，不能用来创建实例，用abstract修饰符标注</li><li>密封类：与抽象类相反，只能被用来创建实例，不能被继承。用sealed修饰符标注</li></ul><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>如果面对一个用户自定义的类或结构，运算符就会不知道如何取处理它。运算符重载允许用户自己定义C#运算符来操作自定义类型的操作数。</p><ul><li>为类或结构重载一个运算符x，可以声明一个名称为<code>operator x</code>的方法并实现它的行为（如<code>operator +</code>和<code>operator -</code>等）。一元运算符的重载方法带有一个单独的class或struct类型的参数，二元运算符重载的方法带有两个参数，其中至少有一个是class或struct类型。</li><li>声明必须同时使用static和public的修饰符</li><li>运算符必须要是要操作的类或结构的成员</li></ul><p>如下代码声明了LimitedInt类的两个重载的运算符：一个是加运算符，另一个是取负运算符</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitedInt</span> <span class="hljs-title">Return</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LimitedInt <span class="hljs-keyword">operator</span> + (LimitedInt x, <span class="hljs-built_in">double</span> y)&#123;<br>        LimitedInt li = <span class="hljs-keyword">new</span> LimitedInt();<br>        li.TheValue = x.TheValue + (<span class="hljs-built_in">int</span>)y;<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LimitedInt <span class="hljs-keyword">operator</span> - (LimitedInt x)&#123;<br>        LimitedInt li = <span class="hljs-keyword">new</span> LimitedInt();<br>        li.TheValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h2><p>标签语句由一个标识符后面跟着一个冒号再跟着一条语句组成，它有如下的形式：<code>Identifier: Statement</code>。这条语句在执行时与只有Statement的语句相同，加一个标签的目的只是为了允许程序从其他位置跳转到这个标签所在的位置。  </p><ul><li>因为标签有自己的声明空间，所以标签语句中的标识符可以是任意有效的标识符（可以与本地变量名相同）。</li><li>标签的作用域仅在块内部</li></ul><p>goto语句可以跳到它本身所在的块中的任何标签语句，或跳出到任何它被嵌套的块内的标签语句。<code>goto Indentifier</code></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组和矩形数组"><a href="#一维数组和矩形数组" class="headerlink" title="一维数组和矩形数组"></a>一维数组和矩形数组</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] intArr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">15</span>];   <span class="hljs-comment">//声明一维数组</span><br><span class="hljs-built_in">int</span>[,] intArr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>, <span class="hljs-number">10</span>];  <span class="hljs-comment">//声明二维数组</span><br><span class="hljs-built_in">int</span> var2 = intArr[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>];      <span class="hljs-comment">//从二维数组中读值</span><br><br><span class="hljs-built_in">int</span>[] intArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;   <span class="hljs-comment">//初始化一维数组</span><br><span class="hljs-built_in">int</span>[,] intArr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[,]&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;&#125;; <span class="hljs-comment">//初始化二维数组</span><br></code></pre></td></tr></table></figure><h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p>交错数组是<strong>数组的数组</strong>，与矩阵数组不同，交错数组的子数组的元素个数可以不同</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//实例化顶层数组，不能在声明语句中初始化顶层数组之外的数组长度</span><br><span class="hljs-built_in">int</span>[][] Arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>][];  <br><span class="hljs-comment">//实例化子数组</span><br>Arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>Arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>Arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h2><p>注意：迭代变量item是只读的，不能修改。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> arr1)<br>    Console.WriteLine(<span class="hljs-string">&quot;Item Value: &#123;0&#125;, item&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Daniel M.Solis. Illustrated C# Fourth Edition [M]. 人民邮电出版社, 2013.</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】258.各位相加</title>
    <link href="/2021/02/19/258.%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/02/19/258.%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258.各位相加"></a>258.各位相加</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p><pre><code>示例:输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>分析如下：</p><ul><li><p>整数abc变为a+b+c的过程中减少的值一定是9的倍数，证明如下：<br>$$abc = a * 100 + b * 10 + c = a * 99 + b * 9 + (a + b + c)$$</p></li><li><p>例如：从384变为15的过程中减去的369为9的倍数。从15变为6的过程中减去的9也为9的倍数.因此从384变到最后的一位数6的过程中减去的369+9也为9的倍数</p></li><li><p>也就是说：我们对所给的数字nums榨干它包含的所有的9，即为所求的最后一位数。也即求num%9。但如果num本来即为9的倍数，如18、369,那么直接返回9.</p></li><li><p>注意：nums为个位数时需要特殊处理</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> num;<br>    <span class="hljs-keyword">return</span> num % <span class="hljs-number">9</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">9</span> : num % <span class="hljs-number">9</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】172.阶乘后的0</title>
    <link href="/2021/02/19/172.%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%840/"/>
    <url>/2021/02/19/172.%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%840/</url>
    
    <content type="html"><![CDATA[<h1 id="172-阶乘后的0"><a href="#172-阶乘后的0" class="headerlink" title="172.阶乘后的0"></a>172.阶乘后的0</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><pre><code>示例 1:输入: 3输出: 0解释: 3! = 6, 尾数中没有零。示例 2:输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零.说明: 你算法的时间复杂度应为 O(log n) 。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>如果计算出阶乘后再统计尾数中0的数量的话，当n很大时计算阶乘的过程肯定会溢出。因此需要考虑其他方法</p><p>题目要求的是结果中**<em>尾数为0**</em>的数量，其他的0不用管。分析可知，只有乘10才会在一个数的尾数中添一个0。而10只能分解成2和5两个因子，因此在计算阶乘的过程中每出现的一对2 * 5都会在结尾贡献一个0。</p><p>进一步分析，每一个偶数都有一个因子2，每一个5的倍数都有一个因子5。在所有小于n的数中，偶数的个数肯定多余5的倍数的个数，因此因子2出现的次数肯定比因子5出现的次数多，而且必须2和5结合在一起才能凑成一个10。因此，要统计在计算阶乘的过程中乘过多少10，只需要统计乘过多少5即可（因为2出现的次数足够多）。</p><p>在小于n的数中，每一个5的倍数都会贡献5。其中：</p><ul><li>在5-25之间的5的倍数会贡献1个5</li><li>在25-125之间的5的倍数会贡献2个5</li><li>在125-625之间的5的倍数会贡献3个5</li><li>依次类推</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        res += (n/<span class="hljs-number">5</span>);<br>        n=n/<span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】169.多数元素</title>
    <link href="/2021/02/19/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/19/169.%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169 多数元素"></a>169 多数元素</h1><p><strong>题目：</strong><br>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:<br>输入: [3,2,3]<br>输出: 3  </p><p>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2  </p><p><strong>思路：</strong>  </p><blockquote><p>哈希表方法：<br>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。<br>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。<br>时间复杂度和空间复杂度都是O(n)</p></blockquote><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//建立一个哈希表，并将数组中所有元素入表</span><br>        <span class="hljs-comment">//key为数组中元素，value为其出现的次数</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!map.containsKey(num))<br>                map.put(num, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span><br>                map.put(num, map.get(num) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//遍历每一个key，如果其value大于数组长度的一半，返回这个key</span><br>        <span class="hljs-keyword">for</span>(Object o : map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>((Integer)map.get(o) &gt; nums.length / <span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">return</span> (Integer)o;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二</strong>(排序方法)：<br>先排序，然后返回排序好的数组的中间位置的元素<br>时间复杂度和空间复杂度都是O(nlogn)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】128. 最长连续序列</title>
    <link href="/2021/02/19/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2021/02/19/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</p><p> </p><pre><code>示例 1：输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。示例 2：输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9</code></pre><p>注：对于示例1，nums的最长数字连续子序列其实为[4,1,3,2]，在解释中为了方便表示其数字连续性，因此写为[1,2,3,4]</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于数组nums，其可能有多个数字连续的序列，其中每个序列都会有一个左边界，例如示例1的结果中[1, 2, 3, 4]的左边界就为1。</p><p><strong>核心思路：</strong><br>如果我们知道了每一个连续序列的左边界，并且知道以它为左边界的连续序列的长度。进而就可以知道所有连续序列的长度。在其中取最大值即为结果。</p><p>但都有哪些数可以成为连续序列的左边界呢？</p><p>设想，如果num为一个左边界，那么num - 1就不应该存在于数组中（因为如果num - 1存在于数组中，num - 1又与num连续，所以num不可能是连续序列的左边界）。<br> 因此如果一个数字num满足：num-1不存在于数组中。这个数字num就可以成为连续序列的左边界。</p><p>具体的算法流程如下；</p><p>准备一个HashSet，将所有元素入set，之后遍历数组中的每一个数num</p><ul><li>如果num - 1存在于set中，那么num不可能是左边界，直接跳过</li><li>如果num - 1不存在于set中，那么num会是一个左边界，我们再不断地查找num+1、num+2……是否存在于set中，来看以num为左边界的连续序列能有多长</li></ul><p>在上述遍历中，我们知道了对于每一个可能的左边界，能扩出的最长连续序列的长度，再在这些长度中取最大即为结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        set.add(num);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span>(set.contains(num - <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//len记录以num为左边界的连续序列的长度</span><br>            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; <br>            <span class="hljs-keyword">while</span>(set.contains(num++))<br>                len++;<br>            res = Math.max(res, len);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)<br>  看似有双重循环，但仔细分析可知，数组中的每一个元素最多也就会被访问两次，因此还是线性的时间复杂度</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】29.两数相除</title>
    <link href="/2021/02/19/29.%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <url>/2021/02/19/29.%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><p> </p><pre><code>示例 1:输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3示例 2:输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2</code></pre><p> </p><p>提示：</p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>首先考虑溢出的问题：在Java中，int型占4字节32位。int型的最大值为：Integer.MIN_VALUE= -2147483648 （-2的31次方）。最小值为：Integer.MAX_VALUE= 2147483647  （2的31次方-1）。因此，如果用-2147483648除以-1，得到的2147483648肯定会溢出，这种情况需要特殊处理。</li><li>先根据除数和被除数的正负判断结果的正负。再把除数和被除数都转换为正数来计算。最后给结果加上正负号。</li><li>真正的相除操作实现在div函数中，简单来说就是如下过程：60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7。具体看注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(dividend == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//为了处理溢出的问题，需要特殊考虑除数为1和-1的情况</span><br>    <span class="hljs-keyword">if</span>(divisor == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dividend;<br>    <span class="hljs-keyword">if</span>(divisor == -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(dividend == Integer.MIN_VALUE)<br>            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span> -dividend;<br>    &#125;<br>    <span class="hljs-keyword">long</span> a = dividend;<br>    <span class="hljs-keyword">long</span> b = divisor;<br>    <span class="hljs-keyword">boolean</span> isPoistive = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//根据除数和被除数的正负判断结果的正负，并把除数和被除数都转换为正数</span><br>    <span class="hljs-keyword">if</span>((a &gt; <span class="hljs-number">0</span> &amp;&amp; b &lt; <span class="hljs-number">0</span>) || (a &lt; <span class="hljs-number">0</span> &amp;&amp; b &gt; <span class="hljs-number">0</span>))<br>        isPoistive = <span class="hljs-keyword">false</span>;<br>    a = Math.abs(a);<br>    b = Math.abs(b);<br>    <span class="hljs-keyword">long</span> res = div(a, b);<br>    <span class="hljs-keyword">if</span>(isPoistive)<br>        <span class="hljs-keyword">return</span> res &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (<span class="hljs-keyword">int</span>) res;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) -res;<br>&#125;<br><br><span class="hljs-comment">//例如25：4</span><br><span class="hljs-comment">//1 * 4 &lt; 25,于是让1翻倍</span><br><span class="hljs-comment">//2 * 4 &lt; 25,于是让2翻倍</span><br><span class="hljs-comment">//4 * 4 &lt; 25,于是让4翻倍</span><br><span class="hljs-comment">//8 * 4 &lt; 35,于是让8翻倍</span><br><span class="hljs-comment">//16 * 4 &gt; 35,可以判断结果肯定位于8和16之间</span><br><span class="hljs-comment">//结果为: 8 + (35 - 4*8) / 4</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a &lt; b)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> sum = b;<br>    <span class="hljs-keyword">while</span>(sum + sum &lt;= a)&#123;<br>        count = count + count;<br>        sum = sum + sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (count + div(a - sum, b));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/problems/divide-two-integers/solution/po-su-de-xiang-fa-mei-you-wei-yun-suan-mei-you-yi-/">leetcode题解区</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】381.O(1) 时间插入、删除和获取随机元素 - 允许重复</title>
    <link href="/2021/02/19/381.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/"/>
    <url>/2021/02/19/381.%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381.O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>381.O(1) 时间插入、删除和获取随机元素 - 允许重复</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。</p><p>注意: 允许出现重复元素。</p><ul><li>insert(val)：向集合中插入元素 val。</li><li>remove(val)：当 val 存在时，从集合中移除一个 val。</li><li>getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</li></ul><p>示例：</p><pre><code>// 初始化一个空的集合。RandomizedCollection collection = new RandomizedCollection();// 向集合中插入 1 。返回 true 表示集合不包含 1 。collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。collection.insert(2);// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。collection.getRandom();// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。collection.remove(1);// getRandom 应有相同概率返回 1 和 2 。collection.getRandom();</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>remove操作让我们用O(1)的时间复杂度删除给定的val，但删除前，我们需要先找到val。因此考虑用O(1)的时间复杂度来进行查找，有两种方法：哈希表和数组（用索引实现O(1))</p><p>但是用数组(或列表)的话，查找操作是O(1)，但删除操作并不是O(1)的，因为删除一个元素往往意味着要移动其他元素。因此我们可以每次删除一个元素val时，都将这个元素和列表末尾元素交换，再删除末尾，这样也就相当于删除元素val了。</p><p>这样一来，我们同时就需要一个哈希表，来将val与其下标的关系记录下来。</p><ul><li>删除操作：通过哈希表找到val的一个下标i，先将数组i位置的元素和尾位置的元素交换后删除nums尾部。再更新尾位置元素和i位置元素在哈希表中对应的下标。</li><li>插入操作：插入元素时，直接将val插入nums的末尾，并更新val在哈希表中对应的下标。</li><li>getRandom操作：随机生成一个位置索引,返回这个索引对应的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedCollection</span> </span>&#123;<br>    List&lt;Integer&gt; nums;<br>    Map&lt;Integer, Set&lt;Integer&gt;&gt; map;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RandomizedCollection</span><span class="hljs-params">()</span> </span>&#123;<br>        nums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//直接将val插入到列表末尾，并更新val在哈希表中对应的下标</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(val))&#123;<br>            nums.add(val);<br>            map.get(val).add(nums.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            nums.add(val);<br>            Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>            set.add(nums.size() - <span class="hljs-number">1</span>);<br>            map.put(val, set);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(val))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//先更新val在哈希表中对应的索引</span><br>            Set&lt;Integer&gt; set = map.get(val);<br>            <span class="hljs-keyword">int</span> i =set.iterator().next();<br>            set.remove(i);<br>            <span class="hljs-keyword">if</span>(set.size() ==<span class="hljs-number">0</span>)&#123;<br>                map.remove(val);<br>            &#125;<br>            <span class="hljs-comment">//再将val与尾元素交换，删除尾元素，更新尾元素在哈希表中对应的索引</span><br>            <span class="hljs-keyword">int</span> lastNumIndex = nums.size()-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i == lastNumIndex)&#123;<br>                nums.remove(lastNumIndex);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> lastNum = nums.remove(lastNumIndex);<br>                nums.set(i,lastNum);<br>                map.get(lastNum).remove(lastNumIndex);<br>                map.get(lastNum).add(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the collection. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//随机生成一个索引,返回这个索引对应的值</span><br>        <span class="hljs-keyword">int</span> index = (<span class="hljs-keyword">int</span>)(Math.random() * nums.size());<br>        <span class="hljs-keyword">return</span> nums.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】260.只出现一次的数字 III</title>
    <link href="/2021/02/19/260.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%20III/"/>
    <url>/2021/02/19/260.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%20III/</url>
    
    <content type="html"><![CDATA[<h1 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260.只出现一次的数字 III"></a>260.只出现一次的数字 III</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><p>示例 :</p><p>输入: [1,2,1,3,2,5]<br>输出: [3,5]</p><h2 id="方法（位运算）"><a href="#方法（位运算）" class="headerlink" title="方法（位运算）"></a>方法（位运算）</h2><p>由于两个相同的数字异或的结果为0，因此将数组中所有元素异或得到的结果res即为两个Single Number异或的结果</p><p>我们进行如下考虑：<br>如果我们将数组中的元素分为两组，每组中只有一个Single Number，那么只要把这两个组的组内元素全部异或，就会分别得到两个Single Number。</p><p>但是如何进行分组才能将两个Single Number正确地分到两个组呢？<br>我们在上面得到了两个Single Number异或得到的结果res。在res中为1的bit位上，两个Single Number的取值肯定不同（如果两个数在这一位上都为1或者都为0，那么异或结果在这一位上必然为0）。我们可以用这一特性来进行分组：</p><ul><li>先找到res中值为1的最低bit位</li><li>在这一位上为1的元素放到一组，在这一位上为0的元素放到另一组</li></ul><p>这样就可以保证两个Single Number被分到两个不同的组，而且同样的元素肯定会被分到同一组。最后组内进行异或，便可分别得到这两个Single Number</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumber(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        res ^= num;<br>    <span class="hljs-keyword">int</span> lowbit = res &amp; (-res);<br>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span>((num &amp; lowbit) == <span class="hljs-number">0</span>)<br>            num1 ^= num;<br>        <span class="hljs-keyword">else</span><br>            num2 ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num1, num2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>注：</strong><br>将一个数与它的相反数进行与操作，可以获得这个数中值为1的最低bit位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> lowbit = res &amp; (-res)<br></code></pre></td></tr></table></figure><p>因为在计算机中，-res由res中的各位都取反，再在最低位上加1来得到</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】231.2的幂</title>
    <link href="/2021/02/19/231.2%E7%9A%84%E5%B9%82/"/>
    <url>/2021/02/19/231.2%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231 2的幂"></a>231 2的幂</h1><p><strong>题目：</strong><br>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>一直除2看最后得到的是否为1，这种方法的时间复杂度为O(logn)。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            n = n / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二-位运算-："><a href="#方法二-位运算-：" class="headerlink" title="方法二(位运算)："></a>方法二(位运算)：</h2><p>所有为2的幂的整数，其二进制均是除了其有效最高位以外全是0的数。也就是说，我们只需要判断这个数是否有除了有效最高位之外还有没有其他的1即可。</p><p>这里可以用到一个位运算小技巧：给定一个数n，将n和(n-1)做一次与运算，即可将n的最后一位1去掉。例如9和8，即1001 &amp; 1000 = 1000，把最后一位的1去掉。再例如12和11，即1100 &amp; 1011 = 1000，最后一位的1被去掉。</p><p>那么对于所有2的幂，我们将它与它-1后的数做一次与运算，就会将其唯一一位1消去，最后等于0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都为O(1)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】137.只出现一次的数字 II</title>
    <link href="/2021/02/19/137.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <url>/2021/02/19/137.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</url>
    
    <content type="html"><![CDATA[<h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137.只出现一次的数字 II"></a>137.只出现一次的数字 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><pre><code>示例 1:输入: [2,2,3,2]输出: 3示例 2:输入: [0,1,0,1,0,1,99]输出: 99</code></pre><h2 id="方法（位运算）"><a href="#方法（位运算）" class="headerlink" title="方法（位运算）"></a>方法（位运算）</h2><p>把每一个整数考虑成长度为32位的二进制数。我们累计这32位中每一位上1出现的次数。由于数组中除一个元素外，其他元素都出现了三次。所以每一位上1出现的次数只能是3的倍数或者是3的倍数+1。因此对这个次数模3后就是只出现一次的那个数在该位上的值（1或0）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br>        <span class="hljs-comment">//count用来统计第i位上出现了多少次1</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums)&#123;<br>            count += (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">//右边为num的第i位上的值</span><br>        &#125;<br>        <span class="hljs-comment">//count % 3只能是0或1</span><br>        <span class="hljs-comment">//通过异或操作将num的第i位上的值设置好</span><br>        res ^= (count % <span class="hljs-number">3</span>) &lt;&lt; i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：对于异或操作：</p><ul><li>任何一个数字异或0的结果都是这个数字本身</li><li>两个相同的数字异或的结果为0</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】58.最后一个单词的长度</title>
    <link href="/2021/02/19/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <url>/2021/02/19/58.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58 最后一个单词的长度"></a>58 最后一个单词的长度</h1><p><strong>题目：</strong><br>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。</p><p>示例:<br>输入: “Hello World”<br>输出: 5</p><p><strong>思路：</strong><br>从字符串末尾开始向前遍历，其中主要有两种情况：<br>第一种情况，以字符串”Hello World”为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词”World”的长度5</p><p>第二种情况，以字符串”Hello World   “为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为”World”，长度为5</p><p>所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度<br>时间复杂度：O(n)，n为结尾空格和结尾单词总体长度</p><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> end = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//排除掉所有末尾的空格，用end标识最后一个单词的最后一个字母</span><br>        <span class="hljs-keyword">while</span>(end &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>)<br>            end--;<br>        <span class="hljs-keyword">if</span>(end &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = end;<br>        <span class="hljs-comment">//用start标识最后一个单词的第一个字母</span><br>        <span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) != <span class="hljs-string">&#x27; &#x27;</span>)<br>            start--;<br>        <span class="hljs-keyword">return</span> end - start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】173.二叉搜索树迭代器</title>
    <link href="/2021/02/19/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2021/02/19/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173.二叉搜索树迭代器"></a>173.二叉搜索树迭代器</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p><p>调用 next() 将返回二叉搜索树中的下一个最小的数。  </p><pre><code>示例：    7  /   \ 3     15      /   \     9    20 BSTIterator iterator = new BSTIterator(root);iterator.next();    // 返回 3iterator.next();    // 返回 7iterator.hasNext(); // 返回 trueiterator.next();    // 返回 9iterator.hasNext(); // 返回 trueiterator.next();    // 返回 15iterator.hasNext(); // 返回 trueiterator.next();    // 返回 20iterator.hasNext(); // 返回 false</code></pre><p>要求：  </p><ul><li>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。</li><li>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。</li></ul><h2 id="方法一（用队列）"><a href="#方法一（用队列）" class="headerlink" title="方法一（用队列）"></a>方法一（用队列）</h2><p>我们知道对于二叉搜索树来说，其中序遍历的结果是一个升序序列。因此，我们先中序遍历二叉搜索树，将树中元素的升序排列存放在一个队列中。每当调用 next() 时，我们就从队列中弹出一个元素（升序保证它是最小的），每当调用hasNext() 时，我们只需检查队列中还有没有剩余元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        dfs(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        queue.add(root.val);<br>        dfs(root.right);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@return</span> the next smallest number */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@return</span> whether we have a next smallest number */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种方法来说，next和hasNext函数的时间复杂度都为O(1),符合题目要求。但是需要用O(n)辅助空间的队列来存储元素，不符合题目中空间复杂度为O(h)的要求（h为树高度）</p><h2 id="方法二（用栈）"><a href="#方法二（用栈）" class="headerlink" title="方法二（用栈）"></a>方法二（用栈）</h2><p>对于二叉搜索树来说，其最左的那个元素就是树中最小的元素。因此，我们先将根节点root及其左子树的所有节点依次入栈，这样栈顶就是树中最左的元素，也即树中最小的元素。</p><p>每当调用next()，返回栈顶元素（树中最小元素），并将其右子节点及右子节点左子树的所有节点入栈，以便之后的next()操作。</p><p>每当调用hasNext()时，我们只需检查队列中还有没有剩余元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;TreeNode&gt; stack;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        leftInorder(root);<br>    &#125;<br>    <span class="hljs-comment">//将root及其子树的所有节点入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftInorder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(root);<br>            root = root.left;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@return</span> the next smallest number */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        TreeNode mostleftNode = stack.pop();<br>        <span class="hljs-keyword">if</span>(mostleftNode.right != <span class="hljs-keyword">null</span>)<br>            leftInorder(mostleftNode.right);<br>        <span class="hljs-keyword">return</span> mostleftNode.val;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@return</span> whether we have a next smallest number */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack.size() &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li>next(): 平均下来为O(1)</li><li>hasNext(): O(1)</li></ul><p>空间复杂度：O(h)  h为树的高度</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】146.LRU缓存机制</title>
    <link href="/2021/02/19/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/19/146.%20LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:</p><pre><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得关键字 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得关键字 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>题目要求我们构建一个数据结构，并实现两种API：put操作和get操作，因为要在O(1)时间复杂度内完成这两种操作，所以这一数据结构要求满足以下几个特点：<strong>插入快、查找快、删除快、并且有序</strong>（因为需要有序来区分最近使用的和久未使用的数据）。</p><p>考虑我们学过的数据结构，链表可以做到有序，插入和删除也快，但是查找操作很慢。哈希表的插入查找删除都为O(1),但是不能做到有序。因此将两个结构相结合，构成哈希链表，即可同时拥有以上特性。</p><p>因此，我们需要同时维护一个哈希表和一个双向链表，双向链表的节点中存放数据结构Node（包括key和value），哈希表的键为key，值为存放这个key的Node节点。如下图所示：</p><p><img src="/img/146.%E5%9B%BE1.jpg"></p><p>Node类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key, value;<br>    <span class="hljs-keyword">private</span> Node next, pre;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.key = k;<br>        <span class="hljs-keyword">this</span>.value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双向链表DoubleList类如下（包括4个时间复杂度均为O(1)的实例方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Node head, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-comment">//在双向链表头部添加节点x</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-comment">//先处理向空链表中加入节点的情况</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>            head = tail = x;<br>        <span class="hljs-keyword">else</span> &#123;<br>            x.next = head;<br>            head.pre = x;<br>            head = x;<br>        &#125;<br>        size++;<br>    &#125;<br>    <span class="hljs-comment">//删除链表中的x节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x == head &amp;&amp; x == tail)&#123;<br>            head = <span class="hljs-keyword">null</span>;<br>            tail = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == tail)&#123;<br>            x.pre.next = <span class="hljs-keyword">null</span>;<br>            tail = x.pre;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == head)&#123;<br>            x.next.pre = <span class="hljs-keyword">null</span>;<br>            head = x.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            x.pre.next = x.next;<br>            x.next.pre = x.pre;<br>        &#125;<br>        size--;<br>    &#125;<br>    <span class="hljs-comment">//删除并返回双向链表的最后一个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>&#123;<br>        Node node = tail;<br>        remove(tail);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-comment">//返回双向链表的长度</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了以上两个结构，我们在LRU算法中将哈希表和双向链表结合起来即可，就可以在实现LRU算法的同时，将get和put这两操作的时间复杂度控制在O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-comment">//哈希表的键为key，值为key对应的Node节点（包含key和value）</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; map;<br>    <span class="hljs-keyword">private</span> DoubleList cache;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cache = <span class="hljs-keyword">new</span> DoubleList();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> value = map.get(key).value;<br>        put(key, value);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        Node x = <span class="hljs-keyword">new</span> Node(key, value);<br>        <span class="hljs-comment">//如果结构中本来有此key，则删除掉旧的节点，并把新的插到头部，然后更新map</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;<br>            cache.remove(map.get(key));<br>            cache.addFirst(x);<br>            map.put(key, x);<br>        &#125;<br>        <span class="hljs-comment">//如果结构中原来没有此key</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//如果容量已满，那么需要先删除尾部的节点，然后再将x添加到头部，同时更新map</span><br>            <span class="hljs-keyword">if</span>(capacity == cache.size())&#123;<br>                Node last = cache.removeLast();<br>                map.remove(last.key);<br>            &#125;<br>            cache.addFirst(x);<br>            map.put(key, x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】540.有序数组中的单一元素</title>
    <link href="/2021/02/19/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/19/540.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540.有序数组中的单一元素"></a>540.有序数组中的单一元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><pre><code>示例 1:输入: [1,1,2,3,3,4,4,8,8]输出: 2示例 2:输入: [3,3,7,7,10,11,11]输出: 10</code></pre><p>注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p><h2 id="方法（二分查找）"><a href="#方法（二分查找）" class="headerlink" title="方法（二分查找）"></a>方法（二分查找）</h2><p>所给数组有序，考虑使用二分法。</p><p>单一的元素左右两边的特点为：</p><ul><li>m为偶数时，在单一元素左边，nums[m] == nums[m + 1]</li><li>m为奇数时，在单一元素右边，nums[m] != nums[m + 1]</li></ul><p>可以据此来进行二分的流程，但是注意：一定要保证mid为偶数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            mid--;<br>        <span class="hljs-keyword">if</span>(mid &lt; nums.length - <span class="hljs-number">1</span> &amp;&amp; nums[mid] == nums[mid + <span class="hljs-number">1</span>])<br>            left = mid + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            right = mid - <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注：二分查找"><a href="#注：二分查找" class="headerlink" title="注：二分查找"></a>注：二分查找</h2><p>对于二分查找，要做到细节不出错，需要关注三件事：</p><ul><li>左右边界</li><li>循环条件</li><li>如何进入下一步循环</li></ul><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>左右边界是指，初始时left和right的取值，如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">left = <span class="hljs-number">0</span> , right = nums.length - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>则表明搜索范围是[left, right]这样一个闭区间</p><p>因此循环条件就应该写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(left &lt;= right)<br></code></pre></td></tr></table></figure><p>即：当left==right时，由于是闭区间，因此当前的查找范围[left, right]里尚且有一个元素，应该再次进入循环，而不是退出</p><p>进一步考虑，进入下一步循环就应该写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">left = mid + <span class="hljs-number">1</span>;<br>right = mid - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>因为当前mid位置已经查找过，下一步查找范围为闭区间[left, mid - 1]或者闭区间[mid, right]</p><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>但是，如果在初始化left和right时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">left = <span class="hljs-number">0</span>, right = nums.length<br></code></pre></td></tr></table></figure><p>则表明搜索范围是[left, right)这样一个左闭右开区间</p><p>因此循环条件就应该写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(left &lt; right)<br></code></pre></td></tr></table></figure><p>因为，left==right时，区间[left, right)里已经没有元素，不应该再进入循环。</p><p>进一步考虑，进入下一步循环就应该写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">left = mid + <span class="hljs-number">1</span>;<br>right = mid;<br></code></pre></td></tr></table></figure><p>因为在mid位置查找过后，因为查找区间均为左闭右开区间，原查找区间为[left, right)，因此下一步查找范围为区间[left, mid)，或者区间[mid + 1, right)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】287.寻找重复数</title>
    <link href="/2021/02/19/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <url>/2021/02/19/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287 寻找重复数"></a>287 寻找重复数</h1><p><strong>题目：</strong><br>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:<br>输入: [1,3,4,2,2]<br>输出: 2  </p><p>示例 2:<br>输入: [3,1,3,4,2]<br>输出: 3</p><p><strong>思路：二分查找</strong><br>这种方法只和数组中存在哪些数有关，和数组中这些数的顺序无关。因此分析时可把数组看成有序的（但其实并没有对数组进行排序，只是这么分析而已）<br>数组中所有的数字都在1到n之间，我们先取1到n的中位数mid。统计数组中小于等于mid的元素个数count，如果count大于mid，则说明重复数存在于1到mid之间。否则，重复数存在于mid+1到n之间。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> right = n;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//统计数组中小于等于mid的个数，mid为从1到n的中位数</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(num &lt;= mid)<br>                count++;<br>        &#125;<br>        <span class="hljs-comment">//如果小于等于mid的个数大于mid，则说明在1到mid中存在重复元素,否则，在mid+1到n中存在重复元素</span><br>        <span class="hljs-keyword">if</span>(count &gt; mid)<br>            right = mid;<br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：O(nlogn)</strong><br><strong>空间复杂度：O(1)</strong></p><p>注：如果没有不能修改数组和空间复杂度的要求，可以采用排序数组和哈希表的方法</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】162.寻找峰值</title>
    <link href="/2021/02/19/162.%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <url>/2021/02/19/162.%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162 寻找峰值"></a>162 寻找峰值</h1><p><strong>题目：</strong><br>峰值元素是指其值大于左右相邻值的元素。<br>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞。</p><p>示例 1:<br>输入: nums = [1,2,3,1]<br>输出: 2<br>解释: 3 是峰值元素，你的函数应该返回其索引 2。  </p><p>示例 2:<br>输入: nums = [1,2,1,3,5,6,4]<br>输出: 1 或 5<br>解释: 你的函数可以返回索引 1，其峰值元素为 2；  或者返回索引 5， 其峰值元素为 6。</p><h3 id="方法一：线性查找-双百解法"><a href="#方法一：线性查找-双百解法" class="headerlink" title="方法一：线性查找(双百解法)"></a>方法一：线性查找(双百解法)</h3><p><strong>分析：</strong><br>可以从以下几个情况考虑：<br>抓住只需要返回一个峰值和nums[i]不等于nums[i+1]这两个重点</p><ul><li>第一个值即为峰值：因为nums[-1]可看作负无穷，所以只要nums[0]&gt;nums[1]时，第一个值就成为了峰值。这种情况下无论数组后面是什么情况，直接返回0即可。</li><li>第一个值不是峰值：这种情况下，nums[0] &lt; nums[1],这种情况下数组的曲线一开始肯定是向上的走势，只要找到走势转向向下的那个点即可，即找到第一个nums[i]&gt;nums[i+1]的地方。如果没有这样的点，直接返回最后一个索引nums.length - 1。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i+<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.length - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度O(n)</strong><br><strong>空间复杂度O(1)</strong></p><h3 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h3><p><strong>思路：</strong><br>典型的二分查找过程，只需把nums[mid]和nums[mid+1]比较，如果前者小于后者，那么在mid处曲线呈升势，mid的右面一定有峰值，往右面查找。如果后者小于前者，则在mid处曲线呈将势，mid或mid左边一定有峰值，往左面查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度O(logn)</strong><br><strong>空间复杂度O(1)</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】81.搜索旋转排序数组 II</title>
    <link href="/2021/02/19/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <url>/2021/02/19/81.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    
    <content type="html"><![CDATA[<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81 搜索旋转排序数组 II"></a>81 搜索旋转排序数组 II</h1><p>和<a href="https://github.com/wyh317/Leetcode/blob/master/%E4%BA%8C%E5%88%86/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md">上面一道题</a>相似，只是允许在数组中可以出现重复元素</p><p>思路：先找到旋转点，然后看是需要在哪一边进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//原排序数组是升序，旋转后的数组打破了这个升序。</span><br>        <span class="hljs-comment">//即有且只有一个位置，其右边元素小于它，破坏了升序。先把这个位置找到，记为index</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i - <span class="hljs-number">1</span>])<br>                index = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//index左边和右边分别为两个升序数组，先判断target在哪个数组中，再在其中进行二分查找</span><br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[index])<br>            <span class="hljs-keyword">return</span> binsearch(nums, <span class="hljs-number">0</span>, index, target);<br>        <span class="hljs-keyword">if</span>(target &gt;= nums[index + <span class="hljs-number">1</span>] &amp;&amp; target &lt;= nums[nums.length - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> binsearch(nums, index + <span class="hljs-number">1</span>,nums.length - <span class="hljs-number">1</span>,target);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//此函数在数组nums中从left到right的位置上对target进行二分查找</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">binsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target == nums[mid])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】74.搜索二维矩阵</title>
    <link href="/2021/02/19/74.%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/02/19/74.%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74 搜索二维矩阵"></a>74 搜索二维矩阵</h1><p><strong>题目：</strong><br>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。<br>示例 1:</li></ul><p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true<br>示例 2:</p><p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 13<br>输出: false</p><p><strong>思路</strong>：<br>先二分找到target所在的行，再在此行中二分查找是否存在target这个元素</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> row = matrix.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = row;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//如果元素大于mid行的最大值，则其一定出现于大于mid的行</span><br>        <span class="hljs-keyword">if</span>(target &gt; matrix[mid][col])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//如果元素小于mid行的最小值，则其一定出现于小于mid的行</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; matrix[mid][<span class="hljs-number">0</span>])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//否则，元素存在于mid行，在该行中进行二分查找</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> binsearch(matrix[mid], target);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//此函数在数组num中查找元素target</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">binsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] num, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = num.length;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target == num[mid])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; num[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】69.X的平方根</title>
    <link href="/2021/02/19/69.X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2021/02/19/69.X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="69-X的平方根"><a href="#69-X的平方根" class="headerlink" title="69  X的平方根"></a>69  X的平方根</h1><p><strong>题目：</strong></p><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:<br>输入: 4<br>输出: 2  </p><p>示例 2:<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><p><strong>思路：二分查找</strong>  </p><p>   若x的平方根为k，则所要求的即为满足$k^2&lt;=x$的最大的k值。采用二分查找找到这个k值。k的左边界为0，右边界为x。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = x;<br>    <span class="hljs-keyword">int</span> ans = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) /<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)mid * mid &lt;= x)&#123;<br>            ans = mid;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】34.在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2021/02/19/34%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/02/19/34%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置"></a>34 在排序数组中查找元素的第一个和最后一个位置</h1><p><strong>题目：</strong><br>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p><p><strong>思路：</strong><br>用两次二分查找，一次查找左边，一次查找右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> left = searchLeft(nums, target);<br>    <span class="hljs-keyword">int</span> right = searchRight(nums, target);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left, right&#125;;<br>&#125;<br><span class="hljs-comment">//在nums中寻找target的右边界</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>            res = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//在nums中寻找target的左边界</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>            res = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】33.搜索旋转排序数组</title>
    <link href="/2021/02/19/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/19/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33 搜索旋转排序数组"></a>33 搜索旋转排序数组</h1><p><strong>题目：</strong><br>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。  </p><p>示例 1:<br>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:<br>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p><p><strong>思路：</strong><br>原排序数组是升序，旋转后的数组打破了这个升序。<br>即有且只有一个位置，其右边元素小于它，破坏了升序。先把这个位置找到，记为index。易知，index的右边即为数组的最小值。找到这个最小值就找到了index。</p><p>如何查找这个最小值呢？ 二分</p><ul><li>nums[0]&lt;=nums[max]说明整个数组是有序的，下标0就是最小值</li><li>如果num[i]&gt;nums[i+1]，不满足升序，说明mid+1就是最小值，退出查找</li><li>如果中间值nums[mid]&gt;=nums[0]说明数组左边是有序的，最小值应该在右边</li><li>如果中间值nums[mid]&lt;nums[0]说明数组左边是无序的，最小值应该在数组左边</li></ul><p><em>代码</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(nums==<span class="hljs-keyword">null</span> || nums.length==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//查找最小值的下标</span><br><span class="hljs-keyword">int</span> minIndex = findMin(nums);<br><span class="hljs-comment">//如果最小值下标为0，说明整个数组是有序的</span><br><span class="hljs-keyword">if</span>(minIndex==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> binarySearch(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>,target);<br>&#125;<br><span class="hljs-comment">//最终结果在[0,min_index-1]中</span><br><span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=target) &#123;<br><span class="hljs-keyword">return</span> binarySearch(nums,<span class="hljs-number">0</span>,minIndex-<span class="hljs-number">1</span>,target);<br>&#125;<br><span class="hljs-comment">//最终结果在[min_index,length-1]中</span><br><span class="hljs-keyword">return</span> binarySearch(nums,minIndex,nums.length-<span class="hljs-number">1</span>,target);<br>&#125;<br><br><br><span class="hljs-comment">//此函数在数组nums中从left到right的位置上对target进行二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target == nums[mid])<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//查找最小值位置的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> end = nums.length-<span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果第一个值比最后一个值小，说明整个数组是有序的</span><br><span class="hljs-keyword">if</span>(nums[begin]&lt;=nums[end]) &#123;<br><span class="hljs-keyword">return</span> begin;<br>&#125;<br><span class="hljs-keyword">while</span>(begin&lt;=end) &#123;<br><span class="hljs-keyword">int</span> mid = begin+(end-begin)/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//前一个值比后一个值大，找到了旋转点</span><br><span class="hljs-keyword">if</span>(mid&lt;nums.length-<span class="hljs-number">1</span> &amp;&amp; nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">return</span> mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//中间点大于等于第一个元素，左半边是有序的，转去右边查找</span><br><span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[<span class="hljs-number">0</span>]) &#123;<br>begin = mid+<span class="hljs-number">1</span>;<br><span class="hljs-comment">//左边是无序的，继续在左边查找</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>end = mid-<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><br>数组长度为0和数组为null不一样。</p><p>int[] array = {};</p><p>此时数组的长度为0，是一个空数组，但是array不是null，它也是一个对象，只不过它的元素个数为0。</p><p>int[] array1 = null;</p><p>array1是数组类型的空引用，栈中名为array1的内存空间没有存放任何地址。</p><p>所以边界判断时，应该按如下顺序写：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span>(<span class="hljs-attribute">nums</span>==null || nums.<span class="hljs-attribute">length</span>==0)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】241.为运算表达式设计优先级</title>
    <link href="/2021/02/19/241.%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2021/02/19/241.%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241.为运算表达式设计优先级"></a>241.为运算表达式设计优先级</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p><pre><code>示例 1:输入: &quot;2-1-1&quot;输出: [0, 2]解释: ((2-1)-1) = 0 (2-(1-1)) = 2示例 2:输入: &quot;2*3-4*5&quot;输出: [-34, -14, -10, -10, 10]解释: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10</code></pre><h2 id="方法（分治法）"><a href="#方法（分治法）" class="headerlink" title="方法（分治法）"></a>方法（分治法）</h2><p>分治法即”分而治之”，其基本思想为：将一个复杂的问题<strong>分解</strong>为一些规模较小的相同子问题，递归解决这些子问题，再将子问题的解<strong>合并</strong>即可得到原问题的解。</p><p>因此分治法需要关注三个内容：</p><ul><li>分解：将原问题分解为子问题，并递归解决子问题</li><li>合并：将子问题的解合并为原问题的解</li><li>递归返回条件：为了避免无限分解子问题，需要设置递归返回条件</li></ul><p>典型的应用分治法的例子：快速排序、归并排序、二叉树的一些问题（如找出二叉树最大深度、判断二叉树是否平衡）</p><p>对于这道题：  </p><ul><li>分解：我们先将计算一个大运算表达式的原问题，分解为计算左右两个小运算表达式的子问题。之后递归解决子问题、得到子问题的解。</li><li>合并：最后根据左右两个小运算表达式之间的符号确定如何对子问题的解进行合并，得到原问题的解。</li></ul><p>如何分解子问题呢？<br>我们以input中每一个运算符为分界，将这个运算符左边和右边分为两个小运算表达式。相当于先计算左右两个小运算表达式（优先级高），再根据这个运算符来合并为原运算表达式的解（优先级低）。</p><p>遍历input中所有的运算符，进行上述分治步骤，因此每一个运算符都曾经成为过优先级最低的运算符，这样保证了最后结果的全面性。</p><p>注意：如果给定的字符串input只有数字，没有运算符，那结果就是给定的字符串的数字表示。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(String input)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//递归返回条件</span><br>    <span class="hljs-keyword">if</span>(input.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-comment">//flag记录input中是否含有运算符</span><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; input.length(); i++)&#123;<br>        <span class="hljs-keyword">char</span> ch = input.charAt(i);<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        flag = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//分解：left列表和right列表分别包含左边和右边可能的计算结果</span><br>        List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="hljs-number">0</span>, i));<br>        List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//合并：根据运算符ch将子问题的解合并为原问题的解</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> L : left)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> R : right)&#123;<br>                <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                    res.add(L + R);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                    res.add(L - R);<br>                <span class="hljs-keyword">else</span><br>                    res.add(L * R);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//处理字符串input中只有数字，没有运算符的情况</span><br>    <span class="hljs-keyword">if</span>(!flag) &#123;<br>        res.add(Integer.valueOf(input));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在递归的过程中，会产生大量的重复计算。因此，如果我们将已计算出的结果保存起来，在下次需要这步计算时直接取出结果，就可避免重复计算。这种方式被称为<strong>记忆化搜索</strong></p><p>以下为记忆化搜索修改后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(String input)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(input.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">if</span>(map.containsKey(input))<br>        <span class="hljs-keyword">return</span> map.get(input);<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; input.length(); i++)&#123;<br>        <span class="hljs-keyword">char</span> ch = input.charAt(i);<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        flag = <span class="hljs-keyword">true</span>;<br>        List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="hljs-number">0</span>, i));<br>        List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> L : left)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> R : right)&#123;<br>                <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                    res.add(L + R);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                    res.add(L - R);<br>                <span class="hljs-keyword">else</span><br>                    res.add(L * R);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag) &#123;<br>        res.add(Integer.valueOf(input));<br>        map.put(input, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    map.put(input, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】215.数组中的第K个最大元素</title>
    <link href="/2021/02/19/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/19/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215.数组中的第K个最大元素"></a>215.数组中的第K个最大元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><pre><code>示例 1:输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2:输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h2 id="方法一（排序）"><a href="#方法一（排序）" class="headerlink" title="方法一（排序）"></a>方法一（排序）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> nums[nums.length - k];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h2 id="方法二（堆）"><a href="#方法二（堆）" class="headerlink" title="方法二（堆）"></a>方法二（堆）</h2><p>维护一个大小为K的小根堆。遍历数组</p><ul><li>当堆中元素不足k个时，直接将元素加入堆中</li><li>当堆中元素大于等于k个时：<ul><li>如果当前元素比堆顶元素大，那么它就比堆顶元素更有资格位列K个最大的元素，因此让堆顶弹出，让它进来。</li><li>如果当前元素比堆顶元素小，则不做任何操作。保证堆中元素是遍历到当前为止K个最大的元素。</li></ul></li></ul><p>最后，堆顶元素即为第K个最大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span>(heap.size() &lt; k)<br>            heap.add(num);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(num &gt; heap.peek())&#123;<br>                heap.poll();<br>                heap.add(num);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap.peek();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(NlogK)</li><li>空间复杂度：O(K)</li></ul><h2 id="方法三（快速选择）"><a href="#方法三（快速选择）" class="headerlink" title="方法三（快速选择）"></a>方法三（快速选择）</h2><p>要找倒数第k个元素，也即找到正着数第len - k + 1个元素。假如对数组进行排序，这个元素应该位于len - k 个位置</p><p>先对整个数组num进行partition操作</p><ul><li>如果第len - k个位置正好处在等于区域，那么等于区域的值就是要找的元素</li><li>如果第len - k个位置位于等于区域右边，则需要在大于区域寻找nums中第len - k + 1小的元素</li><li>如果第len - k个位置位于等于区域左边，则需要在小于区域寻找nums中第len - k + 1小的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums.length - k );<br>&#125;<br><span class="hljs-comment">//在start到end的范围里，寻找nums中第i+1小的元素(正序后第i位置的元素）</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start == end)<br>        <span class="hljs-keyword">return</span> nums[start];<br>    <span class="hljs-keyword">int</span>[] pivotRange = partition(nums, start, end);<br>    <span class="hljs-keyword">if</span>(i &gt;= pivotRange[<span class="hljs-number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> nums[i];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; pivotRange[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> quickSelect(nums, pivotRange[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, end, i);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> quickSelect(nums, start, pivotRange[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)&#123;<br>    <span class="hljs-keyword">int</span> randomIndex = (<span class="hljs-keyword">int</span>)Math.random() * (end - start + <span class="hljs-number">1</span>) + start;<br>    <span class="hljs-keyword">int</span> pivot = nums[randomIndex];<br>    <span class="hljs-keyword">int</span> less = start - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> more = end + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cur = start;<br>    <span class="hljs-keyword">while</span>(cur &lt; more)&#123;<br>        <span class="hljs-keyword">if</span>(nums[cur] &lt; pivot)<br>            swap(nums, ++less, cur++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] &gt; pivot)<br>            swap(nums, --more, cur);<br>        <span class="hljs-keyword">else</span><br>            cur++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;less + <span class="hljs-number">1</span>, more - <span class="hljs-number">1</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><h2 id="方法二和方法三的对比"><a href="#方法二和方法三的对比" class="headerlink" title="方法二和方法三的对比"></a>方法二和方法三的对比</h2><p>很明显，快速选择算法有更好的时间和空间复杂度。但是其也有一些缺点：</p><ul><li>快速选择算法需要给出所有的数据，才能运行算法。而堆可以对于给定的输入流动态地处理，只需要维护一个大小为k的堆，输入流中的数据来一个处理一个，就可以保证堆中总是输入流中最小的k个数</li><li>快速选择排序需要修改原数组。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】95.不同的二叉搜索树 II</title>
    <link href="/2021/02/19/95.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/"/>
    <url>/2021/02/19/95.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95.不同的二叉搜索树 II"></a>95.不同的二叉搜索树 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p><p> </p><pre><code>示例：输入：3输出：[  [1,null,3,2],  [3,2,null,1],  [3,1,null,null,2],  [2,1,3],  [1,null,2,null,3]]解释：以上的输出对应以下 5 种不同结构的二叉搜索树：   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</code></pre><h2 id="方法（分治法）"><a href="#方法（分治法）" class="headerlink" title="方法（分治法）"></a>方法（分治法）</h2><p>原问题让我们生成由1到n为节点组成的二叉搜索树。那么我们可以用分治法将原问题分解</p><ul><li>分解：将原问题分解为以下两个子问题，并递归求解(i为1到n的任意一个节点)<ul><li>生成由1到i-1为节点组成的二叉搜索树</li><li>生成由i+1到n为节点组成的二叉搜索树</li></ul></li><li>合并：令节点i作为根节点，令它的左右子节点分别为由（1…i-1）组成的BST和由（i+1…n）组成的BST</li><li>递归结束条件：start &gt; end时，递归结束</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    <span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    List&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>        res.add(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++)&#123;<br>        List&lt;TreeNode&gt; left = generate(start, i - <span class="hljs-number">1</span>);<br>        List&lt;TreeNode&gt; right = generate(i + <span class="hljs-number">1</span>, end);<br>        <span class="hljs-keyword">for</span>(TreeNode L : left)&#123;<br>            <span class="hljs-keyword">for</span>(TreeNode R : right)&#123;<br>                TreeNode root = <span class="hljs-keyword">new</span> TreeNode(i);<br>                root.left = L;<br>                root.right = R;<br>                res.add(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】23.合并K个升序链表</title>
    <link href="/2021/02/19/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/19/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a>23. 合并K个升序链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p> </p><pre><code>示例 1：输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="方法一（优先队列）"><a href="#方法一（优先队列）" class="headerlink" title="方法一（优先队列）"></a>方法一（优先队列）</h2><p>之前曾用过归并排序的思路解决过合并2个升序链表的问题。这个题我们也可以使用相同的思路，用k个指针分别指向这k个链表的节点，每次都取这k个节点中值最小的一个放到我们的结果链表中去。</p><p>既然我们每次都要在一系列值中找到最小的那个，很自然就会想到用一个最小堆来实现：</p><ul><li>准备一个小根堆，将lists中的所有链表加入到堆中</li><li>每次从小根堆中取出一个链表，将这个链表的头挂到结果链表中去</li><li>将上述链表头节点之后的剩余部分再放入堆中，相当于这个链表的cur指针向后移了一步。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || lists.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    PriorityQueue&lt;ListNode&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v1.val - v2.val);<br>    <span class="hljs-keyword">for</span>(ListNode list : lists)&#123;<br>        <span class="hljs-keyword">if</span>(list != <span class="hljs-keyword">null</span>)<br>            heap.add(list);<br>    &#125;<br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode cur = dummy;<br>    <span class="hljs-keyword">while</span>(!heap.isEmpty())&#123;<br>        cur.next = heap.poll();<br>        cur = cur.next;<br>        <span class="hljs-keyword">if</span>(cur.next != <span class="hljs-keyword">null</span>)<br>            heap.add(cur.next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(Nlogk)</li><li>空间复杂度：O(k)</li></ul><h2 id="方法二（分治法）"><a href="#方法二（分治法）" class="headerlink" title="方法二（分治法）"></a>方法二（分治法）</h2><p>回顾分治法的基本思想为：将难以解决的大问题分解为多个容易解决的小问题，再逐个解决小问题，最终用小问题的解合并即得到了原大问题的解。</p><p>分治法只要考虑以下三点：</p><ul><li>分解：将合并k个链表的原问题，分解为合并lists中左半组链表和右半组链表这两个子问题</li><li>合并：递归解决上述子问题后，我们得到了两个合并后的链表，这时将二者再归并就是答案。这时，问题已经由归并k个链表，转化为了归并两个链表</li><li>递归返回条件：当把子问题分解为最小时，只有一个链表，无需归并，直接返回即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || lists.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//归并lists中索引从start到end间的这些链表</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start == end)<br>        <span class="hljs-keyword">return</span> lists[start];<br>    <span class="hljs-keyword">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;<br>    ListNode list1 = merge(lists, start, mid);<br>    ListNode list2 = merge(lists, mid + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-keyword">return</span> merge2Lists(list1, list2);<br>&#125;<br><span class="hljs-comment">//将问题转化为归并两个链表的问题</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge2Lists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(list1 == <span class="hljs-keyword">null</span> &amp;&amp; list2 == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(list1 == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> list2;<br>    <span class="hljs-keyword">if</span>(list2 == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> list1;<br>    <span class="hljs-keyword">if</span>(list1.val &lt; list2.val)&#123;<br>        list1.next = merge2Lists(list1.next, list2);<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        list2.next = merge2Lists(list2.next, list1);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>时间复杂度：O(Nlogk)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】438.找到字符串中所有字母异位词</title>
    <link href="/2021/02/19/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2021/02/19/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：  </p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p><strong>示例</strong></p><pre><code>示例 1:输入:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。示例 2:输入:s: &quot;abab&quot; p: &quot;ab&quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</code></pre><h2 id="方法（滑动窗口）"><a href="#方法（滑动窗口）" class="headerlink" title="方法（滑动窗口）"></a>方法（滑动窗口）</h2><p>因为s和p中全部都是小写字符，因此我们可以分别用大小为26的桶来记录字符串中出现的字符及其出现的次数</p><ul><li>先将p中的字符全部入桶bucketP。</li><li>用left和right分别记录s中滑动窗口的左右端点，准备一个桶bucketS记录此滑动窗口中的字符及其出现次数</li><li>right不断向右移动，每移动一次都将一个新的字符加入到桶bucketS中。</li><li>当桶bucketS中元素种类或个数比桶bucketP多时，此时right再向右只会让二者差的更多，不可能找到字母异位词。因此这时应该将滑动窗口的左端向右移动，将一些字符踢出桶，直到桶bucketS和桶bucketP中元素相同为止。</li><li>当桶bucketS中元素种类或个数与桶bucketP完全相同时，只需要判断窗口的长度和p是否相同，就可判断是否找到字母异位词</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-comment">//corner case</span><br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; p.length())<br>        <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">int</span>[] bucketP = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.length(); i++)<br>        bucketP[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    <span class="hljs-keyword">int</span>[] bucketS = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-comment">//left和right分别为滑动窗口的左右端点</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">int</span> curR = s.charAt(right) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        bucketS[curR]++;<br>        right++;<br>        <span class="hljs-keyword">while</span>(bucketS[curR] &gt; bucketP[curR])&#123;<br>            <span class="hljs-keyword">int</span> curL = s.charAt(left) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            bucketS[curL]--;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right - left == p.length())<br>            res.add(left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】424.替换后的最长重复字符</title>
    <link href="/2021/02/19/424.%20%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <url>/2021/02/19/424.%20%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a>424. 替换后的最长重复字符</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><pre><code>示例 1：输入：s = &quot;ABAB&quot;, k = 2输出：4解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。示例 2：输入：s = &quot;AABABBA&quot;, k = 1输出：4解释：将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</code></pre><h2 id="方法一（滑动窗口）"><a href="#方法一（滑动窗口）" class="headerlink" title="方法一（滑动窗口）"></a>方法一（滑动窗口）</h2><p>要判断能否将一个子串替换k次以得到一个只包含重复字母的子串，只需要判断该子串中除了出现最多次的那个字符外的其他字符出现的总次数是否大于k即可。大于k则不可，小于k则可。</p><p>用left和right这两个指针分别指向滑动窗口的左端和右端。</p><p>right不断向右移动，每次都在当前窗口后再添加一个新的字符，看看窗口是否还能继续满足要求。</p><ul><li>如果窗口内除出现次数最多的字符外的其他字符出现的总次数大于k了，则该窗口不能满足要求了，left要向右移动。</li><li>否则，该窗口满足要求，用当前窗口的长度更新最大值res</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//用桶来记录当前窗口中的字符以及其出现的次数</span><br>    <span class="hljs-keyword">int</span>[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//left和right分别记录滑动窗口的两端</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;  <span class="hljs-comment">//maxCount记录当前窗口内出现最多的那个字符出现的次数</span><br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-comment">//无论是左端还是右端，只要窗口移动了，就要更新maxCount</span><br>        buckets[s.charAt(right) - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        maxCount = Math.max(maxCount, buckets[s.charAt(right) - <span class="hljs-string">&#x27;A&#x27;</span>]);<br>        <span class="hljs-keyword">while</span>(right - left + <span class="hljs-number">1</span> - maxCount &gt; k)&#123;<br>            buckets[s.charAt(left) - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>            left++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>                maxCount = Math.max(maxCount, buckets[i]);<br>        &#125;<br>        res = Math.max(res, right - left + <span class="hljs-number">1</span>);<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(26n)</li><li>空间复杂度：O(1)</li></ul><h2 id="方法二（改进）"><a href="#方法二（改进）" class="headerlink" title="方法二（改进）"></a>方法二（改进）</h2><p>在方法一中，窗口左端点left每移动一次，就要遍历一次桶以更新maxCount，效率不高。</p><p>因此我们采取如下改进方法：</p><p>对于滑动窗口，只允许两种操作：</p><ul><li>扩展：right右移，left不动</li><li>平移：right和left同时右移</li></ul><p>因为题目让我们求的是长度，而不是具体的子串。因此我们可以用滑动窗口的窗口大小来记录答案。</p><ul><li>右移时，窗口大小加1</li><li>平移时，窗口大小不变</li></ul><p>还是像方法一一样，right不断右移，每次尝试着将一个新的字符加入窗口。如果加入后窗口符合要求，那么扩展窗口。如果加入后窗口不符合要求，那么平移窗口。因为窗口的大小永远不可能减小，所以遍历结束后，当前窗口大小就是符合条件的最大窗口大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        buckets[s.charAt(right) - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        maxCount = Math.max(maxCount, buckets[s.charAt(right) - <span class="hljs-string">&#x27;A&#x27;</span>]);<br>        <span class="hljs-keyword">if</span>(right - left + <span class="hljs-number">1</span> - maxCount &gt; k)&#123;<br>            buckets[s.charAt(left) - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>            left++;<br>        &#125;<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right - left;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】219.存在重复元素II</title>
    <link href="/2021/02/19/219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <url>/2021/02/19/219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    
    <content type="html"><![CDATA[<h1 id="219-存在重复元素II"><a href="#219-存在重复元素II" class="headerlink" title="219.存在重复元素II"></a>219.存在重复元素II</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><pre><code>示例 1:输入: nums = [1,2,3,1], k = 3输出: true示例 2:输入: nums = [1,0,1,1], k = 1输出: true示例 3:输入: nums = [1,2,3,1,2,3], k = 2输出: false</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>维护一个最多包含k个元素的哈希set，让它起到一个滑动窗口的作用</p><p>从头到尾遍历数组：</p><ul><li>如果当前元素存在于set中，则说明在距当前元素k步的范围内存在重复元素，直接返回true</li><li>如果当前元素不在set中，则将其加入set，如果加入后set大小大于k，则移除当前set中最早进来的数字，保证其大小始终不大于k。</li></ul><p>时间复杂度：O(n)<br>空间复杂度：O(K)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(set.contains(nums[i]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            set.add(nums[i]);<br>            <span class="hljs-keyword">if</span>(set.size() &gt; k)<br>                set.remove(nums[i - k]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】209.长度最小的子数组</title>
    <link href="/2021/02/19/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/19/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h1><p><strong>题目：</strong><br>给定一个含有n个正整数的数组和一个正整数s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><p>示例:<br>输入: s = 7, nums = [2,3,1,2,4,3]<br>输出: 2<br>解释: 子数组[4,3]是该条件下的长度最小的连续子数组。</p><p><strong>思路：滑动窗口法</strong><br>当输出或比较的结果在原数据结构中是连续排列的时候，可以使用滑动窗口算法求解。<br>将两个指针比作一个窗口，通过移动指针的位置改变窗口的大小，观察窗口中的元素是否符合题意。</p><p>初始窗口中只有数组开头一个元素。<br>当窗口中的元素小于目标值，右指针向右移，扩大窗口。<br>当窗口中的元素大于目标值，比较当前窗口大小是否为最小值，左指针向右移，缩小窗口。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> minlength = Integer.MAX_VALUE;<br>        <span class="hljs-comment">//left和right分别代表滑动窗口的左右端</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; nums.length)&#123;<br>            sum += nums[right];<br>            right++;<br>            <span class="hljs-comment">//和sum大于目标值s时，left左移，滑动窗口缩小</span><br>            <span class="hljs-keyword">while</span>(sum &gt;= s)&#123;<br>                minlength = Math.min(minlength, right - left );<br>                sum -= nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minlength == Integer.MAX_VALUE? <span class="hljs-number">0</span>:minlength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】3.无重复字符的最长子串</title>
    <link href="/2021/02/19/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/19/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h1><p><strong>题目：</strong><br>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。  </p><p>示例:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><h2 id="思路：滑动窗口法"><a href="#思路：滑动窗口法" class="headerlink" title="思路：滑动窗口法"></a>思路：滑动窗口法</h2><p>想象一个窗口，当abc进入窗口后，无重复字符，目前最长子串长度为3.当后一个a进入后，变成了abca出现了重复字符a。所以要将窗口进行滑动，以满足要求。如何滑动？将队列左边的元素移除即可。一直维持这样的队列，直到找出最长长度。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//哈希表的value值为key值上一次出现过的位置(s中的索引)</span><br>    HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>    <span class="hljs-comment">//max用来储存不含重复字符的最长子串长度</span><br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//left用来储存滑动窗口的左端</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-comment">//如果map中出现过s[i]，则再将s[i]加入时会出现重复字符，因此需要进行窗口滑动，即更新left</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))<br>            <span class="hljs-comment">//将left更新为之前出现过的与s[i]相同的字符的下一个位置，即将那个相同字符滑出窗口</span><br>            <span class="hljs-comment">//例子abba可以说明为何需要和left取最大，当填入第二个a时，left在索引为2处，但第1个a的下一个位置为索引为1处。</span><br>            left = Math.max(left, map.get(s.charAt(i))+ <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//不管s[i]是否出现过，都将它put进哈希表。</span><br>        <span class="hljs-comment">//如果map中曾经有s[i]，这一操作相当于把其value值更新</span><br>        map.put(s.charAt(i),i);<br>        <span class="hljs-comment">//更新最长长度max值</span><br>        max = Math.max(max,i-left+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口法题目汇总"><a href="#滑动窗口法题目汇总" class="headerlink" title="滑动窗口法题目汇总"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/">滑动窗口法题目汇总</a></h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】508.出现次数最多的子树元素和</title>
    <link href="/2021/02/19/508.%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/"/>
    <url>/2021/02/19/508.%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508.出现次数最多的子树元素和"></a>508.出现次数最多的子树元素和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><pre><code>示例 1：输入:    5  /  \ 2   -3返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。示例 2：输入：    5  /  \ 2   -5返回 [2]，只有 2 出现两次，-5 只出现 1 次。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>我们用一个哈希表记录每一个可能的和出现的次数。哈希表的key为所有可能的子树元素和的值，value为该值出现的次数。</p><p>在深度优先遍历树的过程中，不仅要计算各个子树的元素和。还要根据计算出来的和值更新哈希表和最多出现的次数。</p><p>如果当前和值出现的次数为max，那么将其加入列表res。如果当前和值出现的次数大于max，那么需要先将res清空，再将当前的和值加入。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//用一个哈希表记录每个和出现的次数</span><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//max为最多出现的次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//用一个列表记录出现max次的和值</span><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        valSum(root);<br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++)<br>            result[i] = res.get(i);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//求以root为根节点的树的所有元素的和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">valSum</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> L = valSum(root.left);<br>        <span class="hljs-keyword">int</span> R = valSum(root.right);<br>        <span class="hljs-keyword">int</span> sum = root.val + L + R;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(sum))<br>            map.put(sum, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>            map.put(sum, map.get(sum) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(map.get(sum) &gt; max)&#123;<br>            res.clear();<br>            res.add(sum);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(map.get(sum) == max)<br>            res.add(sum);<br>        max = Math.max(max, map.get(sum));<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N) </li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】450.删除二叉搜索树中的节点</title>
    <link href="/2021/02/19/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/02/19/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><pre><code>示例:root = [5,3,6,2,4,null,7]key = 3    5   / \  3   6 / \   \2   4   7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。    5   / \  4   6 /     \2       7另一个正确答案是 [5,2,6,null,4,null,7]。    5   / \  2   6   \   \    4   7</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>若要在一颗根为root的二叉搜索树中删除值为key的节点，一共有三种情况：</p><ol><li><p>key &lt; root.val<br>由于二叉搜索树左子树的节点值都小于根节点，因此值为key的节点一定位于左子树中，我们递归在左子树中删除值为key的节点，并将删除结束后的新的左子树与根节点连接即可。</p></li><li><p>key &gt; root.val<br> 由于二叉搜索树右子树的节点值都大于根节点，因此值为key的节点一定位于右子树中，我们递归在右子树中删除值为key的节点，并将删除结束后的新的右子树与根节点连接即可。</p></li><li><p>key = root.val<br>当key与根节点值相等时，意味着要删除的节点正是根节点root自己。于是可以分两种情况讨论：</p><ul><li>若root的右子树为空，则要想删除root节点，只需让root的左子树替代它的位置即可。</li><li>若root的右子树不为空，由于右子树中最左的节点即为右子树中值最小的节点，root左子树的所有节点都比这个节点小，因此我们只要找到右子树中这个最左的节点，将root的左子树挂到它下面，成为它的左子树即可。如下图所示：将50的左子树挂到50的右子树的最左的节点60下，成为60节点的左子树</li></ul><p><img src="/img/450.%E5%9B%BE1.png"></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//情况一：在root的左子树中删除值为key的节点</span><br>    <span class="hljs-keyword">if</span>(key &lt; root.val)&#123;<br>        TreeNode L = deleteNode(root.left, key);<br>        root.left = L;<br>    &#125;<br>    <span class="hljs-comment">//情况二：在root的右子树中删除值为key的节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; root.val)&#123;<br>        TreeNode R = deleteNode(root.right, key);<br>        root.right = R;<br>    &#125;<br>    <span class="hljs-comment">//情况三：删除root节点自身</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root.left;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//用cur找到root右子树中最左的节点</span><br>            TreeNode cur = root.right;<br>            <span class="hljs-keyword">while</span>(cur.left != <span class="hljs-keyword">null</span>)<br>                cur = cur.left;<br>            <span class="hljs-comment">//将root的左子树挂到这个节点之下</span><br>            cur.left = root.left;<br>            <span class="hljs-keyword">return</span> root.right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】257.二叉树的所有路径</title>
    <link href="/2021/02/19/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/02/19/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><pre><code>示例:输入:    1  /   \ 2     3  \   5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</code></pre><h2 id="方法（深度优先搜索）"><a href="#方法（深度优先搜索）" class="headerlink" title="方法（深度优先搜索）"></a>方法（深度优先搜索）</h2><p>对以root为根节点的树进行深度优先遍历，搜索从root到叶节点的路径：</p><ul><li>如果遍历到了叶子节点，则在当前路径的结尾处添加该节点，并将目前的整条路经加到结果数组中</li><li>如果当前遍历不是叶子节点，则在当前路径的结尾处添加该节点，继续遍历其子节点</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        dfs(root, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//搜索以node为起始的到叶节点的路径</span><br>    <span class="hljs-comment">//cur为到达node前所经历过的路径</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node, String cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        cur += Integer.toString(node.val);<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>)&#123;<br>            res.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            dfs(node.left, cur);<br>            dfs(node.right, cur);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】230.二叉搜索树中第K小的元素</title>
    <link href="/2021/02/19/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/19/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><pre><code>示例 1:输入: root = [3,1,4,null,2], k = 1    3   / \  1   4   \    2输出: 1示例 2:输入: root = [5,3,6,2,4,null,null,1], k = 3      5     / \    3   6   / \  2   4 /1输出: 3</code></pre><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>根据二叉搜索树的中序遍历序列是升序的这一特性，我们可以对树进行中序遍历，得到树中元素的升序序列，最后再返回序列中的第k-1个元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res.get(k - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        res.add(root.val);<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>因为二叉搜索树左子树的元素都小于根节点，右子树的元素都大于根节点。因此：  </p><ul><li>如果k不大于root的左子树的节点个数，那么以root为根的二叉搜索树的第k小元素也就是root左子树的第k小元素</li><li>如果k正好比root的左子树的节点个数大一，那么第k小元素就是根节点本身。</li><li>否则，二叉搜索树的第k小元素存在于右子树中，也即要寻找右子树的第$k - leftNum - 1$小的元素。（注：$leftNum+1$为左子树加根节点的节点个数）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//获取左子树的节点数leftNum</span><br>    <span class="hljs-keyword">int</span> leftNum = number(root.left);<br>    <span class="hljs-keyword">if</span>(leftNum &gt;= k)<br>        <span class="hljs-keyword">return</span> kthSmallest(root.left, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftNum + <span class="hljs-number">1</span> == k)<br>        <span class="hljs-keyword">return</span> root.val;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> kthSmallest(root.right, k - leftNum - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//此函数用于获取以root为根节点的树的节点个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">number</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> number(root.left) + number(root.right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>时间复杂度: $O(nlogn)$</li><li>空间复杂度: $O(n)$</li></ul><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>方法三可看作是对方法一的一个改进，我们在对二叉搜索树进行中序遍历的时候，不再用额外空间来存储树中节点信息。而是用一个变量count来记录节点当前已遍历到的节点个数，当遍历到第k个节点时(count等于k)，返回这个节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        <span class="hljs-keyword">if</span>(++count == k)&#123;<br>            res = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】117.填充每个节点的下一个右侧节点指针 II</title>
    <link href="/2021/02/19/117.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II/"/>
    <url>/2021/02/19/117.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117 填充每个节点的下一个右侧节点指针 II"></a>117 填充每个节点的下一个右侧节点指针 II</h1><p><strong>题目：</strong><br>大体和题目116相同，只是给定的二叉树并不受限制</p><p><strong>思路：</strong><br>递归法  </p><ul><li>如果一个节点root既有左子节点又有右子节点，则左子节点的next指向右子节点，右子节点的next指向NextNoNullChild</li><li>如果一个节点只有左子节点，则左子节点的next指向其NextNoNullChild</li><li>如果一个节点只有右子节点，则右子节点的next指向其NextNoNullChild</li></ul><p>这里注意一定要先构建右子树，再构建左子树，因为寻找父节点的兄弟节点是从左到右遍历的，如果右子树未构建好就遍历，则会出错</p><p>BFS广度优先搜索：<br>116题的BFS解答同样适用于该题</p><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span> &amp;&amp; root.left != <span class="hljs-keyword">null</span>)&#123;<br>            root.left.next = root.right;<br>            root.right.next = NextNoNullChild(root);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>)<br>            root.left.next = NextNoNullChild(root);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)<br>            root.right.next = NextNoNullChild(root);<br><br>        root.right = connect(root.right);<br>        root.left = connect(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">//用while循环，找到和root及其兄弟节点的的下一个不为null的子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">NextNoNullChild</span><span class="hljs-params">(Node root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(root.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(root.next.left != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> root.next.left;<br>            <span class="hljs-keyword">if</span>(root.next.right != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> root.next.right;<br>            root = root.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】116.填充每个节点的下一个右侧节点指针</title>
    <link href="/2021/02/19/116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2021/02/19/116.%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h1><p><strong>题目：</strong><br>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}</p><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>每个 node 左子树的 next , 就是 node 的右子树<br>每个 node 右子树的 next, 就是 node next 的 左子树  </p><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)<br>            root.left.next = root.right;<br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)<br>            root.right.next = root.next != <span class="hljs-keyword">null</span> ? root.next.left : <span class="hljs-keyword">null</span>;<br>        connect(root.left);<br>        connect(root.right);<br>        <span class="hljs-keyword">return</span> root; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS解法"><a href="#BFS解法" class="headerlink" title="BFS解法"></a>BFS解法</h2><p><strong>算法</strong>：    </p><ol><li>创建一个辅助队列 Q，通过以下方式实现层序遍历：          每一步都记录当前队列中全部 元素数量，即对应树中一个层级元素的数量。然后从队列中处理对应数量的元素。完成后，这一层级所有的节点都被访问，队列包含下一层级的 全部 节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!Q.empty())<br>&#123;<br>    size = Q.size()<br>    <span class="hljs-keyword">for</span> i in range <span class="hljs-number">0.</span>.size<br>    &#123;<br>        node = Q.pop()<br>        Q.push(node.left)<br>        Q.push(node.right)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>首先在队列中加入根节点。因为第 0 层级只有一个节点，不需要建立连接，直接进入 while 循环即可</li><li>伪代码中 while 循环迭代的是树的层级，内部的 for 循环迭代的是一个层级上所有的节点。由于可以访问同一层级的所有节点，因此能够建立指针连接。</li><li>for 循环弹出一个节点时，同时把它的孩子节点加入队列。因此队列中每个层级的元素也是顺序存储的。可以通过已有的顺序建立 next 指针。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        Queue&lt;Node&gt; Q = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;(); <br>        Q.add(root);<br>        <span class="hljs-comment">//while迭代树的层级</span><br>        <span class="hljs-keyword">while</span> (Q.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> size = Q.size();<br>            <span class="hljs-comment">//for迭代同一层级上的所有节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Node node = Q.poll();<br><br>                <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) &#123;<br>                    node.next = Q.peek();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    Q.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    Q.add(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】114.二叉树展开为链表</title>
    <link href="/2021/02/19/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/19/114.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114 二叉树展开为链表"></a>114 二叉树展开为链表</h1><p><strong>题目：</strong><br>给定一个二叉树，原地将它展开为一个单链表。</p><pre><code>例如，给定二叉树    1   / \  2   5 / \   \3   4   6将其展开为：1 \  2   \    3     \      4       \        5         \          6</code></pre><p><strong>思路：</strong><br>采用递归的思路来解决问题。递归的特点就在于，无需关注函内部数处理的细节，只需要关注函数的功能以及函数的输入输出即可。<br>对于这道题而言，可以分三步解决问题：</p><ol><li>将左子树展开为链表</li><li>将右子树展开为链表</li><li>将链表形式的右子树放在链表形式的左子数的右边</li></ol><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//先分别将左右子数转化为链表</span><br>        flatten(root.left);<br>        flatten(root.right);<br>        <span class="hljs-comment">//先把root.right保存下来，再将左子树接到root.right上来，之后把root.left置空</span><br>        TreeNode temp = root.right;<br>        root.right = root.left;<br>        root.left = <span class="hljs-keyword">null</span>;<br>        TreeNode cur = root;<br>        <span class="hljs-comment">//将右子数接到当前链表的末尾</span><br>        <span class="hljs-keyword">while</span>(cur.right != <span class="hljs-keyword">null</span>)<br>            cur = cur.right;<br>        cur.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】112.路径总和</title>
    <link href="/2021/02/19/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2021/02/19/112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h1><p><strong>题目：</strong><br>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p><strong>思路：递归</strong><br>遍历整棵树，依次对子节点递归调用hasPathSum函数，调用时参数sum值更新为sum减去当前节点的值。如果当前节点是叶节点，并且sum减到了0。则说明找到了这一路径。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> hasPathSumCore(root,sum);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSumCore</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        sum -= node.val;<br>        <span class="hljs-comment">//如果node为叶子节点，则返回sum是否为0</span><br>        <span class="hljs-keyword">if</span>(node.right == <span class="hljs-keyword">null</span> &amp;&amp; node.left == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> sum == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (hasPathSumCore(node.right,sum) || hasPathSumCore(node.left,sum));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】109.有序链表转换二叉搜索树</title>
    <link href="/2021/02/19/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/02/19/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109.有序链表转换二叉搜索树"></a>109.有序链表转换二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><pre><code>给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：     0    / \  -3   9  /   /-10  5</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>本题和<a href="https://github.com/wyh317/Leetcode/blob/master/%E6%A0%91/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">108.将有序数组转换为二叉搜索树</a>思路完全一样。<br>因为链表是升序排列的，所以只要找到它的中间节点，让它成为树的根节点，再让其前面的元素成为左子树，让其后面的元素成为右子树，再对左右子树分别递归进行相同的操作即可。我们用快慢指针法来寻找中间节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">//递归结束条件 + 边界处理</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(head.val);<br>    <span class="hljs-comment">//快慢指针法找到中间节点,pre指针用于记录slow的前一个节点</span><br>    ListNode slow = head, fast = head, pre = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>        pre = slow;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-comment">//让两个链表从中间断开</span><br>    pre.next = <span class="hljs-keyword">null</span>;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(slow.val);<br>    root.left = sortedListToBST(head);<br>    root.right = sortedListToBST(slow.next);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】108.将有序数组转换为二叉搜索树</title>
    <link href="/2021/02/19/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/02/19/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p><pre><code>示例:给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：     0    / \  -3   9  /   /-10  5</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>由于二叉搜索树的中序遍历是升序的，因此本题相当于根据中序遍历的序列恢复二叉搜索树。因此我们可以拿序列中的任何一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样就可以得到一颗二叉搜索树。又因为题目要求得到一颗平衡搜索二叉树BST，因此我们选择升序序列中的中间元素作为根节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] nums;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.nums = nums;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//dfs函数用数组nums中从索引left到right间的元素构造二叉搜索树，返回构造后树的根节点。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>)<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>        root.left = dfs(left, mid - <span class="hljs-number">1</span>);<br>        root.right = dfs(mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的拓展为<a href="https://github.com/wyh317/Leetcode/blob/master/%E6%A0%91/109.%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">109.有序链表转换二叉搜索树</a>.两道题思路完全一样，只不过链表无法像数组一样通过索引直接找到中间元素，需要用快慢指针法找中间元素。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】106.从中序与后序遍历序列构造二叉树</title>
    <link href="/2021/02/19/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/02/19/106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><pre><code>中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><h2 id="方法（递归）"><a href="#方法（递归）" class="headerlink" title="方法（递归）"></a>方法（递归）</h2><p>二叉树的三种遍历次序依次为：</p><ul><li>前序遍历：根、左、右</li><li>中序遍历：左、根、右</li><li>后序遍历：左、右、根</li></ul><p>一个二叉树的前序、中序、后序遍历序列可以看作由如下部分构成：</p><ul><li><p>前序遍历序列：</p><pre><code>  [根节点, [左子树的前序遍历], [右子树的前序遍历]]</code></pre></li><li><p>中序遍历序列：</p><pre><code>  [[左子树的中序遍历], 根节点, [右子树的中序遍历]]</code></pre></li><li><p>后序遍历序列：</p><pre><code>  [[左子树的后序遍历], [右子树的后序遍历], 根节点]</code></pre></li></ul><p>因此，我们由后序遍历和中序遍历构造二叉树的步骤为：</p><ol><li>在后序遍历序列中得到根节点</li><li>在中序遍历序列中找到根节点的位置，其左边为左子树中序遍历序列，右边为右子树中序遍历序列。</li><li>在后序遍历序列中也找到左右子树对应的后序遍历序列（根据一棵树的中序遍历序列和后序遍历序列的长度相同）</li><li>递归生成左右子树</li><li>将根节点与左右子树连接</li></ol><p>为了降低空间复杂度，我们不对原树的preorder和inorder切分生成新的数组序列，而是采用双指针记下子树的序列在preorder和inorder的索引范围</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] inorder;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] postorder;<br>    <span class="hljs-keyword">static</span> HashMap&lt;Integer, Integer&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.inorder = inorder;<br>        <span class="hljs-keyword">this</span>.postorder = postorder;<br>        <span class="hljs-comment">//用一个哈希表将中序遍历序列的每个元素和其下标对应起来，方便之后在inorder中查找根节点位置索引</span><br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)<br>            map.put(inorder[i], i);<br>        <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>, inorder.length, <span class="hljs-number">0</span>, postorder.length);<br>    &#125;<br>    <span class="hljs-comment">//由中序遍历序列和后序遍历序列构造二叉树</span><br>    <span class="hljs-comment">//后序遍历序列由postorder中索引po_start和po_end间的元素构成</span><br>    <span class="hljs-comment">//中序遍历序列由inorder中索引in_start和in_end间的元素构成</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in_start, <span class="hljs-keyword">int</span> in_end, <span class="hljs-keyword">int</span> po_start, <span class="hljs-keyword">int</span> po_end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(po_start == po_end || in_start == in_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//后序遍历序列的最后一个元素为根节点</span><br>        <span class="hljs-keyword">int</span> root_val = postorder[po_end - <span class="hljs-number">1</span>];<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(root_val);<br>        <span class="hljs-comment">//在中序遍历序列中找到根节点的位置索引</span><br>        <span class="hljs-keyword">int</span> root_index = map.get(root_val);<br>        <span class="hljs-comment">//左子树的后序遍历序列和中序遍历的长度</span><br>        <span class="hljs-keyword">int</span> left_num = root_index - in_start;<br>        TreeNode L = helper(in_start, root_index, po_start, po_start + left_num);<br>        TreeNode R = helper(root_index + <span class="hljs-number">1</span>, in_end, po_start + left_num, po_end - <span class="hljs-number">1</span>);<br>        root.left = L;<br>        root.right = R;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n), n为树中节点的个数</li><li>空间复杂度：O(n), 需要用O(n)存储哈希表，O(h)存储递归时的栈空间（h为树高度 h &lt; n）,因此空间复杂度为O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】105.从前序与中序遍历序列构造二叉树</title>
    <link href="/2021/02/19/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/02/19/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><pre><code>例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：    3   / \  9  20    /  \   15   7</code></pre><h2 id="方法（递归）"><a href="#方法（递归）" class="headerlink" title="方法（递归）"></a>方法（递归）</h2><p>二叉树的三种遍历次序依次为：</p><ul><li>前序遍历：根、左、右</li><li>中序遍历：左、根、右</li><li>后序遍历：左、右、根</li></ul><p>一个二叉树的前序、中序、后序遍历序列可以看作由如下部分构成：</p><ul><li><p>前序遍历序列：</p><pre><code>  [根节点, [左子树的前序遍历], [右子树的前序遍历]]</code></pre></li><li><p>中序遍历序列：</p><pre><code>  [[左子树的中序遍历], 根节点, [右子树的中序遍历]]</code></pre></li><li><p>后序遍历序列：</p><pre><code>  [[左子树的后序遍历], [右子树的后序遍历], 根节点]</code></pre></li></ul><p>因此，我们由前序遍历和中序遍历构造二叉树的步骤为：</p><ol><li>在前序遍历序列中得到根节点</li><li>在中序遍历序列中找到根节点的位置，其左边为左子树中序遍历序列，右边为右子树中序遍历序列。</li><li>在前序遍历序列中也找到左右子树对应的前序遍历序列（根据一棵树的中序遍历序列和前序遍历序列的长度相同）</li><li>递归生成左右子树</li><li>将根节点与左右子树连接</li></ol><p>为了降低空间复杂度，我们不对原树的preorder和inorder切分生成新的数组序列，而是采用双指针记下子树的序列在preorder和inorder的索引范围</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] preorder;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] inorder;<br>    HashMap&lt;Integer, Integer&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.preorder = preorder;<br>        <span class="hljs-keyword">this</span>.inorder = inorder;<br>        <span class="hljs-comment">//用一个哈希表将中序遍历序列的每个元素和其下标对应起来，方便之后在inorder中查找根节点位置索引</span><br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)<br>            map.put(inorder[i], i);<br>        <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>, preorder.length,<span class="hljs-number">0</span>, inorder.length);<br>    &#125;<br><br>    <span class="hljs-comment">//由前序遍历序列和中序遍历序列构造二叉树</span><br>    <span class="hljs-comment">//前序遍历序列由preorder中索引pre_start和pre_end间的元素构成</span><br>    <span class="hljs-comment">//中序遍历序列由inorder中索引in_start和in_end间的元素构成</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre_start, <span class="hljs-keyword">int</span> pre_end, <span class="hljs-keyword">int</span> in_start, <span class="hljs-keyword">int</span> in_end)</span> </span>&#123;<br>        <span class="hljs-comment">//递归结束条件：前序或中序遍历序列为空</span><br>        <span class="hljs-keyword">if</span>(pre_start == pre_end || in_start == in_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> root_val = preorder[pre_start];<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(root_val);<br>        <span class="hljs-keyword">int</span> root_index = map.get(root_val);<br>        <span class="hljs-comment">//左子树的前序遍历序列和中序遍历的长度</span><br>        <span class="hljs-keyword">int</span> left_num = root_index - in_start;<br>        TreeNode L = helper(pre_start + <span class="hljs-number">1</span>, pre_start + <span class="hljs-number">1</span> + left_num, in_start, root_index);<br>        TreeNode R = helper(pre_start + <span class="hljs-number">1</span> + left_num, pre_end, root_index + <span class="hljs-number">1</span>, in_end);<br>        root.left = L;<br>        root.right = R;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n), n为树中节点的个数</li><li>空间复杂度：O(n), 需要用O(n)存储哈希表，O(h)存储递归时的栈空间（h为树高度 h &lt; n）,因此空间复杂度为O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】102.二叉树的层序遍历</title>
    <link href="/2021/02/19/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/02/19/102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p> </p><pre><code>示例：二叉树：[3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回其层次遍历结果：[[3],[9,20],[15,7]]</code></pre><h2 id="方法（广度优先搜索）"><a href="#方法（广度优先搜索）" class="headerlink" title="方法（广度优先搜索）"></a>方法（广度优先搜索）</h2><p>用一个队列结构来实现广度优先搜索。从根节点开始搜索，每次遍历同一层的全部节点，使用一个列表存储该层的节点值。</p><ul><li>时间复杂度：O(n)   需要遍历到树中的每一个节点</li><li>空间复杂度：O(n)   队列的长度不超过n</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            TreeNode node = queue.poll();<br>            level.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)<br>                queue.offer(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)<br>                queue.offer(node.right);<br>        &#125;<br>        res.add(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法（深度优先搜索）"><a href="#方法（深度优先搜索）" class="headerlink" title="方法（深度优先搜索）"></a>方法（深度优先搜索）</h2><p>在每次第一次遍历到一层时，在结果数组res中添加一个新的空数组。在之后的遍历过程中，将节点值加入到该层在res中对应的数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(level == res.size() + <span class="hljs-number">1</span>)<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        res.get(level - <span class="hljs-number">1</span>).add(root.val);<br>        dfs(root.left, level + <span class="hljs-number">1</span>);<br>        dfs(root.right, level + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】96.不同的二叉搜索树</title>
    <link href="/2021/02/19/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/02/19/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h1><p><strong>题目：</strong><br>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><pre><code>示例:输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</code></pre><p><strong>思路：</strong><br>采用动态规划的思路求解<br>设要求的以1到n为节点组成的二叉搜索树的数目为G(n)。分析可知，1到n的任何一个节点都可以作为根节点，令以节点i为根节点的二叉搜索树的数目为f(i)。于是有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">G(n)&#x3D;f(1)+f(2)+f(3)+f(4)+...+f(n)<br></code></pre></td></tr></table></figure><p>两种特殊情况是n为0和n为1的情况，这两种情况对应的结果都为1。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">G(0) &#x3D; G(1) &#x3D; 1<br></code></pre></td></tr></table></figure><p>然而，f(i)也与G函数有关系。f(i)代表的以i节点为根的可以生成的二叉搜索树的个数，等于其左子数个数和右子树个数的乘积。左子数的节点个数为i-1，右子树的节点个数为n-i。而且， G(n)和序列的内容无关，只和序列的长度有关，因此有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">f(i)&#x3D;G(i−1)∗G(n−i)<br></code></pre></td></tr></table></figure><p>综合以上公式，可以得到<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin">卡特兰数</a>公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">G(n)&#x3D;G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)<br></code></pre></td></tr></table></figure><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>                G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];<br>        <span class="hljs-keyword">return</span> G[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>G(n)语句的执行次数为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">\sum_&#123;i&#x3D;2&#125;^&#123;n&#125; i&#x3D;\frac&#123;(2+n)(n-1)&#125;&#123;2&#125; <br></code></pre></td></tr></table></figure><p>因此时间复杂度为O(n^2)<br>空间复杂度为O(n)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】493.翻转对</title>
    <link href="/2021/02/19/493.%20%E7%BF%BB%E8%BD%AC%E5%AF%B9/"/>
    <url>/2021/02/19/493.%20%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="493-翻转对"><a href="#493-翻转对" class="headerlink" title="493. 翻转对"></a>493. 翻转对</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p><p>你需要返回给定数组中的重要翻转对的数量。</p><pre><code>示例 1:输入: [1,3,2,3,1]输出: 2示例 2:输入: [2,4,3,5,1]输出: 3</code></pre><h2 id="方法（归并排序）"><a href="#方法（归并排序）" class="headerlink" title="方法（归并排序）"></a>方法（归并排序）</h2><p>在一个数组中寻找元素对这样的情况都可以考虑归并排序的思路。</p><p>如果我们已经将数组的左右两部分nums[L……mid]、nums[mid+1……R]排好序。则对于右半部分的位置j，如果在左边有一个位置i满足nums[i] &gt; 2*nums[j],那么从i到mid中的所有位置都可以和j组成翻转对（因为左半部分有序，位置i右边的元素肯定大于位置i处的元素）。</p><p>当找完了j位置的所有翻转对之后，接下来找j+1位置的翻转对。由于nums[j+1]大于nums[j]，因此i不用回退，一直向右移动判断即可。知道找出右半部分所有位置对应的翻转对数量。</p><p>总结一下，所有的翻转对由以下三部分构成：</p><ol><li>i和j都在nums的左半部分</li><li>i和j都在nums的右半部分</li><li>i在nums的左半部分，j在nums的右半部分。</li></ol><p>上面我们讨论的是第三部分，第一部分和第二部分的翻转对递归求得即可。</p><p>也就是说我们在归并排序的同时，在merge操作的过程中顺带统计出了翻转对的数目。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(right == left)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//数组左半段内部产生的翻转对</span><br>    <span class="hljs-keyword">int</span> count1 = mergeSort(nums, left, mid);<br>    <span class="hljs-comment">//数组右半段内部产生的翻转对</span><br>    <span class="hljs-keyword">int</span> count2 = mergeSort(nums, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-comment">//翻转对的两端i和j分别在左半段和右半段时，产生的翻转对。</span><br>    <span class="hljs-keyword">int</span> count3 = merge(nums, left, mid, right);<br>    <span class="hljs-keyword">return</span> count1 + count2 + count3;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> curL = left;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= right; i++)&#123;<br>        <span class="hljs-keyword">while</span>(curL &lt;= mid &amp;&amp; (<span class="hljs-keyword">long</span>)nums[curL] &lt;= (<span class="hljs-keyword">long</span>)<span class="hljs-number">2</span> * nums[i])<br>            curL++;<br>        res += mid - curL + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> L = left;<br>    <span class="hljs-keyword">int</span> R = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(L &lt;= mid &amp;&amp; R &lt;= right)&#123;<br>        help[index++] = nums[L] &lt; nums[R] ? nums[L++] : nums[R++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(L &lt;= mid)&#123;<br>        help[index++] = nums[L++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(R &lt;= right)&#123;<br>        help[index++] = nums[R++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; help.length; i++)&#123;<br>        nums[i + left] = help[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】384.打乱数组</title>
    <link href="/2021/02/19/384.%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/19/384.%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384 打乱数组"></a>384 打乱数组</h1><p><strong>题目：</strong><br>打乱一个没有重复元素的数组。</p><p> </p><p>示例:</p><p>// 以数字集合 1, 2 和 3 初始化数组。<br>int[] nums = {1,2,3};<br>Solution solution = new Solution(nums);</p><p>// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。<br>solution.shuffle();</p><p>// 重设数组到它的初始状态[1,2,3]。<br>solution.reset();</p><p>// 随机返回数组[1,2,3]打乱后的结果。<br>solution.shuffle();</p><p><strong>思路：</strong><br>我们可以用一个简单的技巧来降低暴力算法的时间复杂度和空间复杂度，那就是让数组中的元素互相交换，这样就可以避免掉每次迭代中用于修改列表的时间了。</p><p>算法：<br>Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。</p><p><strong>代码:</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] original;<br>    Random rand = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-comment">//将原始数组赋给array，并将原始数组拷贝一份保存至original</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.array = nums;<br>        <span class="hljs-keyword">this</span>.original = nums.clone();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Resets the array to its original configuration and return it. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reset() &#123;<br>        <span class="hljs-keyword">return</span> original;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns a random shuffling of the array. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] shuffle() &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; array.length; i++)<br>            <span class="hljs-comment">//生成一个范围在当前下标到数组末尾元素下标之间的随机整数</span><br>            <span class="hljs-comment">//并将当前元素和随机选出的下标所指的元素互相交换</span><br>            swapAt(i, randRange(i ,array.length));<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-comment">//此函数实现交换array数组的i处和j处的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swapAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i , <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = array[i];<br>        array[i] = array[j];<br>        array[j] = temp;<br>    &#125;<br>    <span class="hljs-comment">//生成一个范围在min和max之间的随机整数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> rand.nextInt(max - min) + min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度 ： O(n)<br>Fisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。<br>空间复杂度： O(n)<br>因为要实现 重置 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】349.两个数组的交集</title>
    <link href="/2021/02/19/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <url>/2021/02/19/349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h1><p><strong>题目：</strong><br>给定两个数组，编写一个函数来计算它们的交集。  </p><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2]</p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [9,4]</p><p><strong>思路：</strong><br>由于检查一个元素是否在set中的时间复杂度为O(1),而且set中不包含重复元素。因此考虑用Hashset数据结构来解决。<br>准备两个set，将nums1中元素加进set1中，将nums2中元素加进set2中。遍历set1中的元素，若其也在set2中，则将此元素加入到结果数组中。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>    <span class="hljs-keyword">if</span>(nums1 == <span class="hljs-keyword">null</span> || nums2 == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    Set&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nums: nums1)<br>        set1.add(nums);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nums:nums2)<br>        set2.add(nums);<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:set1)&#123;<br>        <span class="hljs-keyword">if</span>(set2.contains(num))<br>            list.add(num);<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size();i++)<br>        res[i] = list.get(i);  <br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>list数据结构在定义时不需要声明大小。上述方法先将结果都加入到list中，再建立一个和list大小相同的数组，将list中的元素都加入到这个数组中，并返回。<br>注：list的添加操作为add，提取操作为get</p><p>也可以不用list，直接用数组来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Math.max(set1.size(),set2.size())];<br><span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : set1)&#123;<br>    <span class="hljs-keyword">if</span> (set2.contains(num)) <br>        res[idx++] = num;<br><span class="hljs-keyword">return</span> Arrays.copyOf(res, idx);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】268.缺失数字</title>
    <link href="/2021/02/19/268.%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <url>/2021/02/19/268.%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268 缺失数字"></a>268 缺失数字</h1><p><strong>题目：</strong><br>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p>示例 1:<br>输入: [3,0,1]<br>输出: 2  </p><p>示例 2:<br>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p><h2 id="方法一：排序法"><a href="#方法一：排序法" class="headerlink" title="方法一：排序法"></a>方法一：排序法</h2><p><strong>思路：</strong> 先将数组排序，然后判断排序后的数组数字是否挨着，即若两个相邻数字之间相差2，则这两个数字间的那个数字即为缺失数字  </p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-comment">// 判断 n 是否出现在末位</span><br>    <span class="hljs-keyword">if</span> (nums[nums.length-<span class="hljs-number">1</span>] != nums.length) &#123;<br>        <span class="hljs-keyword">return</span> nums.length;<br>    &#125;<br>    <span class="hljs-comment">// 判断 0 是否出现在首位</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 此时缺失的数字一定在 (0, n) 中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> expectedNum = nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[i] != expectedNum) &#123;<br>            <span class="hljs-keyword">return</span> expectedNum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 未缺失任何数字（保证函数有返回值）</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong><br>时间复杂度：O(nlogn),排序的复杂度<br>空间复杂度：O(1),实际上跟采用的排序算法有关</p><h2 id="方法二：哈希法"><a href="#方法二：哈希法" class="headerlink" title="方法二：哈希法"></a>方法二：哈希法</h2><p><strong>思路：</strong><br>先将nums数组中所有数放进哈希表，然后寻找从0到n的哪一个数不在哈希表中，返回这个数字  </p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//新建一个HashSet,将nums中所有元素加入HashSet</span><br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums)<br>        set.add(num);<br>    <span class="hljs-comment">//判断从0到nums.length范围内数是否在set中，如果有数不在，返回这个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= nums.length;i++)<br>        <span class="hljs-keyword">if</span>(!set.contains(i))<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(n)。HashSet的插入和查询操作都是O(1),对每一个数都进行这个操作，总时间复杂度为O(n)<br><strong>空间复杂度</strong>：O(n)。需要HashSet存储这些数</p><h2 id="方法三：数学方法"><a href="#方法三：数学方法" class="headerlink" title="方法三：数学方法"></a>方法三：数学方法</h2><p><strong>思路：</strong><br>用高斯求和公式求出从1到n的和，即：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">\sum^&#123;n&#125;_&#123;i &#x3D; 0&#125;\frac&#123;n(n-1)&#125;&#123;2&#125;<br></code></pre></td></tr></table></figure><p>然后再将nums中的元素求和，二者相减即为缺失的元素  </p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> expectedSum = nums.length*(nums.length + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) <br>        sum += num;<br>    <span class="hljs-keyword">return</span> expectedSum - sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong><br>高斯求和的复杂度为O(1),数组元素求和的复杂度为O(n)。总时间复杂度为O(n)<br><strong>空间复杂度:</strong> O(1)</p><h2 id="方法四：位运算"><a href="#方法四：位运算" class="headerlink" title="方法四：位运算"></a>方法四：位运算</h2><p><strong>思路：</strong><br>如果数组中没有丢失数字的话，比如[0,1,2]。其中每个数字0，1，2作为数组索引中出现一次，作为值中又出现一次，总共出现两次</p><p>一旦丢失了数字，比如[0,1,3]。0，1这两个数字出现两次（作为索引一次，作为值一次），而3这个数字只作为值出现一次。</p><p>而我们知道，一个数字自己异或自己得到的结果为0。因此如果我们异或数组nums的所有索引和所有值。最终0，1会自己异或自己进而为0。最终异或结果其实是3和2的异或值。其中，3为数组nums的长度，2为缺失的数字</p><p>而数组nums的长度我们是知道的，上述得到的结果再异或一下它，得到的2即为丢失的数字</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)<br>        res = res ^ i ^ nums[i];<br>    <span class="hljs-keyword">return</span> res ^ nums.length;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度:O(N)</li><li>时间复杂度:O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】327.区间和的个数</title>
    <link href="/2021/02/19/327.%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/02/19/327.%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327 区间和的个数"></a>327 区间和的个数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。<br>区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p><pre><code>示例:输入: nums = [-2,5,-1], lower = -2, upper = 2,输出: 3 解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。</code></pre><p>即求满足累加和在lower和upper之间的子数组的个数</p><h2 id="方法1（前缀和）"><a href="#方法1（前缀和）" class="headerlink" title="方法1（前缀和）"></a>方法1（前缀和）</h2><p>首先生成前缀和数组preSum，其中preSum[i]表示nums中i位置之前所有元素之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[nums.length + <span class="hljs-number">1</span>];<br>preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.length; i++)&#123;<br>    preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，子数组nums[i….j-1]的累加和可以由前缀和数组快速地得到，即preSum[j] - preSum[i]。我们可以遍历出所有可能的子数组，再判断其累加和是否在lower和upper之间即可，但这种方法的时间复杂度为O(n^2)</p><h2 id="方法2（前缀和-归并排序）"><a href="#方法2（前缀和-归并排序）" class="headerlink" title="方法2（前缀和+归并排序）"></a>方法2（前缀和+归并排序）</h2><p>我们得到了前缀和数组preSum后，如果preSum[j] - preSum[i]大于lower小于upper，那么就说明nums[i….j-1]的累加和大于lower小于upper。</p><p>如果考虑把前缀和数组分为两段，考虑前一段和后一段都有序、两段之间无序的情况。如果我们先固定前一段的一个元素i，假设后一段的索引为j，我们如何得到一个j的取值区间，让区间内preSum[j] - preSum[i]都大于lower小于upper呢？</p><ul><li>先定义两个变量L和R，分别代表这个区间的左右边界。并将L和R都初始化指向后一段的第一个元素</li><li>如果这时preSum[j] - preSum[i]还不大于lower，则说明还没找到这样的区间，区间的左边界也就不在此，L向右移。直到遇到preSum[j] - preSum[i]大于lower的j位置，说明我们已经进入了这个区间，此时的L即为区间的左边界。</li><li>当前preSum[L] - preSum[i]大于lower，又因为后半段有序，因此L位置之后的所有j都满足preSum[j] - preSum[i]大于lower</li><li>接下来需要寻找满足preSum[j] - preSum[i]小于upper的j的右边界，步骤同上，我们用R记录下来这个右边界。至此为止，L和R间的所有j位置都满足preSum[j] - preSum[i]大于lower小于upper。</li></ul><p>因此我们知道，以i位置开头的，满足累加和大于lower小于upper的子数组一共有R-L个。而又因为左半段有序，因此preSum[i+1]大于preSum[i],若要寻找以i+1开头的子数组，则之前的L和R必然只能向右移动。同理，我们可以找到以左半段每个元素开头的，满足累加和大于lower小于upper的子数组个数。加起来就是当i在左半段、j在右半段的情况下，满足preSum[j] - preSum[i]大于lower小于upper的组合个数。</p><p>而结果需要包含三种情况：</p><ul><li>i和j都在左半段</li><li>i和j都在右半段</li><li>i在左半段、j在右半段</li></ul><p>我们刚才所求的是第三种，第一种和第二种情况我们可以将左半段再分两段，右半段再分两段，递归地求得。（归并排序的思想）</p><p>时间复杂度和归并排序相同，为O(nlogn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lower;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> upper;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.lower = lower;<br>        <span class="hljs-keyword">this</span>.upper = upper;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//求前缀和数组</span><br>        <span class="hljs-keyword">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[nums.length + <span class="hljs-number">1</span>];<br>        preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.length; i++)&#123;<br>            preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> mergeSort(preSum, <span class="hljs-number">0</span>, preSum.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] preSum, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//满足累加和在lower和upper之间的子数组的个数分为三部分：</span><br>        <span class="hljs-comment">//左侧自己merge时找到的子数组个数（i、j都在左侧）</span><br>        <span class="hljs-comment">//右侧自己merge时找到的子数组个数（i、j都在右侧）</span><br>        <span class="hljs-comment">//左侧和右侧merge时找到的子数组个数（i在左侧、j在右侧）</span><br>        <span class="hljs-keyword">return</span> mergeSort(preSum, left, mid) + mergeSort(preSum, mid + <span class="hljs-number">1</span>, right) + merge(preSum, left, mid, right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] preSum, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 统计i在左半段、j在右半段的情况下满足条件的子数组个数</span><br>        <span class="hljs-comment">// 左半段为[left, mid]，右半段为[mid + 1, right]</span><br>        <span class="hljs-comment">// j的左右边界分别为L和R</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">int</span> L = mid + <span class="hljs-number">1</span>, R = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            <span class="hljs-keyword">while</span> (L &lt;= right &amp;&amp; preSum[L] - preSum[i] &lt; lower) <br>                L++;<br>            <span class="hljs-keyword">while</span> (R &lt;= right &amp;&amp; preSum[R] - preSum[i] &lt;= upper) <br>                R++;<br>            res += R - L; <br>            i++;<br>        &#125;<br><br>        <span class="hljs-comment">//进行归并排序的标准merge操作</span><br>        <span class="hljs-keyword">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> p1 = left, p2 = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;<br>            help[idx++] = (preSum[p1] &lt;= preSum[p2]) ? (<span class="hljs-keyword">int</span>) preSum[p1++] : (<span class="hljs-keyword">int</span>) preSum[p2++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p1 &lt;= mid) &#123;<br>            help[idx++] = (<span class="hljs-keyword">int</span>) preSum[p1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p2 &lt;= right) &#123;<br>            help[idx++] = (<span class="hljs-keyword">int</span>) preSum[p2++];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length; j++) &#123;<br>            preSum[left + j] = help[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】167.两数之和 II - 输入有序数组</title>
    <link href="/2021/02/19/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/19/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h1><p><strong>题目：</strong><br>给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1必须小于index2。</p><p>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p><strong>思路：双指针法</strong><br>定义两个指针left和right，初始化时分别指向数组的两端<br>如果left和right对应的值加起来等于target，那么可直接返回。因为数组是排序好的，如果和小于target，也即希望和大一些，所以将left右移一位。如果和大于target，也即希望和小一些，所以将right左移一位。如此进行循环直到找到相等的时候，若找不到则返回null</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span>(numbers == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = numbers.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] == target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] &lt; target)<br>            left++;<br>        <span class="hljs-keyword">else</span><br>            right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】121.买卖股票的最佳时机</title>
    <link href="/2021/02/19/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2021/02/19/121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h1><p><strong>题目：</strong><br>(只能进行一次交易)<br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。</p><p> </p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。  </p><p>示例 2:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p><strong>思路：</strong><br>用一个变量记录最低的股票价格，在遍历的过程中更新它。<br>  最大的利润，一定为，某天的股票价格与之前出现过的最低股票价格之差。遍历一次数组即可得到结果。时间复杂度O(n)<br>  即：我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><p><strong>代码:</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> min_price = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> max_profit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;<br>        min_price = Math.min(min_price, prices[i]);<br>        max_profit = Math.max(prices[i] - min_price,max_profit);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_profit;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】59.螺旋矩阵 II</title>
    <link href="/2021/02/19/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <url>/2021/02/19/59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
    
    <content type="html"><![CDATA[<h1 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59.螺旋矩阵 II"></a>59.螺旋矩阵 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><pre><code>示例:输入: 3输出:[    [ 1, 2, 3 ],    [ 8, 9, 4 ],    [ 7, 6, 5 ]]</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>定义四个索引top、bottom、left、right,分别代表长方形上下左右四条边的索引。</p><p>按照从左到右、从上到下、从右到左、从下到上的顺序将数值填入数组，每次填入后更新边界（比如说从左到右填入完之后，更新top为top+1）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>, bottom = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(count &lt;= n * n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++)&#123;<br>            res[top][i] = count++;<br>        &#125;<br>        top++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = top; i &lt;= bottom; i++)&#123;<br>            res[i][right] = count++;<br>        &#125;<br>        right--;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = right; i &gt;= left; i--)&#123;<br>            res[bottom][i] = count++;<br>        &#125;<br>        bottom--;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = bottom; i &gt;= top; i--)&#123;<br>            res[i][left] = count++;<br>        &#125;<br>        left++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】73.矩阵置零</title>
    <link href="/2021/02/19/73.%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <url>/2021/02/19/73.%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73.矩阵置零"></a>73.矩阵置零</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><pre><code>示例 1:输入: [  [1,1,1],  [1,0,1],  [1,1,1]]输出: [  [1,0,1],  [0,0,0],  [1,0,1]]</code></pre><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>用两个set分别记录需要置0的行和需要置0的列。第一次遍历矩阵时，若发现一个元素为0，则将其行和列值分别加入到两个set中。第二次遍历矩阵时，将行set中的行全部置0，将列set中的列全部置0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>    Set&lt;Integer&gt; row = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    Set&lt;Integer&gt; col = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                row.add(i);<br>                col.add(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : row)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            matrix[i][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j : col)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            matrix[i][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m * n)</li><li>空间复杂度：O(m + n)   最坏情况是矩阵中全部元素为0的情况，这时两个set的大小分别为m和n。</li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>思路：不用额外空间，让首行和首列记录某列和某行是否有0</p><p>算法步骤：</p><ol><li>首先用两个布尔类型变量firstRow和firstCol分别记录矩阵的首行和首列中是否有0</li><li>遍历除首行和首列外的所有元素，若元素matrix[i][j]为0，则将它对应的首行和首列中的元素matrix[i][0]和matrix[0][j]置为0，意为此行和列后续需要被置0（由于修改后首行和首列是否有0的信息会被破坏掉，因此需要有之前的步骤一）</li><li>遍历首行和首列，若发现首行中有元素为0，则将此元素所处的列全部置0，若发现首列中有元素为0，则将此元素所处的行全部置0。</li><li>根据步骤一的布尔类型变量firstRow和firstCol来判断首行和首列是否需要被置0。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">boolean</span> firstRow = <span class="hljs-keyword">false</span>, firstCol = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//步骤一</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>            firstCol = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)<br>            firstRow = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//步骤二</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//步骤三</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//步骤四</span><br>    <span class="hljs-keyword">if</span>(firstRow)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(firstCol)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m * n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】57.插入区间</title>
    <link href="/2021/02/19/57.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/02/19/57.%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57.插入区间"></a>57.插入区间</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p> </p><pre><code>示例 1：输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]]示例 2：输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>本题和第56题类似。但注意本题所给的区间已经按起始端点升序排序。因此我们仍然遍历区间，按如下步骤构建结果集：</p><ul><li>先将完全在新区间左边的区间（右边界都小于新区间左边界的区间）加入结果集</li><li>当遇到一个区间，这个区间的右边界大于等于新区间的左边界，并且这个区间的左边界小于等于新区间的右边界时，则说明需要将其合并，我们将合并后的区间作为新的要插入的区间，继续进入循环。</li><li>当需要合并的区间都合并完全后，将要插入的区间插入</li><li>最后将完全在新区间右边的区间（左边界都大于新区间右边界的区间）加入结果集</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] insert(<span class="hljs-keyword">int</span>[][] intervals, <span class="hljs-keyword">int</span>[] newInterval) &#123;<br>    <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;newInterval&#125;;<br>    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[intervals.length + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> res_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> num_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num_index &lt; intervals.length &amp;&amp; intervals[num_index][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>])<br>        res[res_index++] = intervals[num_index++];<br>    <span class="hljs-keyword">while</span>(num_index &lt; intervals.length &amp;&amp; intervals[num_index][<span class="hljs-number">1</span>] &gt;= newInterval[<span class="hljs-number">0</span>] &amp;&amp; intervals[num_index][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>])&#123;<br>        newInterval[<span class="hljs-number">0</span>] = Math.min(intervals[num_index][<span class="hljs-number">0</span>], newInterval[<span class="hljs-number">0</span>]);<br>        newInterval[<span class="hljs-number">1</span>] = Math.max(intervals[num_index][<span class="hljs-number">1</span>], newInterval[<span class="hljs-number">1</span>]);<br>        num_index++;<br>    &#125;<br>    res[res_index++] = newInterval;<br>    <span class="hljs-keyword">while</span>(num_index &lt; intervals.length &amp;&amp; intervals[num_index][<span class="hljs-number">0</span>] &gt; newInterval[<span class="hljs-number">1</span>])<br>        res[res_index++] = intervals[num_index++];<br>    <span class="hljs-keyword">return</span> Arrays.copyOf(res, res_index);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】56.合并区间</title>
    <link href="/2021/02/19/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/02/19/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h1><p><strong>题目：</strong><br>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].  </p><p>示例 2:<br>输入: [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p><strong>思路：</strong><br>先将数组intervals按照第一个元素的大小从小到大排序。之后遍历数组intervas中的每一个区间。</p><ul><li>如果该区间的左端点大于res中最后一个区间的右端点，则不重合、不需要合并，直接将这个区间加入到res的末尾。</li><li>否则，需要合并，即用该区间的右端点更新res中最后一个区间的右端点，取二者的最大值。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>    <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> intervals;<br>    <span class="hljs-comment">//初始化结果数组，大小为intervals的长度</span><br>    <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[intervals.length][<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//将数组intervals按照第一个元素的大小进行升序排序</span><br>    Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">//先将第一个区间加入结果集</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    res[index++] = intervals[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//遍历数组中的每一个区间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; res[index - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>            res[index++] = intervals[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res[index - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = Math.max(res[index - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//由于res初始化时长度为intervals.length</span><br>    <span class="hljs-comment">//因此最后只需要返回它的前index+1个元素的拷贝</span><br>    <span class="hljs-keyword">return</span> Arrays.copyOf(res, index);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】55.跳跃游戏</title>
    <link href="/2021/02/19/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/02/19/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h1><p><strong>题目：</strong><br>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><p><strong>思路：</strong><br>维护一个最远距离(数组位置的索引)，最开始初始化最远距离为0，然后遍历数组，如果以当前位置开始能跳到的位置大于最远位置，即数组当前位置值+当前位置索引&gt;最远位置，则更新最远位置。最后判断这个最远位置和数组长度的大小即可。  </p><p><strong>简单来说</strong>，把每一个能够起跳的地方都跳一次，不断更新能跳到的最远距离，看能不能跳到最后</p><p><strong>代码:</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> longest_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &gt; longest_index)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//更新最长距离</span><br>        longest_index = Math.max(longest_index, i + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest_index &gt;= nums.length - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】31.下一个排列</title>
    <link href="/2021/02/19/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2021/02/19/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a>31.下一个排列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><pre><code>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>当给定排列已经是最大排列时，这种情况单独考虑，只需反转数组即可。</p><p>否则，下一个排列肯定比当前排列要大，而且要尽可能让变大的幅度很小。</p><p>步骤如下：</p><ol><li>从后向前遍历数组，<strong>找到第一个升序位置对</strong> (index,index+1)，满足 a[index] &lt; a[index+1]。在index之后的所有位置i，都符合降序。意味着nums[index…]为以index开头的最大排列。既然我们要找一个更大的排列，意味着不能再以index开头，我们要在index位置后面找到一个最小比它大的数代替它。</li><li>于是我们<strong>在index位置右边从后向前寻找第一个比nums[index]大的元素位置j</strong>。因为nums[index+1….]为降序排列，因此第一个出现的比nums[index]大的元素就是最小比nums[index]大的元素。</li><li>之前nums[index…]为以nums[index]开头的最大排列，现在我们要让nums[index…]变为以nums[j]开头的最小排列，于是<strong>将index位置和j位置交换</strong>，即让一个最小的比nums[index]大的元素nums[j]代替它。</li><li>再<strong>反转nums[index+1…..]，让这段区间由降序变成升序</strong>。此刻index位置右边为以nums[j]元素开头的最小排列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = nums.length - <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//1.寻找第一个升序位置对</span><br>    <span class="hljs-keyword">while</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index] &gt;= nums[index + <span class="hljs-number">1</span>])<br>        index--;<br>    <span class="hljs-comment">//如果没找到一个升序位置对，则整个数组为降序，即最大排列，这时将其反转得到最小排列</span><br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)<br>        reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//否则，(index,index+1)为找到的第一个升序位置对</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//2.在index右侧寻找最小的比nums[index]大的位置j</span><br>        <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[index] &gt;= nums[j]) <br>            j--;<br>        <span class="hljs-comment">//3.将位置i和位置index上的元素交换</span><br>        swap(nums, index, j);<br>        <span class="hljs-comment">//4.反转index右边，使得其由降序变为升序</span><br>        reverse(nums, index + <span class="hljs-number">1</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[a];<br>    nums[a] = nums[b];<br>    nums[b] = temp;<br>&#125;<br><span class="hljs-comment">//将数组arr逆序</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(end - start &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> left = start;<br>    <span class="hljs-keyword">int</span> right = end;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        swap(nums, left++, right--);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】18.四数之和</title>
    <link href="/2021/02/19/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/02/19/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><pre><code>示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[    [-1,  0, 0, 1],    [-2, -1, 1, 2],    [-2,  0, 0, 2]]</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>思路类似<a href="https://github.com/wyh317/Leetcode/blob/master/%E6%95%B0%E7%BB%84/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">15.三数之和</a></p><ul><li>第一层循环固定第一个数，然后去遍历其他三个数</li><li>第二层循环固定第二个数，然后去遍历最后两个数</li><li>通过双指针法找出最后两个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br>    <span class="hljs-keyword">if</span>(nums==<span class="hljs-keyword">null</span>||nums.length&lt;<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    Arrays.sort(nums);<br>    <span class="hljs-comment">//定义4个指针i，j，L，R</span><br>    <span class="hljs-comment">//i从0开始遍历，用于固定第一个数。j从i+1开始遍历，用于固定第二个数。</span><br>    <span class="hljs-comment">//L和R作为双指针，L指向j+1，R指向数组最右端，用于找出最后两个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length-<span class="hljs-number">3</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//计算当前前四个元素的最小值，因为已经排好序，如果最小值比目标值大，说明不会找到符合条件的四个数</span><br>        <span class="hljs-keyword">int</span> min1 = nums[i] + nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] + nums[i+<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">if</span>(min1 &gt; target)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//计算当前最后四个元素的最大值，因为已经排好序，如果最大值比目标值小，说明以目前i的位置不会找到符合条件的四个数，忽略</span><br>        <span class="hljs-keyword">int</span> max1 = nums[i] + nums[nums.length-<span class="hljs-number">1</span>] + nums[nums.length-<span class="hljs-number">2</span>] + nums[nums.length-<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">if</span>(max1 &lt; target)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//第二重循环用和第一重循环类似的逻辑固定第二个数的同时，用双指针去找最后两个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length-<span class="hljs-number">2</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//定义双指针</span><br>            <span class="hljs-keyword">int</span> L = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> R = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> min = nums[i] + nums[j] + nums[L] + nums[L+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(min &gt; target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> max = nums[i] + nums[j] + nums[R] + nums[R-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(max &lt; target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//双指针法找剩下的两个数</span><br>            <span class="hljs-keyword">while</span> (L &lt; R)&#123;<br>                <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[L] + nums[R];<br>                <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                    res.add(Arrays.asList(nums[i], nums[j], nums[L], nums[R]));<br>                    <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; nums[L] == nums[L+<span class="hljs-number">1</span>])&#123;<br>                        L++;<br>                    &#125;<br>                    <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; j &lt; R &amp;&amp; nums[R]==nums[R-<span class="hljs-number">1</span>])&#123;<br>                        R--;<br>                    &#125;<br>                    L++;<br>                    R--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)<br>                    L++;<br>                <span class="hljs-keyword">else</span><br>                    R--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】16.最接近的三数之和</title>
    <link href="/2021/02/19/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/02/19/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>示例：</p><pre><code>输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>本题与<a href="https://github.com/wyh317/Leetcode/blob/master/%E6%95%B0%E7%BB%84/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">15.三数之和</a> 非常相似。</p><p>可以使用暴力方法计算出数组中任意三个数的和，最后取离target最近的和即可。但这种方法的时间复杂度为$O(n^3)$。</p><p>我们采用和<a href="https://github.com/wyh317/Leetcode/blob/master/%E6%95%B0%E7%BB%84/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">15.三数之和</a>相同的思路，先固定住第一个数，再通过双指针法找后两个数。</p><p>具体算法流程如下：</p><ul><li>先对数组排序，时间复杂度为O(nlogn)</li><li>从头到尾遍历数组，当遍历到数组中元素nums[i]时，用双指针L和R指向在nums[i]后面的数组两端，即L = i+1, R = nums.length - 1</li><li>如果 nums[i] == nums[i-1]，则说明该数字重复，重复计算没有意义，所以应该跳过</li><li>计算三个指针所指元素的和sum,判断sum与目标target的距离，如果二者距离更近则更新结果res。</li><li>双指针移动：因为数组有序，因此如果sum &lt; target，则L右移，如果sum &gt; target，则R左移。否则sum=target，直接返回target。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minDif = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[nums.length - <span class="hljs-number">1</span>];<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> L = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> R = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L &lt; R)&#123;<br>            <span class="hljs-keyword">int</span> sum = nums[i] + nums[L] + nums[R];<br>            <span class="hljs-keyword">if</span>(Math.abs(target - sum) &lt; Math.abs(target - res))<br>                res = sum;<br>            <span class="hljs-keyword">if</span>(sum &lt; target)<br>                L++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)<br>                R--;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> target;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)  （数组中每一个元素都对应着一个双指针操作）<br>空间复杂度：O(1)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】1.两数之和</title>
    <link href="/2021/02/19/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/02/19/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><pre><code>示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h2 id="方法1（暴力法）"><a href="#方法1（暴力法）" class="headerlink" title="方法1（暴力法）"></a>方法1（暴力法）</h2><p>从头到尾遍历数组。对于每遍历到的一个元素num，在剩下的数组中查找是否存在target-num。如果存在则返回，否则继续遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h2 id="方法2（用哈希表，两次遍历数组）"><a href="#方法2（用哈希表，两次遍历数组）" class="headerlink" title="方法2（用哈希表，两次遍历数组）"></a>方法2（用哈希表，两次遍历数组）</h2><p>我们解这道题的核心思路即：对于数组中一个给定元素num，查找数组中是否存在另一个元素target-num。</p><p>上一个方法之所以复杂度高，是由于在一个数组中查找一个元素需要O(n)的时间复杂度。如果查找这一步能优化，那么整个算法就可以优化。于是我们很容易想到能用O(1)的时间复杂度实现最快查找的数据结构：哈希表</p><p>算法步骤：</p><ol><li>先遍历一次数组，将数组中所有元素加到哈希表中，key为元素的值，value为元素的索引</li><li>再从头到尾遍历数组。对于每遍历到的一个元素num，在哈希表中查找是否存在target-num。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)<br>        map.put(nums[i], i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i]) &amp;&amp; map.get(target - nums[i]) != i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, map.get(target - nums[i])&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="方法3（用哈希表，一次遍历数组）"><a href="#方法3（用哈希表，一次遍历数组）" class="headerlink" title="方法3（用哈希表，一次遍历数组）"></a>方法3（用哈希表，一次遍历数组）</h2><p>其实，我们只需遍历一遍数组就能把问题解决。从头到尾遍历数组。对于每遍历到的一个元素num，如果target-num在哈希表中，则返回。否则将当前元素加到哈希表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i]))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;<br>        <span class="hljs-keyword">else</span><br>            map.put(nums[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】15.三数之和</title>
    <link href="/2021/02/19/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/02/19/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p> </p><pre><code>示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1],[-1, -1, 2]]</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>注意题目中要求答案中不可以包含重复的三元组，所以时间复杂度为O(n^3)的暴力解法是行不通的。之前我们曾用时间复杂度O(n)和空间复杂度O(n)解决了两数之和问题。于是我们可以从头遍历数组，对于每遍历到的一个元素num，都在数组中查找是否有两数之和为-num的另外两个元素，这样这3个元素的和就为0了。</p><p>按照这种思路的时间复杂度为O(n^2),因为这个时间复杂度大于排序所需的O(nlogn)。所以我们可以先把数组进行排序，以方便后续的操作。排序有着以下两个好处：</p><ol><li>对于两数之和的问题，我们可以不用额外的辅助空间（哈希表）。由于数组的有序性，我们可以用双指针的思路来解决。</li><li>如果nums[i] == nums[i-1]，则可以直接跳过对于i处的遍历，以避免结果中存在重复。</li></ol><p>算法步骤：</p><ul><li><p>先将数组排序，之后从头到尾遍历数组，当遍历到数组nums[i]时，用L和R左右两个指针指向在nums[i]后面的数组两端。计算三个数的和sum，判断是否满足为 0，满足则添加进结果集。</p></li><li><p>如果 nums[i]大于0，则它后面的数组元素必然都大于0，三数之和必然无法等于0，结束循环.</p></li><li><p>如果 nums[i] == nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过</p></li><li><p>当 sum == 0时，nums[L] == nums[L+1]，则会导致结果重复，应该跳过，L++。</p></li><li><p>当 sum == 0时，nums[R] == nums[R-1]，则会导致结果重复，应该跳过，R–。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList(); <br>    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt; <span class="hljs-number">3</span>) <br>        <span class="hljs-keyword">return</span> res; <br>    Arrays.sort(nums);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> L = i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> R = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L &lt; R)&#123;<br>            <span class="hljs-keyword">int</span> sum = nums[i] + nums[L] + nums[R];<br>            <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                res.add(Arrays.asList(nums[i],nums[L],nums[R]));<br>                <span class="hljs-keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="hljs-number">1</span>])<br>                    L++;<br>                <span class="hljs-keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="hljs-number">1</span>])<br>                    R--;<br>                L++;<br>                R--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <br>                L++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) <br>                R--;<br>        &#125;<br>    &#125;        <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】560.和为K的子数组</title>
    <link href="/2021/02/19/560.%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/19/560.%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560.和为K的子数组"></a>560.和为K的子数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><pre><code>示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>一种暴力方法为每次固定一个左边界，在其右边不断尝试可能的右边界，统计有多少个由这样的左右边界构成的子数组使得其中的元素和为K。这种方法时间复杂度为O(N^2)</p><p>改进解法：  </p><ul><li>先遍历一次数组，计算数组中每一个元素对应的前缀和（即在数组中该元素以及它前面的所有元素的和为多少），构建前缀和数组。</li><li>为了避免二次遍历，我们构建一个哈希表，其key为前缀和，value为该前缀和出现的次数。</li><li>这种方法的核心思想是：要找到有多少符合preSum[i] - preSum[j] = K的情况。i为子数组右边界，j为子数组左边界。也就是说我们在遍历到位置i时，想知道在之前有多少个位置j，符合preSum[j] = preSum[i] - K。即前缀和preSum[j]出现了多少次，而这恰好可以直接从哈希表中得到。</li><li>于是我们相当于用了O(N)的空间复杂度，使算法的时间复杂度降为O(N)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.length; i++)&#123;<br>        preSum[i] = preSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        res += map.containsKey(preSum[i] - k) ? map.get(preSum[i] - k) : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(preSum[i]))<br>            map.put(preSum[i], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>            map.put(preSum[i], map.get(preSum[i]) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】1143.最长公共子序列</title>
    <link href="/2021/02/19/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/02/19/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>注：两个字符串的「公共子序列」（Longest Common Subsequence，简称 LCS）是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p><pre><code>示例 1:输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。示例 2:输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。示例 3:输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>遇到子序列相关的问题，可以往动态规划上考虑。这道题让我们在<strong>两个字符串</strong>中寻找共同拥有的最长子序列，因此很容易想到用二维动态规划来解决。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义$dp[i][j]$为：$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度。</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>根据上述dp数组的定义，可以写出如下Base Case：</p><ul><li>i为0时，str1[0…i-1]不构成一个字符串，因此不存在与str2的公共子序列，因此dp[0][j]为0</li><li>j为0时，str2[0…j-1]不构成一个字符串，因此不存在于str1的公共子序列，因此dp[i][0]为0</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><p>当str1遍历到i - 1，str2遍历到j - 1时，即要求$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度时，需要考虑以下的几种情况：</p><ul><li><p>如果str1[i - 1]与str2[j - 1]相等，那么肯定要将其放入str1[0…i−1]和str2[0…j−1]的LCS当中，有了这个字符，LCS的长度就会加1，因此<br>$$dp[i][j] = dp[i - 1][j - 1] + 1$$</p></li><li><p>如果str1[i - 1]与str2[j - 1]不等，则又会分为以下的三种情况：</p><ul><li><p>str1[i - 1]与str2[j - 1]都不放入LCS当中，那么LCS的长度不会产生变化，即dp[i][j] = dp[i - 1][j - 1]</p></li><li><p>str1[i - 1]放入LCS中，但str2[j - 1]不放。这时dp[i][j] = dp[i][j - 1]</p></li><li><p>str1[i - 1]不放入LCS中，但str2[j - 1]放。这时dp[i][j] = dp[i - 1][j]</p><p> 由于在dp[i][j]这个位置可以做上述三种选择，因此取三种选择可能产生的最大值，即为dp[i][j]。即：<br> $$dp[i][j] = max(dp[i - 1][j - 1],dp[i][j - 1],dp[i - 1][j])$$</p></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length() + <span class="hljs-number">1</span>][str2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case,其实可以不用，因为数组初始化时全体元素就为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= str2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= str1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= str1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= str2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1.charAt(i - <span class="hljs-number">1</span>) == str2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[str1.length()][str2.length()];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度:O(m * n)</li><li>空间复杂度:O(m * n)<br>其中，m和n分别为str1和str2的长度</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】714.买卖股票的最佳时机含手续费</title>
    <link href="/2021/02/19/714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
    <url>/2021/02/19/714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><pre><code>示例 1:输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润:  在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>由于每一笔交易只需要支付一次手续费，依据生活经验，我们做如下的约定：只在买入股票时支付手续费，卖出时不支付手续费。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>由于在一个时刻，手中只有持有股票和不持有股票这两种情况，因此定义二维dp数组：</p><ul><li>dp[i][0]：第i天时，如果手中没有股票，这时所能获得的最大利润</li><li>dp[i][1]: 第i天时，如果手中持有股票，这时所能获得的最大利润</li></ul><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>如果第0天不持有股票，说明还没有买过股票，利润为0，因此：<br>$$dp[0][0] = 0$$<br>如果第0天持有股票，说明就在第0天这天买了股票，不仅没有利润，还花费了prices[0]和手续费，因此：<br>$$dp[0][1] = -prices[0] - fee$$</p><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><ul><li><p>第i天手中没有股票这个状态可以由两个状态转移而来：</p><ul><li>第i - 1天时，手中就没有股票</li><li>第i - 1天时，手中持有股票，但在第i天时卖出了股票，赚了prices[i]</li></ul><p>于是，dp[i][0]即为以上两种情况的较大值，即：<br>  $$dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])$$</p></li><li><p>第i天手中持有股票这个状态可以由两个状态转移而来：</p><ul><li>第i - 1天时，手中就持有股票</li><li>第i - 1天时，手中没有股票，但在第i天时买入了股票，花费了prices[i]以及手续费</li></ul><p>于是，dp[i][1]即为以上两种情况的较大值，即：<br>$$dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = - prices[<span class="hljs-number">0</span>] - fee;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i] - fee);<br>    &#125;<br>    <span class="hljs-comment">//在最后一天也可能有手中有股票和无股票两种情况，但都最后一天了，手中有股票不卖肯定亏了，所以手中无股票才会是这时利润最大的情况</span><br>    <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>因为一个时刻的状态只依赖于它前一个时刻的状态，所以可以我们可以进行空间复杂度优化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>    <span class="hljs-comment">//noStock代表手中无股票，haveStock代表手中持有股票</span><br>    <span class="hljs-comment">//二者分别对应着优化前的dp[i][0]和dp[i][1]</span><br>    <span class="hljs-keyword">int</span> noStock = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> haveStock = - prices[<span class="hljs-number">0</span>] - fee;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>        noStock = Math.max(noStock, haveStock + prices[i]);<br>        haveStock = Math.max(haveStock, noStock - prices[i] - fee);<br>    &#125;<br>    <span class="hljs-keyword">return</span> noStock;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】518.零钱兑换 II</title>
    <link href="/2021/02/19/518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II/"/>
    <url>/2021/02/19/518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518.零钱兑换 II"></a>518.零钱兑换 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><p> </p><pre><code>示例 1:输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1示例 2:输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。示例 3:输入: amount = 10, coins = [10] 输出: 1</code></pre><h2 id="方法一（暴力递归）"><a href="#方法一（暴力递归）" class="headerlink" title="方法一（暴力递归）"></a>方法一（暴力递归）</h2><p>例如：arr = [200, 100, 50, 20, 5, 1]，aim = 1000<br>对于第一个元素200：<br>选择0张200的，求出用后面的面值凑出1000的方法数<br>选择1张200的，求出用后面的面值凑出800的方法数<br>选择2张200的，求出用后面的面值凑出600的方法数<br>………<br>选择5张200的，求出用后面的面值凑出0的方法数</p><p>将以上方法数加起来，就是答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coins1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> process1(arr, <span class="hljs-number">0</span>, aim);<br>&#125;<br><span class="hljs-comment">//自由使用index及其之后所有的面值，凑成目标钱数aim的方法数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> aim)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//递归结束条件：如果index来到了最后的位置，已经没有可选的面值了</span><br>    <span class="hljs-comment">//如果这时目标钱数aim为0，则之前所选是一种方法。如果aim不为0，说明没有可选面值但还有钱没凑出来，说明之前所选不是一种可行方法。</span><br>    <span class="hljs-keyword">if</span> (index == arr.length) &#123;<br>        res = aim == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//i表示使用几张arr[index]面值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; arr[index] * i &lt;= aim; i++) <br>            res += process1(arr, index + <span class="hljs-number">1</span>, aim - arr[index] * i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二（动态规划）"><a href="#方法二（动态规划）" class="headerlink" title="方法二（动态规划）"></a>方法二（动态规划）</h2><p>由暴力递归改动态规划有如下几步：</p><ol><li><p>分析可变参数，本题中返回值仅由aim和index两个参数决定。因此可变参数为2个。需要一个二维dp数组。</p></li><li><p>分析可变参数的变化范围：index的变化范围为数组arr的长度，aim的变化范围为0到aim这aim+1个值。分析完这前两步，我们就可以构造dp数组</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dp[i][j]表示用arr中0到i个面值凑出钱数j的方法数</span><br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][aim + <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li><li><p>确定Base Case: i为0和j为0时的情况</p></li><li><p>根据暴力递归的递归主体，分析出一个普遍位置是怎么依赖的。然后依次填充dp数组</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> aim, <span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-comment">//处理边界</span><br>    <span class="hljs-keyword">if</span>(aim == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span> || aim &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//构造dp数组</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length][aim + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; arr[<span class="hljs-number">0</span>] * j &lt;= aim; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][arr[<span class="hljs-number">0</span>] * j] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//填充dp数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= aim; j++) &#123;<br>            num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; j - arr[i] * k &gt;= <span class="hljs-number">0</span>; k++) &#123;<br>                num += dp[i - <span class="hljs-number">1</span>][j - arr[i] * k];<br>            &#125;<br>            dp[i][j] = num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[arr.length - <span class="hljs-number">1</span>][aim];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】514.自由之路</title>
    <link href="/2021/02/19/514.%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
    <url>/2021/02/19/514.%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="514-自由之路"><a href="#514-自由之路" class="headerlink" title="514.自由之路"></a>514.自由之路</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。</p><p>最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。</p><p>旋转 ring 拼出 key 字符 key[i] 的阶段中：</p><ul><li>您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。</li><li>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。</li></ul><p>示例：</p><pre><code>输入: ring = &quot;godding&quot;, key = &quot;gd&quot;输出: 4解释:对于 key 的第一个字符 &#39;g&#39;，已经在正确的位置, 我们只需要1步来拼写这个字符。 对于 key 的第二个字符 &#39;d&#39;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。当然, 我们还需要1步进行拼写。因此最终的输出是 4。</code></pre><p><img src="/img/514.jpg"></p><h2 id="方法一（暴力递归）"><a href="#方法一（暴力递归）" class="headerlink" title="方法一（暴力递归）"></a>方法一（暴力递归）</h2><p>记dfs(i,j)为从ring的i位置出发，拼写出key的j位置及其之后所有字符（key[j….])，所需要走的最少步数是多少。</p><p>因为字符串 key 一定可以由字符串 ring 旋转拼出。因此当key已经拼完时（j等于key.length）为递归函数的返回条件。此刻返回0，因为key已全部拼完，不需要再走步数了。</p><p>当key尚未拼完时，我们若要从ring的i位置出发，拼写出key的j位置及其之后所有字符，需要走的步数包含两部分：</p><ol><li>拼出key中j位置的字符：由于ring中可能有重复字符，因此key[j]在ring中可能有多个出现的位置，我们选择一个最近的位置，转distance步，使得ring中12：00方向指向一个与key[j]相等的字符，然后按下中心按钮，拼出这一字符，于是这一部分要走distance+1步。</li><li>拼出key中j位置之后的所有字符：我们需要在ring中从刚才转distance步到达的这个位置开始，拼出key中从j+1位置开始的字符。递归求这一部分要走的步数：dfs(next, j + 1)</li></ol><p>因此一共要走distance+1 + dfs(next, j + 1)步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">String ring;<br>String key;<br>Map&lt;Character, List&lt;Integer&gt;&gt; map;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRotateSteps</span><span class="hljs-params">(String ring, String key)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.ring = ring;<br>    <span class="hljs-keyword">this</span>.key = key;<br>    <span class="hljs-comment">//map的key为字符，value为字符在ring中出现的位置（一个字符可以出现多次，因此value为列表）</span><br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ring.length(); i++)&#123;<br>        <span class="hljs-keyword">char</span> ch = ring.charAt(i);<br>        <span class="hljs-keyword">if</span>(!map.containsKey(ch))<br>            map.put(ch, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        map.get(ch).add(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(j == key.length())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> position : map.get(key.charAt(j)))&#123;<br>        <span class="hljs-comment">//转到key[j]字符有顺时针转和逆时针转两种转法，我们采用步数较小的那种</span><br>        <span class="hljs-keyword">int</span> forwardDist = Math.abs(i - position);<br>        <span class="hljs-keyword">int</span> backDist = ring.length() - forwardDist;<br>        <span class="hljs-keyword">int</span> distance = Math.min(forwardDist, backDist);<br>        min = Math.min(min, distance + <span class="hljs-number">1</span> + dfs(position, j + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> min;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二（动态规划）"><a href="#方法二（动态规划）" class="headerlink" title="方法二（动态规划）"></a>方法二（动态规划）</h2><p>暴力递归改动态规划一共有如下几步：</p><ol><li>分析哪几个可变参数可以确定返回值的状态。对于这道题：ring中的位置i和key中的位置j一旦确定，返回值就确定</li><li>分析参数的变化范围，建立dp数组（可变参数有几个，dp数组就是几维）。于是: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ring.length()][key.length()];<br></code></pre></td></tr></table></figure></li><li>根据暴力递归的递归结束条件，确定base case<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Base Case:j为key.length() - 1时</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ring.length(); i++) &#123;<br>    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> position : map.get(key.charAt(key.length() - <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-keyword">int</span> forwardDist = Math.abs(i - position);<br>        <span class="hljs-keyword">int</span> backDist = ring.length() - forwardDist;<br>        <span class="hljs-keyword">int</span> distance = Math.min(forwardDist, backDist) + <span class="hljs-number">1</span>;<br>        min = Math.min(min, distance);<br>    &#125;<br>    dp[i][key.length() - <span class="hljs-number">1</span>] = min;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>根据递归主体，分析出一个普遍位置是怎么依赖的。然后依次填充dp数组</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">String ring;<br>String key;<br>Map&lt;Character, List&lt;Integer&gt;&gt; map;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRotateSteps</span><span class="hljs-params">(String ring, String key)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.ring = ring;<br>    <span class="hljs-keyword">this</span>.key = key;<br>    <span class="hljs-comment">//构建map，这步和暴力递归解法相同</span><br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ring.length(); i++) &#123;<br>        <span class="hljs-keyword">char</span> ch = ring.charAt(i);<br>        <span class="hljs-keyword">if</span> (!map.containsKey(ch))<br>            map.put(ch, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        map.get(ch).add(i);<br>    &#125;<br>    <span class="hljs-comment">//构建dp数组</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ring.length()][key.length()];<br>    <span class="hljs-comment">//确定Base Case:j为key.length() - 1时</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ring.length(); i++) &#123;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> position : map.get(key.charAt(key.length() - <span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-keyword">int</span> forwardDist = Math.abs(i - position);<br>            <span class="hljs-keyword">int</span> backDist = ring.length() - forwardDist;<br>            <span class="hljs-keyword">int</span> distance = Math.min(forwardDist, backDist) + <span class="hljs-number">1</span>;<br>            min = Math.min(min, distance);<br>        &#125;<br>        dp[i][key.length() - <span class="hljs-number">1</span>] = min;<br>    &#125;<br>    <span class="hljs-comment">//填充dp数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = key.length() - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ring.length(); i++) &#123;<br>            <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> position : map.get(key.charAt(j))) &#123;<br>                <span class="hljs-keyword">int</span> forwardDist = Math.abs(i - position);<br>                <span class="hljs-keyword">int</span> backDist = ring.length() - forwardDist;<br>                <span class="hljs-keyword">int</span> distance = Math.min(forwardDist, backDist);<br>                min = Math.min(min, distance + <span class="hljs-number">1</span> + dp[position][j + <span class="hljs-number">1</span>]);<br>            &#125;<br>            dp[i][j] = min;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】494.目标和</title>
    <link href="/2021/02/19/494.%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <url>/2021/02/19/494.%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p> </p><pre><code>示例：输入：nums: [1, 1, 1, 1, 1], S: 3输出：5解释：-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。</code></pre><h2 id="方法一：暴力法（回溯算法）"><a href="#方法一：暴力法（回溯算法）" class="headerlink" title="方法一：暴力法（回溯算法）"></a>方法一：暴力法（回溯算法）</h2><p>对于回溯法，需要重点考虑三个问题：</p><ul><li>路径：目前为止已经做出的选择（目前所产生的和sum）</li><li>选择列表：当前可以做的选择（给nums[i]加号或者减号）</li><li>结束条件：到达决策树的叶节点时，无法再继续做选择，结束。（用完了数组nums中的每一个数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] nums;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> S;<br>    <span class="hljs-comment">//res记录能组合成目标数S的方法数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> res;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.nums = nums;<br>        <span class="hljs-keyword">this</span>.S = S;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯主体</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-comment">//结束条件：用完了数组中的所有元素</span><br>        <span class="hljs-keyword">if</span>(i == nums.length)&#123;<br>            <span class="hljs-comment">//如果使用完所有元素构成了目标数S，则res加1</span><br>            <span class="hljs-keyword">if</span>(sum == S)<br>                res++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//首先尝试给nums[i]加正号，做选择、递归下一步、撤销选择</span><br>        sum += nums[i];<br>        backtrack(i + <span class="hljs-number">1</span>, sum);<br>        sum -= nums[i];<br>        <span class="hljs-comment">//再尝试给nums[i]加负号，做选择、递归下一步、撤销选择</span><br>        sum -= nums[i];<br>        backtrack(i + <span class="hljs-number">1</span>, sum);<br>        sum += nums[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：动态规划（01背包问题）"><a href="#方法二：动态规划（01背包问题）" class="headerlink" title="方法二：动态规划（01背包问题）"></a>方法二：动态规划（01背包问题）</h2><h3 id="1-定义状态"><a href="#1-定义状态" class="headerlink" title="1.定义状态"></a>1.定义状态</h3><p>定义dp[i][j]为给子数组nums[0…i]的每个元素加号或减号，能凑成目标数S的方法数</p><p>由于目标数可正可负，因此j也应该既有正也有负。在这里我们令j的取值为从-sum到+sum。其中sum为数组nums中所有元素之和。</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>当i为0时，也就是说只用数组的第一个元素nums[0]去凑成目标数S，有多少种方法。分两种情况：</p><ul><li>当nums[0]为0时，要凑成0有两种方法（给nums[0]加正号或负号都可以），要凑成其他数就没有办法了。</li><li>当nums[0]非0时，凑成nums[0]或-nums[0]有一种方法，要凑成其他数没有办法。</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><p>对于数组中的每个数nums[i]，我们都有两种选择：</p><ul><li>给nums[i]加号+</li><li>给nums[i]减号-</li></ul><p>如果给nums[i]加号，那么$dp[i][j] = dp[ i - 1 ][ j - nums[i]]$,即：不算nums[i]这个数，前面的nums[0…i-1]要凑成S-nums[i]。这样算上nums[i]后才能凑成目标数S。</p><p>如果给nums[i]减号，那么$dp[i][j] = dp[ i - 1 ][ j + nums[i]]$,即：不算nums[i]这个数，前面的nums[0…i-1]要凑成S+nums[i]。这样算上nums[i]后才能凑成目标数S。</p><p>把这两种选择每种的方法数相加，就是dp[i][j]，即：$dp[ i ][ j ] = dp[ i - 1 ][ j - nums[ i ] ] + dp[ i - 1 ][ j + nums[ i ] ]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意：在上述中：dp数组对于j的取值为从-sum到+sum，但具体到代码上时，由于数组的索引不可能为负，因此需要进行适当的调整，把j的取值改为从0到2*sum</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;<br>    <span class="hljs-comment">//处理边界情况</span><br>    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> (nums[<span class="hljs-number">0</span>] == S || nums[<span class="hljs-number">0</span>] == -S) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//sum记录数组中所有元素之和</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums)<br>        sum += num;<br>    <span class="hljs-comment">//如果S比数组中所有元素之和都大，那么肯定无法得到目标数S，返回0</span><br>    <span class="hljs-keyword">if</span> (Math.abs(S) &gt; Math.abs(sum)) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length][<span class="hljs-number">2</span> * sum + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>        dp[<span class="hljs-number">0</span>][sum] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        dp[<span class="hljs-number">0</span>][sum + nums[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>][sum - nums[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//状态转移（填充dp数组）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = -sum; j &lt;= sum; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j + nums[i] &gt; sum)<br>                dp[i][j + sum] = dp[i - <span class="hljs-number">1</span>][j + sum - nums[i]];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j - nums[i] &lt; -sum)<br>                dp[i][j + sum] = dp[i - <span class="hljs-number">1</span>][j + sum + nums[i]];<br>            <span class="hljs-keyword">else</span><br>                dp[i][j + sum] = dp[i - <span class="hljs-number">1</span>][j + sum - nums[i]] + dp[i - <span class="hljs-number">1</span>][j + sum + nums[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>][S + sum];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】474.一和零</title>
    <link href="/2021/02/19/474.%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
    <url>/2021/02/19/474.%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p><p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p><p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p><p> </p><pre><code>示例 1:输入: strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出: 4解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot; 。示例 2:输入: strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出: 2解释: 你可以拼出 &quot;10&quot;，但之后就没有剩余数字了。更好的选择是拼出 &quot;0&quot; 和 &quot;1&quot; 。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><h3 id="1-状态定义（题目要什么就把什么定义为状态）"><a href="#1-状态定义（题目要什么就把什么定义为状态）" class="headerlink" title="1.状态定义（题目要什么就把什么定义为状态）"></a>1.状态定义（题目要什么就把什么定义为状态）</h3><p>定义dp[i][j][k]为在有j个0和k个1的情况下，最多能拼出子数组strs[0…i]中的多少个字符串。</p><h3 id="2-Base-case"><a href="#2-Base-case" class="headerlink" title="2.Base case"></a>2.Base case</h3><p>先确定dp[0][j][k],即能否用j个0和k个1拼出strs[0]，若能则该dp值为1，若不能则为0.</p><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><p>每到strs中的一个字符串时，都面临两个选择：拼这个字符串或者不拼这个字符串。dp值取二者中的较大值。</p><ul><li>若不拼这个字符串，$dp[i][j][k] = dp[i−1][j][k]$</li><li>若拼这个字符串，假如当前的这个字符串有a个0，b个1。则拼这个字符串就会消耗这a个1，b个0。于是$dp[i][j][k] = dp[i-1][j-a][k-b] + 1$</li><li>注意：当目前拥有的0的个数j和1的个数k小于拼这个字符串所需要的a和b时，只能选择不拼这个字符串。</li></ul><p>最后返回$dp[strs.length - 1][m][n]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[strs.length][m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    <span class="hljs-keyword">int</span>[] countBase = count0And1(strs[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= n; k++)<br>            dp[<span class="hljs-number">0</span>][j][k] = (j &gt;= countBase[<span class="hljs-number">0</span>] &amp;&amp; k &gt;= countBase[<span class="hljs-number">1</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;<br>        <span class="hljs-keyword">int</span>[] count = count0And1(strs[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= n; k++) &#123;<br>                <span class="hljs-keyword">int</span> a = count[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> b = count[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(j &lt; a || k &lt; b)<br>                    dp[i][j][k] = dp[i-<span class="hljs-number">1</span>][j][k];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j][k] = Math.max(dp[i-<span class="hljs-number">1</span>][j][k], dp[i-<span class="hljs-number">1</span>][j-a][k-b]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[strs.length - <span class="hljs-number">1</span>][m][n];<br>&#125;<br><br><span class="hljs-comment">//统计字符串str中0和1出现的次数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] count0And1(String str)&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//res[0]代表字符串str中字符0出现的次数，res[1]代表字符串str中字符1出现的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: str.toCharArray())&#123;<br>        res[c - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h2><p>由于dp数组的第i行只与它的前一行第i-1行有关，因此我们可以去掉i这个维度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>        <span class="hljs-keyword">int</span>[] count = count0And1(str);<br>        <span class="hljs-keyword">int</span> a = count[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> b = count[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//注意：这里要逆向填充</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = m; j &gt;= a; j--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n; k &gt;= b; k--) &#123;<br>                dp[j][k] = Math.max(dp[j][k], dp[j-a][k-b]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br><br><span class="hljs-comment">//统计字符串str中0和1出现的次数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] count0And1(String str)&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//res[0]代表字符串str中字符0出现的次数，res[1]代表字符串str中字符1出现的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: str.toCharArray())&#123;<br>        res[c - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】416.分割等和子集</title>
    <link href="/2021/02/19/416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <url>/2021/02/19/416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:<br>每个数组中的元素不会超过 100，数组的大小不会超过 200  </p><pre><code>示例 1:输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集.</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>题目的意思我们可以换一种方式理解：假设数组nums的元素和为sum，是否能找到数组的一个子序列，使得它的和为sum/2。</p><p>在起初，我们可以先进行以下判断：</p><ul><li>如果nums的元素和sum为奇数，则不可能找到和为sum/2的子序列(因为nums中元素都为整数，和不可能为一个小数)，直接返回false。</li><li>如果nums中最大的元素大于sum/2，也就意味着nums中其余所有元素的和小于sum/2，直接返回false。<h3 id="1-状态定义"><a href="#1-状态定义" class="headerlink" title="1.状态定义"></a>1.状态定义</h3>定义布尔类型的二维数组dp，dp[i][j]表示数组nums[0…i]中是否有和为j的子序列。</li></ul><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>base case为这个二维数组的第一行和第一列。</p><ul><li>j=0时，无论i为多少，都为true。因为任何一个nums[0…i]都有一个和为0的子序列（子序列中元素为0）。所以，dp[i][0] = true</li><li>i = 0时，只能选择数组的第一个元素nums[0]，因此当j与nums[0]相等时为true，其余都为false。即，dp[0][nums[0]] = true</li></ul><h3 id="3-状态转换方程"><a href="#3-状态转换方程" class="headerlink" title="3.状态转换方程"></a>3.状态转换方程</h3><p>当遍历到一个数nums[i]，我们有两种选择：选它或者不选它来构建和为j的子序列，这两种选择只要有一个为true，dp[i][j]就为true。</p><p>我们分为两种情况来讨论：</p><ul><li>j &gt;= nums[i]时：<ul><li>如果选nums[i]，那么只须判断nums[0…i-1]是否有和为j-nums[i]的子序列即可。即dp[i][j] = dp[i - 1][j - nums[i]]</li><li>如果不选nums[i],则dp[i][j] = dp[i - 1][j]</li></ul></li><li>j &lt; nums[i]时：<br>这种情况下不可以选nums[i]，因为一旦选nums[i]进子序列，由于nums[i] &gt; j，子序列的和一定大于j，不可能等于j。因此dp[i][j]一定为false。因此dp[i][j] = dp[i - 1][j]</li></ul><p>最后返回dp[n-1][target]即可，即nums数组中是否有和为target的子序列（target为sum/2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        sum += num;<br>    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length][target + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>    dp[<span class="hljs-number">0</span>][nums] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= target; j++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= nums[i])<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i]];<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][target];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h2><p>在填充dp数组时我们发现，每一行的dp值都只与它上一行的dp值有关，因此我们可以优化掉行这个维度，只留列的维度。于是可以将dp数组由二维将为一维。</p><p>空间复杂度由O(n*target)降到O(target)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        sum += num;<br>    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[target + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//注意：这里要逆向填充</span><br>        <span class="hljs-comment">//如果我们对于j从小到大更新dp值，在计算dp[j]的时候，dp[j - nums[i]]已经是该行被更新过的状态，而我们希望它是上一行的状态。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = target; j &gt;= num[i]; j--)&#123;<br>            dp[j] = dp[j] || dp[j - nums[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】343.整数拆分</title>
    <link href="/2021/02/19/343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <url>/2021/02/19/343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><pre><code>示例 1:输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。示例 2:输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>每一个整数n拆分得到的最大乘积可以由比n小的整数拆分得到的最大乘积来得到，因此可以考虑用动态规划。</p><p>若要求i拆分得到的最大乘积，我们可以将i拆分为j和i - j之和，这时我们有两个选择：</p><ul><li>j不再继续拆分，这时乘积为j * (i - j)</li><li>j继续向下拆分，因为j拆分得到的最大乘积为dp[j]，因此这时的乘积为dp[j] * (i - j)</li></ul><p>将这两种情况的乘积取较大的那个，即为拆分i所能得到的最大乘积。</p><p>动态规划步骤：</p><ul><li>定义dp[i]为将整数i拆分所能得到的最大乘积</li><li>Base Case：dp[0] = 0, dp[1] = 1</li><li>状态转移方程：$\operatorname{dp}[i]=\max _{1 \leq j&lt;i}{\max (j \times(i-j), j \times \operatorname{dp}[i-j])}$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--)&#123;<br>            max = Math.max(max, Math.max(j * (i - j), (i - j) * dp[j]));<br>        &#125;<br>        dp[i] = max;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】322.零钱兑换</title>
    <link href="/2021/02/19/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <url>/2021/02/19/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322 零钱兑换"></a>322 零钱兑换</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><pre><code>示例 1:输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1示例 2:输入: coins = [2], amount = 3输出: -1</code></pre><h2 id="方法（暴力递归）"><a href="#方法（暴力递归）" class="headerlink" title="方法（暴力递归）"></a>方法（暴力递归）</h2><p>如果想求 amount = 11 时的最少硬币数（原问题），若已经知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制约，是互相独立的。</p><p>按如下步骤来考虑：</p><ol><li><p>分析<strong>base case</strong>：当目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p></li><li><p>分析<strong>可变参数</strong>，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的<strong>可变参数</strong>就是目标金额amount。</p></li><li><p>确定<strong>决策</strong>，也就是导致<strong>可变参数</strong>产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的<strong>决策</strong>。</p></li><li><p>明确 dp 函数/数组的定义。如果是自顶向下的暴力递归情况，就会有一个递归的dp函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的<strong>可变参数</strong>；函数的返回值就是题目要求我们计算的量。  </p><p>就本题来说，<strong>可变参数</strong>只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：dp(n) 的定义：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dp(coins, amount);<br>    &#125;<br>    <span class="hljs-comment">//编写dp函数，它对于一个要凑成的总金额，返回最少用的硬币个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(amount &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin: coins)&#123;<br>            <span class="hljs-keyword">int</span> subProblem = dp(coins, amount - coin);<br>            <span class="hljs-keyword">if</span>(subProblem == -<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            res = Math.min(res, <span class="hljs-number">1</span> + subProblem);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res != Integer.MAX_VALUE ? res : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>以上暴力解法的代码转化为数学形式就是状态转移方程：</p><p><img src="/img/322.%E5%85%AC%E5%BC%8F.jpg"></p><p>上述的暴力递归方法是自顶向下的，因此会产生很多重复计算。我们接下来把它改成自底向上的动态规划：</p><p>动态规划需要一个dp数组，dp数组的定义与上述的dp函数类似，其索引是要凑成的金额amount的值，索引对应的值为要凑成amount需要的最小硬币数。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//将dp数组的所有元素初始化为amount + 1，因为dp[amount] 最大不可能超过 amount（最小面值为 1 元），所以 amount + 1 是一个无意义的数。</span><br>    <span class="hljs-comment">//如果索引index对应的数组元素为amount + 1，代表无法通过给定的硬币凑成金额index。</span><br>    Arrays.fill(dp, amount + <span class="hljs-number">1</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++)&#123;<br>        <span class="hljs-comment">//计算dp[i]：要凑成金额i最少需要多少硬币</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin : coins)&#123;<br>            <span class="hljs-keyword">if</span>(i - coin &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            dp[i] = Math.min(dp[i], <span class="hljs-number">1</span> + dp[i - coin]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (dp[amount] == amount + <span class="hljs-number">1</span>) ? -<span class="hljs-number">1</span> :dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】309.最佳买卖股票时机含冷冻期</title>
    <link href="/2021/02/19/309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <url>/2021/02/19/309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><pre><code>示例:输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><h2 id="方法（二维DP）"><a href="#方法（二维DP）" class="headerlink" title="方法（二维DP）"></a>方法（二维DP）</h2><h3 id="1-状态定义"><a href="#1-状态定义" class="headerlink" title="1.状态定义"></a>1.状态定义</h3><p>通过分析题意，我们可以将所有状态归结为以下三种（分别记为状态1、2、3）:</p><ol><li>持股</li><li>不持股且在冷冻期（不能买入）</li><li>不持股且不在冷冻期（能买入）</li></ol><p>返回值的状态由两个参数决定（天数和状态），因此这是一个二维DP的问题。</p><p><strong>定义dp[i][j]为在第i天状态为j时的最大收益</strong></p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>在第0天只有买入和不买入的两种操作，不可能存在卖出（因为不可能在第0天前买入0。</p><ul><li>如果第0天买入，即持股，对应状态0，花费了prices[0]。于是$dp[0][0] = -prices[0]$;</li><li>如果第0天不买入，即不持股，对应状态1、2。不花钱不赚钱。于是$dp[0][1]=dp[0][2]=0$</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><ul><li><p>持股状态可以由两种情况转换来：</p><ol><li>昨天持股，今天不卖</li><li>昨天不持股且非冷冻期，今天买入</li></ol></li><li><p>冷冻期状态只能由以下一种情况转换来：</p><ul><li>昨天持股，今天卖出</li></ul></li><li><p>不持股且不在冷冻期状态可以由两种情况转换来：</p><ul><li>昨天处在冷冻期，今天不能买</li><li>昨天不持股且不在冷冻期，今天可以买但是偏偏不买</li></ul><p>具体转换过程如下图所示：</p></li></ul><p><img src="/img/309.jpg"></p><p>注意：在最后一天(第i-1天）时，一定不能持股，无论什么价位都要卖出，不然会亏。即在最后一天时的持股状态不可能产生最大收益。因此最大收益应该为最后一天时不持股和冷冻期这两种状态的较大者。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices == <span class="hljs-keyword">null</span> || prices.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>        dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(dp[n - <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[n - <span class="hljs-number">1</span>], Math.max(dp[n - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">2</span>][<span class="hljs-number">2</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h2><p>由于第i天的状态只与第i-1天的状态有关，因此我们可以用如下方式降低空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices == <span class="hljs-keyword">null</span> || prices.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-comment">//设置base case</span><br>    <span class="hljs-keyword">int</span> dp0 = -prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> dp1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> dp2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">int</span> new1 = Math.max(dp0, dp2 - prices[i]);<br>        <span class="hljs-keyword">int</span> new2 = dp0 + prices[i];<br>        <span class="hljs-keyword">int</span> new3 = Math.max(dp1, dp2);<br>        dp0 = new1;<br>        dp1 = new2;<br>        dp2 = new3;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(dp0 + prices[n - <span class="hljs-number">1</span>], Math.max(dp1, dp2));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-tu-miao-dong-jie-fa-by-zi-gei-zi-zu/">leetcode题解区</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】279.完全平方数</title>
    <link href="/2021/02/19/279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/02/19/279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>即：要用最少的完全平方数组成n，求这个最少的完全平方数的个数为多少。</p><pre><code>示例 1:输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4.示例 2:输入: n = 13输出: 2解释: 13 = 4 + 9.</code></pre><h2 id="方法1（动态规划）"><a href="#方法1（动态规划）" class="headerlink" title="方法1（动态规划）"></a>方法1（动态规划）</h2><ul><li>状态定义：dp[i]表示组成数字i要用的最少完全平方数个数</li><li>base case：dp[0] = 0, dp[1] = 1</li><li>状态转移方程：$dp[i] = min(dp[i], dp[i - j<em>j] + 1)$<br>最开始初始化dp[i]都为i，即用i个1（1也是完全平方数）可以组成i。<br>j</em>j为完全平方数，状态转移方程的意思为：整数i-j * j最少要用dp[i - j * j]个完全平方数组成，那么算上这个完全平方数的话，整数i<strong>可以</strong>用dp[i - j * j] + 1个完全平方数组成，于是将dp[i - j * j] + 1与原来的dp[i]取较小的那个，便可得到整数i<strong>最少</strong>可用多少个完全平方数组成。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        dp[i] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; i - j * j &gt;= <span class="hljs-number">0</span>; j++)<br>            dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法2（BFS）"><a href="#方法2（BFS）" class="headerlink" title="方法2（BFS）"></a>方法2（BFS）</h2><p>把0到n的每个整数看成图中的一个节点，如果两个整数之间相差一个平方数，那么就认为这两个整数所在的节点间有一条边。</p><p>所以题目要求的最小的平方数数量，也就是求解从节点 n 到节点 0 的最短路径。</p><p>在图中的最短路径问题，很容易想到BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    List&lt;Integer&gt; squares = generateNum(n);<br>    queue.add(n);<br>    visited[n] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        count++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            <span class="hljs-keyword">int</span> temp = queue.poll();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> square : squares)&#123;<br>                <span class="hljs-keyword">if</span>(temp - square == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> count;<br>                <span class="hljs-keyword">if</span>(temp - square &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span>(visited[temp - square])<br>                    <span class="hljs-keyword">continue</span>;<br>                queue.add(temp - square);<br>                visited[temp - square] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//生成小于n的所有完全平方数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">generateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++)&#123;<br>        nums.add(i * i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】198.打家劫舍</title>
    <link href="/2021/02/19/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2021/02/19/198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h1><p><strong>题目：</strong><br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><blockquote><p>示例 1:<br>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。  </p></blockquote><blockquote><p>示例 2:<br>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><p><strong>思路：</strong>  </p><blockquote><p>用动态规划的思想来解决，用dp[i]表示前i家获取的最高金额。在第i家时，一共只有两个选择：偷或者不偷。如果偷第i家，则就不能偷第i-1家。获得的金额为dp[i]=dp[i-2]+nums[i]。如果不偷第i家，则无新的金额，即：dp[i] = dp[i-1]。<br>于是对于第i家，综合以上两种决策取最大值。前i家获得的最高金额为（也即状态转移方程）：<br>dp[i]=max(dp[i-1],dp[i-2]+nums[i])<br>DP 数组也可以叫”子问题数组”，因为 DP 数组中的每一个元素都对应一个子问题。</p></blockquote><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || len == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++)&#123;<br>            <span class="hljs-comment">//状态转移方程。注意：dp中的第i号元素为nums中的第i-1号元素</span><br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + nums[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】188.买卖股票的最佳时机 IV</title>
    <link href="/2021/02/19/188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV/"/>
    <url>/2021/02/19/188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV/</url>
    
    <content type="html"><![CDATA[<h1 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188.买卖股票的最佳时机 IV"></a>188.买卖股票的最佳时机 IV</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> </p><p>示例 1：</p><pre><code>输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</code></pre><p>示例 2：</p><pre><code>输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。    随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><h3 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h3><p>hasStock[i][j]:表示第i天时，已经交易j次，并且当前持股时的最大收益<br>noStock[i][j]:表示第i天时，已经交易j次，并且当前不持股时的最大收益  </p><h3 id="Base-Case"><a href="#Base-Case" class="headerlink" title="Base Case"></a>Base Case</h3><p>在第0天，还没进行过交易时，如果手中持股，则说明在第0天买入了股票，当前收益为-prices[0]。若手中不持股，当前收益为0.于是hasStock[0][0] = -prices[0]， noStock[0][0] = 0。</p><p>由于买入和卖出需要在不同的时间，因此在第0天不可能有过任何交易，hasStock[0][1…k]和noStock[0][1…k]均无效，我们将其设为最小值Integer.MIN_VALUE</p><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>对于hasStock[i][j]：</p><ul><li>如果手上的股票是在第i天买入的，那么第i-1天时，手中肯定不持有股票，对应着状态noStock[i-1][j]</li><li>如果手中的股票不是在第i天买入的，那么第i-1天时，手中持有股票，对应着状态hasStock[i-1][j]</li></ul><p>于是：<br>$hasStock[i][j] = max(hasStock[i-1][j], noStock[i-1][j] - prices[i])$</p><p>对于noStock[i][j]:</p><ul><li>如果手上的股票是第i天卖出的，那么在第i-1天时，手中持有股票，对应着状态hasStock[i-1][j-1]</li><li>如果手上的股票不是第i天卖出的，那么在第i-1天时，手中不持有股票，对应着状态noStock[i-1][j]</li></ul><p>于是：<br>$noStock[i][j] = max(noStock[i-1][j], hasStock[i-1][j-1] + prices[i])$</p><p>由于在最后一天时，手中持有股票肯定是不明智的，一定要在结束前将股票卖出才可能收获最大利润，因此最大利润一定为noStock[n - 1][0…k]中的一个，取最大值即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-comment">//由于n天最多也就能进行n/2次交易，因此重新设置最多能进行的交易次数k</span><br>    k = Math.min(k, n / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span>[][] hasStock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span>[][] noStock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//设置base case</span><br>    hasStock[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>    noStock[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//设置为最小值的一半，防止溢出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br>        hasStock[<span class="hljs-number">0</span>][j] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;<br>        noStock[<span class="hljs-number">0</span>][j] = Integer.MIN_VALUE / <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        hasStock[i][<span class="hljs-number">0</span>] = Math.max(hasStock[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], noStock[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            hasStock[i][j] = Math.max(hasStock[i-<span class="hljs-number">1</span>][j], noStock[i-<span class="hljs-number">1</span>][j] - prices[i]);<br>            noStock[i][j] = Math.max(noStock[i-<span class="hljs-number">1</span>][j], hasStock[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + prices[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//统计noStock[n - 1][1...k]的最大值</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)<br>        res = Math.max(res, noStock[n - <span class="hljs-number">1</span>][j]);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp/">Leetcode题解区</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】152.乘积最大子数组</title>
    <link href="/2021/02/19/152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/19/152.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152.乘积最大子数组"></a>152.乘积最大子数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p> </p><pre><code>示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>因为数组中的数可负可正。由于存在负数，那么最大积可能乘以下一个数就变成最小积，最小积可能乘以下一个数就变成最大积。因此我们同时维护两个dp数组：maxDP和minDP。</p><ul><li>max[i]记录以数组nums中第i个元素结尾的子数组的最大积</li><li>min[i]记录以数组nums中第i个元素结尾的子数组的最小积</li></ul><p>状态转移方程：</p><ul><li>$maxDP[i] = Max(maxDP[i-1]*nums[i], nums[i], minDP[i-1]*nums[i])$</li><li>$minDP[i] = Min(minDP[i-1]*nums[i], nums[i], maxDP[i-1]*nums[i])$</li></ul><p>特殊情况：若nums[i]为0，则以nums[i]结尾的子数组的乘积只能为0（因为子数组中包括0），于是maxDP[i]和minDP[i]均为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span>[] maxDP = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">int</span>[] minDP = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-comment">//base case</span><br>    maxDP[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    minDP[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        maxDP[i] = Math.max(maxDP[i-<span class="hljs-number">1</span>] * nums[i], Math.max(nums[i], minDP[i-<span class="hljs-number">1</span>] * nums[i]));<br>        minDP[i] = Math.min(minDP[i-<span class="hljs-number">1</span>] * nums[i], Math.min(nums[i], maxDP[i-<span class="hljs-number">1</span>] * nums[i]));<br>        res = Math.max(res, maxDP[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><strong>空间优化</strong><br>i位置上的状态(maxDP和minDP)只与i-1位置上的状态有关，所以更新 maxDP[i]的时候，我们只用到maxDP[i-1]的信息，再之前的信息就用不到了。所以我们不需要维护两个数组，只需要维护两个变量来记录i-1处的位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">int</span> maxDP = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> minDP = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//因为在更新minDP前需要更新maxDP，因此需要把前一步的maxDP先保存起来</span><br>        <span class="hljs-keyword">int</span> preMax = maxDP;<br>        maxDP = Math.max(maxDP * nums[i], Math.max(nums[i], minDP * nums[i]));<br>        minDP = Math.min(minDP * nums[i], Math.min(nums[i], preMax * nums[i]));<br>        res = Math.max(res, maxDP);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】139.单词拆分</title>
    <link href="/2021/02/19/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <url>/2021/02/19/139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><pre><code>示例 1：输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;示例 2：输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。     注意你可以重复使用字典中的单词。示例 3：输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>分析题意：<br>“applepenapple”能否被成功拆分取决于”applepen”能否被成功拆分以及”apple”是否为字典中的单词。</p><p>即：字符串的前i个字符能否被成功拆分，取决于字符串前j个字符能否被成功拆分以及s[j…i]是否是字典中的单词。</p><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>定义dp[i]为字符串s的前i个字符（s[0..j-1])能否成功拆分。</p><h3 id="设置Base-Case"><a href="#设置Base-Case" class="headerlink" title="设置Base Case"></a>设置Base Case</h3><p>dp[0] = true</p><h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>dp[i] = dp[j] &amp;&amp; (s[j…i]是否在字典中)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>    Set&lt;String&gt; set= <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(String word: wordDict)&#123;<br>        set.add(word);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-comment">//flag记录s[j...i]是否在字典中</span><br>            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span>(set.contains(s.substring(j, i)))<br>                flag = <span class="hljs-keyword">true</span>;<br>            dp[i] = dp[j] &amp;&amp; flag;<br>            <span class="hljs-comment">//只要有一种方法使得s[0..j-1]能成功拆分，那么s[0..j-1]就是可拆分的。</span><br>            <span class="hljs-comment">//则无需判断之后的拆分方式，退出对于j的循环</span><br>            <span class="hljs-keyword">if</span>(dp[i])<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.length()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】120.三角形最短路径和</title>
    <link href="/2021/02/19/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/02/19/120.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="120-三角形最短路径和"><a href="#120-三角形最短路径和" class="headerlink" title="120.三角形最短路径和"></a>120.三角形最短路径和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p> </p><pre><code>例如，给定三角形：[    [2],    [3,4],    [6,5,7],    [4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）</code></pre><h2 id="方法1（暴力递归）"><a href="#方法1（暴力递归）" class="headerlink" title="方法1（暴力递归）"></a>方法1（暴力递归）</h2><p>设f(i,j)为从位置(i,j)到最后一行的最短路径和。则可以发现如下规律：<br>$$f(i,j) = min(f(i+1,j) , f(i+1,j+1)) + triangle[i][j]$$</p><p>根据上述规律，很容易就可以写出以下暴力递归的方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span>  help(triangle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">help</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i = triangle.size())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> Math.min(help(triangle, i + <span class="hljs-number">1</span>, j), help(triangle, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>)) + triangle.get(i).get(j));<br>&#125;<br></code></pre></td></tr></table></figure><p>暴力递归的方法会产生很多重复计算，因此动态规划方法要用额外的dp数组来进行优化。</p><h2 id="方法2（动态规划）"><a href="#方法2（动态规划）" class="headerlink" title="方法2（动态规划）"></a>方法2（动态规划）</h2><p>对暴力递归方法进行分析可以知道，用来确定返回值状态的可变参数为i和j，也即位置。</p><p>因此定义二维的dp数组。其中dp[i][j]的含义为：从(i, j)位置走到三角形最后一行的最短路径和。</p><p>状态转移方程为：<br>$$dp(i,j) = min(dp(i+1,j) , dp(i+1,j+1)) + triangle[i][j]$$</p><p>由三角形的最后一行不断向上进行状态转移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = triangle.size();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>    <span class="hljs-comment">//先把不被依赖的位置（最后一行）对应dp数组的值填好</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        dp[n - <span class="hljs-number">1</span>][i] = triangle.get(n - <span class="hljs-number">1</span>).get(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++)<br>            dp[i][j] = Math.min(dp[i+<span class="hljs-number">1</span>][j] , dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(n^2)  </p><h2 id="方法3（对空间进行优化）"><a href="#方法3（对空间进行优化）" class="headerlink" title="方法3（对空间进行优化）"></a>方法3（对空间进行优化）</h2><p>对方法2的实际运行过程进行分析，可以发现。对于dp[i][j]的计算，只需要知道dp数组第i+1行的情况即可，因此无需将整个dp数组的N行全部保存，只保存第i+1行这一行就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = triangle.size();<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        dp[j] = triangle.get(n - <span class="hljs-number">1</span>).get(j);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            dp[j] = Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(n) </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】91.解码方法</title>
    <link href="/2021/02/19/91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <url>/2021/02/19/91.%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><pre><code>&#39;A&#39; -&gt; 1&#39;B&#39; -&gt; 2...&#39;Z&#39; -&gt; 26</code></pre><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><pre><code>示例 1:输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。示例 2:输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>此题和<a href="https://leetcode-cn.com/problems/climbing-stairs/">70.爬楼梯</a>这道题相似。爬楼梯要求每次只能爬一个台阶或两个台阶，所以爬n层台阶的爬法是爬n-1层台阶和爬n-2层台阶的爬法之和。而对于此题，一个字符既可以单独解码（例如：’1’ -&gt; A），又可以和它的前一个字符共同解码（例如：’26’ -&gt; Z）。</p><p>设dp[i]表示字符串前i个字符组成的子串s[0…i-1]的解码方法个数。于是从整体逻辑上而言：dp[i] = dp[i-1] + dp[i-2]（和爬楼梯一样）<br>但本题比爬楼梯复杂在如下两点：</p><ul><li>对”0”的判断：0不能单独进行解码</li><li>对两个字符组合的判断：只有当1&lt;=s[i-1…i]&lt;=26，这两个字符才可以一起解码</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//合法的编码第一位不可能是0</span><br>    <span class="hljs-keyword">if</span>(s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//dp[i]为s中前i个字符的解码方法个数</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= s.length(); i++)&#123;<br>        <span class="hljs-comment">//one为单个位解码所表示的数字，two为两位一起解码所表示的数字</span><br>        <span class="hljs-keyword">int</span> one = Integer.valueOf(s.substring(i - <span class="hljs-number">1</span>, i));<br>        <span class="hljs-keyword">int</span> two = Integer.valueOf(s.substring(i - <span class="hljs-number">2</span>, i));<br>        <span class="hljs-comment">//单个位能解码的前提是:这个位上不是0</span><br>        <span class="hljs-keyword">if</span>(one != <span class="hljs-number">0</span>)<br>            dp[i] += dp[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//两个位能一起解码的前提是：两个位所表示的数字小于26并且第一个位不能是0</span><br>        <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">2</span>) != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; two &lt;= <span class="hljs-number">26</span>)<br>            dp[i] += dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.length()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】70.爬楼梯</title>
    <link href="/2021/02/19/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2021/02/19/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h1><p><strong>题目：</strong><br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><p>示例 1：<br>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。  </p><ol><li> 1 阶 + 1 阶  </li><li> 2 阶  </li></ol><p>示例 2：<br>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。  </p><ol><li> 1 阶 + 1 阶 + 1 阶  </li><li> 1 阶 + 2 阶   </li><li> 2 阶 + 1 阶  </li></ol><p><strong>思路：</strong>  </p><blockquote><p>爬楼梯问题的本质是斐波那契数列，设对于n层台阶，爬到楼顶的方法数为climbStairs(n)。分为两种情况，第一步跳1阶，第2步跳2阶，方法数分别为climbStairs(n-1),climbStairs(n-2)。则climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)。<br>但用递归的方法实现时，会产生很多的重复计算。因此可以采用迭代的方法。即采用自下而上的方法取代自上而下的方法。</p></blockquote><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//设对于n层台阶，爬到楼顶的方法数为climbStairs(n)</span><br>    <span class="hljs-comment">//分为两种情况，第一步跳1阶，第2步跳2阶，方法数分别为climbStairs(n-1),climbStairs(n-2)</span><br>    <span class="hljs-comment">//则climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;=n ; i++)<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">return</span> dp[n]; <br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】63.不同路径 II</title>
    <link href="/2021/02/19/63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <url>/2021/02/19/63.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    
    <content type="html"><![CDATA[<h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63.不同路径 II"></a>63.不同路径 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p><strong>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径</strong></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><pre><code>示例 1:输入:[  [0,0,0],  [0,1,0],  [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>本题源于[62.不同路径]，不同之处在于本题的网格中存在障碍物。由题易知，障碍物是不能涉足之地，设$dp[i,j]$为从左上角开始，到达点(i,j)的所有可能路径数。因此：</p><ul><li>如果一个点的上面和左面都没有障碍物，那么到达它可能的路径数目为：<br>  $$dp[i,j] = dp[i-1,j] + dp[i, j-1]$$</li><li>如果一个点的上面有障碍物，那么若想到达它，只能从左方到达,即：<br>  $$dp[i,j] = dp[i, j-1]$$</li><li>如果一个点的左面有障碍物，若想到达它，只能从上方到达,即：<br>  $$dp[i,j] = dp[i-1,j]$$  </li><li>如果一个点的上面和左面都有障碍物，那么该点对应的dp[i][j] = 0</li><li>base case：  <ul><li>正常来说第一行的点对应的dp[i,j]都是1。但如果第一行存在障碍物，那么障碍物右面的点对应的dp[i,j]是0</li><li>正常来说第一列的点对应的dp[i,j]都是1。但如果第一列存在障碍物，那么障碍物下面的点对应的dp[i,j]都是0</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] obstacleGrid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = obstacleGrid.length, m = obstacleGrid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || obstacleGrid[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>    <span class="hljs-comment">//以下设置base case(第一行和第一列)</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//以下两个变量分别记录第一行和第一列是否出现过障碍物</span><br>    <span class="hljs-keyword">boolean</span> row_flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> col_flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        col_flag = obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> ? <span class="hljs-keyword">true</span> : col_flag;<br>        dp[i][<span class="hljs-number">0</span>] = col_flag ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>        row_flag = obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span> ? <span class="hljs-keyword">true</span> : row_flag;<br>        dp[<span class="hljs-number">0</span>][j] = row_flag ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//以下填充dp数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>            <span class="hljs-keyword">if</span>(obstacleGrid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(obstacleGrid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>)<br>                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】62.不同路径</title>
    <link href="/2021/02/19/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/02/19/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><pre><code>示例 1:输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右</code></pre><p>注意：如果把网格看成矩阵的话，m为列数，n为行数</p><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><ul><li><p>设$dp[i,j]$为从左上角开始，到达点(i,j)的所有可能路径数。由题意可知，若想到达一个点，只能从该点的上方或者左方到达。因此有如下状态转移方程：<br>$$ dp[i,j] = dp[i-1,j] + dp[i, j-1]$$</p></li><li><p>确定base case:  </p><ul><li>对于网格第一列上的所有点(j = 0)，若想到达它，只能从上方到达,即：<br>$$ dp[i,j] = dp[i-1,j]$$  </li><li>对于网格第一行上的所有点(i = 0)，若想到达它，只能从左方到达,即：<br>$$dp[i,j] = dp[i, j-1]$$</li><li>对于网格左上角的点，dp[0,0] = 1;</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>    <span class="hljs-comment">//设置base case</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//填写dp数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法（数学）"><a href="#方法（数学）" class="headerlink" title="方法（数学）"></a>方法（数学）</h2><p>机器人要从左上角走到右下角，需要向右走n-1步，向下走m-1步，总共需要走m+n-2步。</p><p>我们要找路径数，也就是要找在这m + n - 2步中，选择n - 1步向右走的方案数。即：<br>$$<br>C_{m+n-2}^{n-1}=\frac{(m+n-2) !}{(n-1) !(n-1) !}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> N = n + m - <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        res = res * (N - (m - <span class="hljs-number">1</span>) + i) / i;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】53.最大子序和</title>
    <link href="/2021/02/19/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2021/02/19/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h1><p><strong>题目：</strong><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  </p><blockquote><p>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 </p></blockquote><p><strong>思路：</strong>  </p><blockquote><p>方法：用动态规划求解。<br>用函数f(i)表示以第i个数字结尾的子数组的最大和。<br>题目要求的是max[f(i)]<br>若i=0或f(i-1)&lt;=0,则f(i) = pData[i].<br>若i!=0并且f(i-1) &gt; 0, 则f(i) = pData[i] + f(i-1)</p></blockquote><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxSum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//pre表示以第i-1个数字结尾的子数组的最大和。将其初始化为nums[0]</span><br>        <span class="hljs-keyword">int</span> pre = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> cur;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-comment">//如果pre小于0，则以第i个数字结尾的子数组的最大值cur就是这个数字本身，不带上pre。更新maxSum</span><br>            <span class="hljs-keyword">if</span>(pre &lt;= <span class="hljs-number">0</span>)&#123;<br>                cur = nums[i];<br>                maxSum = Math.max(maxSum, cur);<br>            &#125;<br>            <span class="hljs-comment">//如果pre大于0,则以第i个数字结尾的子数组的最大值cur为以第i-1个数字结尾的子数组的最大和pre加上当前位置值。</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                cur = pre + nums[i];<br>                maxSum = Math.max(maxSum, cur);<br>            &#125;<br>            <span class="hljs-comment">//更新pre</span><br>            pre = cur;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】5.最长回文子串</title>
    <link href="/2021/02/19/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/19/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre><code>示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><h2 id="方法一（动态规划）"><a href="#方法一（动态规划）" class="headerlink" title="方法一（动态规划）"></a>方法一（动态规划）</h2><p>一个长度大于2的回文串，去掉首尾两个字母后仍然是一个回文串。<br>用dp[i][j]表示字符串s的第i到j个字母组成的串是否为回文串。即有动态规划状态转移方程</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span><br></code></pre></td></tr></table></figure><p>意为：如果从i+1到j-1的一个子串是回文串，并且s[i]和s[j]相等，则从i到j的子串也是回文串<br>接下来考虑边界条件：（回文串长度小于等于2时）  </p><ul><li>s长度为1：肯定为回文串</li><li>s长度为2：判断s[i]和s[j]是否相等  </li></ul><p>由于在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，所以要先遍历j，再遍历i。在遍历的过程中不断更新max_len，即可获得最长回文子串长度j-i+1和起始位置start。</p><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-comment">//dp[i][j]表示字符串s的第i到j个字母组成的串是否为回文串</span><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[length][length];<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//max_len记录最长回文子串的长度</span><br>        <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>                <span class="hljs-comment">//i必须小于j，因此当i大于j时可以直接continue跳过不处理</span><br>                <span class="hljs-keyword">if</span>(i &gt; j)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">//长度为1的子串肯定是回文串</span><br>                <span class="hljs-keyword">if</span>(i == j)<br>                    dp[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//子串长度为2并且i和j对应的字符相等时，为回文字符串</span><br>                <span class="hljs-keyword">if</span>(j == i + <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = s.charAt(i) == s.charAt(j);<br>                &#125;<br>                <span class="hljs-comment">//子串长度大于2时，依据动态规划的状态转移方程判断</span><br>                <span class="hljs-keyword">if</span>(j - i &gt; <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j);<br>                &#125;<br>                <span class="hljs-comment">//更新回文子串的最长长度max_len以及这个子串的起始位置start</span><br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="hljs-number">1</span> &gt; max_len)&#123;<br>                    max_len = j-i+<span class="hljs-number">1</span>;<br>                    start = i;<br>                &#125; <br>            &#125;<br>        &#125;<br>        String res = <span class="hljs-keyword">new</span> String(s.toCharArray(), start, max_len);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：方法toCharArray()将s转换为一个字符数组，该字符数组中存放了当前字符串中的所有char类型字符。</p><h2 id="方法二（中心扩展法）"><a href="#方法二（中心扩展法）" class="headerlink" title="方法二（中心扩展法）"></a>方法二（中心扩展法）</h2><p>字符串s可能有2N - 1个可能的中心，其中：</p><ul><li>每个单字符都可能作为中心扩展出长度为奇数的回文串，这种情况有N种。</li><li>每一对相邻的双字符也可能作为中心扩展出长度为偶数的回文串，这种情况有N - 1种</li></ul><p>对每一个中心都尽可能地尝试向外扩展，找到能扩出的最长长度以及其对应的最长回文串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res_left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res_right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * s.length() - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">int</span> left = i / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> right = i / <span class="hljs-number">2</span> + i % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;<br>            left--;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = right - left - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(len &gt; maxLen)&#123;<br>            maxLen = len;<br>            res_left = left + <span class="hljs-number">1</span>;<br>            res_right = right - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(res_left, res_right + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】22.括号生成</title>
    <link href="/2021/02/18/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2021/02/18/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><pre><code>示例：输入：n = 3输出：[    &quot;((()))&quot;,    &quot;(()())&quot;,    &quot;(())()&quot;,    &quot;()(())&quot;,    &quot;()()()&quot;    ]</code></pre><h2 id="方法（回溯法）"><a href="#方法（回溯法）" class="headerlink" title="方法（回溯法）"></a>方法（回溯法）</h2><p>对于回溯法，需要重点关注三点：</p><ul><li><p>结束条件：起初我们手中有n个左括号和n个右括号，当左括号和右括号都用完时，递归结束。将路径字符串加入res</p></li><li><p>选择：在每一步中我们都有两个选择：选一个左括号或选一个右括号。但是也有以下前提条件：</p><ul><li>能够选左括号的前提：左括号数量大于0</li><li>能够选右括号的前提：已使用的左括号数量大于已使用的右括号数量。（产生右括号时，前面如果没有足够的左括号与之匹配，则会产生不合理的字符串结果），即左括号剩余数量left要大于右括号剩余数量right。</li></ul><p>在做选择时，考虑以上两个条件，即可实现剪枝操作。</p></li><li><p>路径：路径内容应该包括：已产生的字符串path，剩余的左括号left以及剩余的右括号right。</p></li></ul><p>例如，n=2时，可以画出决策树如下：<br><img src="/img/22.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        backtrack(<span class="hljs-keyword">new</span> StringBuilder(), n, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(StringBuilder path, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> String(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//选择1：使用左括号</span><br>        <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span>)&#123;<br>            path.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtrack(path, left - <span class="hljs-number">1</span>, right);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//选择2：使用右括号</span><br>        <span class="hljs-keyword">if</span>(left &lt; right &amp;&amp; right &gt; <span class="hljs-number">0</span>)&#123;<br>            path.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtrack(path, left, right - <span class="hljs-number">1</span>);<br>            path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】39.组合总和</title>
    <link href="/2021/02/18/39.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2021/02/18/39.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：<br> 所有数字（包括 target）都是正整数。<br> 解集不能包含重复的组合。 </p><pre><code>示例 1：输入：candidates = [2,3,6,7], target = 7,所求解集为：[[7],[2,2,3]]示例 2：输入：candidates = [2,3,5], target = 8,所求解集为：[  [2,2,2,2],  [2,3,3],  [3,5]]</code></pre><h2 id="方法（回溯法）"><a href="#方法（回溯法）" class="headerlink" title="方法（回溯法）"></a>方法（回溯法）</h2><p>对于回溯法，需要重点考虑三个问题：</p><ul><li>路径：目前为止已经做出的选择</li><li>选择列表：当前可以做的选择</li><li>结束条件：到达决策树的叶节点时，无法再继续做选择，结束。</li></ul><p>以上述的示例1为例，画出本题的决策树如下（引用自<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419的leetcode题解</a>）</p><p><img src="/img/39-1.png"></p><p>在分支箭头上的数字表示已经做出的选择，即路径。节点中的数字表示当前的target。当target为0时，即找到了一个正确路径。</p><p>以上的决策树有4个为0的叶节点，按理说结果数组中应该有4个路径[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]。但是正确的输出只包含两个[2, 2, 3][7]。可以发现原来是[2, 2, 3], [2, 3, 2], [3, 2, 2]这三个路径中的元素相同，而题目要求的解中不应包含重复的组合。</p><p>为什么会产生重复呢？<br>题目中说candidates中的数字可以无限制重复被选取。因此我们在每一个节点做选择的时候，考虑了所有的候选数。比如说在节点4处，即使该层的上一个节点5搜索过包括2的全部的情况，在4处做选择的时候，依然可以选择2。造成了重复。</p><p>因此我们要在搜索的过程中就进行去重操作：具体的做法是：在每一次做选择的时候，设置一个选择的起点start，只能选择candidants数组中start及其之后的元素。</p><p>如下图所示：即从每一层的第 2 个结点开始，都不能再搜索产生同一层结点已经使用过的 candidate 里的元素。（引用自<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419的leetcode题解</a>）</p><p><img src="/img39-2.png"></p><h3 id="used数组和start变量适用情况的区别："><a href="#used数组和start变量适用情况的区别：" class="headerlink" title="used数组和start变量适用情况的区别："></a>used数组和start变量适用情况的区别：</h3><p>（引用自<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419的leetcode题解</a>）</p><ul><li>排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；</li><li>组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 start 变量。</li></ul><p>补充：used数组用在元素只能使用一次的情况下，而当遍历到一个元素时，如果只需要向后搜索其后面的元素，不再需要考虑前面的元素时，用start变量。</p><p>在理清上述的逻辑之后，我们下一步考虑剪枝操作：我们先对数组candidates排序，则排序后candidates[start]即为我们当前可以选择的最小的元素。如果target小于candidates[start]，那么即使我们选择最小的那个元素，下一步的target都会产生一个负数，不可能得到正确的组合，因此直接返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        Arrays.sort(candidates);<br>        backtrack(candidates, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//剪枝操作</span><br>        <span class="hljs-keyword">if</span>(target &lt; candidates[start])<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;<br>            <span class="hljs-comment">//进行选择</span><br>            path.add(candidates[i]);<br>            <span class="hljs-comment">//根据做出的选择，进入下一个节点</span><br>            <span class="hljs-comment">//这里的start参数之所以是i而不是i+1，是因为即使选择了candidates[i]，在不同层的下一个节点依然可以再重复地选择它。</span><br>            backtrack(candidates, i, target - candidates[i]);<br>            <span class="hljs-comment">//撤销选择</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h1><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><pre><code>说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 示例 1:输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>这道题同时满足：</p><ul><li>在一个组合中，candidates中的每个数字只能使用一次。</li><li>组合问题：例如：数组[1,2,3]，遍历到1时，包含1的所有结果已经被搜索完毕。遍历到2时就不需要再考虑前面的1，只需要向后搜索即可.</li></ul><p>因此需要同时使用used数组和start变量。</p><p>而给定的candidates数组中包含重复变量，为了避免重复的结果。必须先排序后再剪枝，具体的剪枝操作为：遇到决策树中同一层中的相同元素时，剪枝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] candidates;<br>    <span class="hljs-keyword">int</span> target;<br>    <span class="hljs-keyword">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">this</span>.candidates = candidates;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[candidates.length];<br>        <span class="hljs-comment">//排序使得重复的元素彼此相邻</span><br>        Arrays.sort(candidates);<br>        backtrack(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; path, <span class="hljs-keyword">int</span> sum)</span></span>&#123;<br>        <span class="hljs-comment">//以下两个if判断为终止条件</span><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(start == candidates.length)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//以下if判断为剪枝操作</span><br>        <span class="hljs-keyword">if</span>(sum &gt; target || candidates[start] &gt; target - sum)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;<br>            <span class="hljs-comment">//当重复的元素在决策树的同一层时，剪枝</span><br>            <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            used[i] = <span class="hljs-keyword">true</span>;<br>            backtrack(i + <span class="hljs-number">1</span>, path, sum + candidates[i]);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419的leetcode题解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】46.全排列</title>
    <link href="/2021/02/18/46.%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2021/02/18/46.%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><pre><code>示例:输入: [1,2,3]输出:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><h2 id="方法（回溯法）"><a href="#方法（回溯法）" class="headerlink" title="方法（回溯法）"></a>方法（回溯法）</h2><p>对于回溯法，需要重点考虑三个问题：</p><ul><li>路径：目前为止已经做出的选择</li><li>选择列表：当前可以做的选择</li><li>结束条件：到达决策树的叶节点时，无法再继续做选择，结束。</li></ul><p>通常回溯法适合用递归来实现。当我们到达一个节点时，尝试所有可能的选择。</p><ul><li>在做出一个选择之后，将该选择从选择列表中移除，并向路径中添加该选择。</li><li>之后递归进入下一个节点。</li><li>递归退出后再撤销刚才的选择，向选择列表中再加回此选择，再将选择从路径中移除。</li></ul><p>下图表示了本题对应的决策树：</p><p><img src="/img/46.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; path)</span></span>&#123;<br>    <span class="hljs-comment">//满足结束条件时，向结果数组中添加当前路径。</span><br>    <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//如果当前路径中已包含元素nums[i]，则是非法的选择，直接跳过。</span><br>        <span class="hljs-keyword">if</span>(used[i])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//做选择</span><br>        path.add(nums[i]);<br>        used[i] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//进入递归</span><br>        backtrack(nums, path);<br>        <span class="hljs-comment">//撤销选择</span><br>        uesd[i] = <span class="hljs-keyword">false</span>;<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h2><p>这里引用了<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban">labuladong的回溯算法详解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">res = []<br><span class="hljs-function">def <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span>:</span><br><span class="hljs-function">    <span class="hljs-keyword">if</span> 满足结束条件:</span><br><span class="hljs-function">        res.<span class="hljs-title">append</span><span class="hljs-params">(路径)</span></span><br><span class="hljs-function">        return  </span><br><span class="hljs-function">        </span><br><span class="hljs-function">    <span class="hljs-keyword">if</span> 满足剪枝条件：</span><br><span class="hljs-function">    return</span><br><span class="hljs-function">    </span><br><span class="hljs-function">    <span class="hljs-keyword">for</span> 选择 in 选择列表:</span><br><span class="hljs-function">        做选择</span><br><span class="hljs-function">        <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span><br><span class="hljs-function">        撤销选择</span><br></code></pre></td></tr></table></figure><h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><pre><code>示例:输入: [1,1,2]输出:[[1,1,2],[1,2,1],[2,1,1]]</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>本题和全排列的第一题不同在于，本题中给定的数组包含重复数字。因此需要进行剪枝操作。</p><p>为了让重复的数字彼此相邻，我们先对给定数组进行排序。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        Arrays.sort(nums);<br>        backtrack(nums, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; path)</span></span>&#123;<br>        <span class="hljs-comment">//满足结束条件时，向结果数组中添加当前路径。</span><br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//剪枝条件</span><br>            <span class="hljs-comment">//i &gt; 0是为了保证i-1有意义</span><br>            <span class="hljs-comment">//nums[i] == nums[i - 1]即当遇到重复元素时，剪枝</span><br>            <span class="hljs-comment">//!used[i - 1]是为了保证之前和当前节点相同的那个元素刚刚撤销了选择</span><br>            <span class="hljs-comment">//如果</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <br>                <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-keyword">true</span>;<br>            backtrack(nums, path);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】52.N皇后 II</title>
    <link href="/2021/02/18/51.%20N%E7%9A%87%E5%90%8E/"/>
    <url>/2021/02/18/51.%20N%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a>52. N皇后 II</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><pre><code>示例:输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]</code></pre><p>提示：</p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h2 id="方法-回溯法"><a href="#方法-回溯法" class="headerlink" title="方法(回溯法)"></a>方法(回溯法)</h2><p>因为在每一行都有在0到n-1中的哪一列放皇后这n种选择，进行完这次选择之后，在下一行又会面临同样的选择，因此考虑用回溯法。</p><p>回溯法需要考虑三件事：路径、选择、结束条件：</p><ul><li>路径：也即棋盘（只有经过的行放好了皇后）</li><li>选择：该行的n个位置，除了与其他皇后有冲突的位置，剩下的位置都可以作为放皇后的选择。</li><li>结束条件：棋盘上所有的行都已经放好了皇后</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//构建并初始化象棋棋盘,初始化时所有位置都没有皇后</span><br>        String[][] board = <span class="hljs-keyword">new</span> String[n][n];<br>        <span class="hljs-keyword">for</span> (String[] strings : board) <br>            Arrays.fill(strings, <span class="hljs-string">&quot;.&quot;</span>);<br>        backtrack(board, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(String[][] board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span> (board.length == row) &#123;<br>            res++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; board[row].length; col++) &#123;<br>            <span class="hljs-comment">//剪枝:如果board[row][col]不能放置皇后，则跳过</span><br>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) <br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            board[row][col] = <span class="hljs-string">&quot;Q&quot;</span>;<br>            <span class="hljs-comment">//进入下一行</span><br>            backtrack(board, row + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤销选择</span><br>            board[row][col] = <span class="hljs-string">&quot;.&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否可以在board[row][col]处放置皇后</span><br>    <span class="hljs-comment">//注：任何两个皇后都不能处于同一条横行、纵行或斜线上。</span><br>    <span class="hljs-comment">//由于我们在做选择时，每一横行只放了一个皇后，因此只需要判断纵行和斜线即可。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>        <span class="hljs-comment">//因为我们从上到下在每一行上放置皇后，因此只需要考虑小于row的行上有没有皇后冲突即可。</span><br>        <span class="hljs-comment">//检查同一列是否有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col].equals(<span class="hljs-string">&quot;Q&quot;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查左上的斜线上有没有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j].equals(<span class="hljs-string">&quot;Q&quot;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查右上的斜线上有没有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board.length; i--, j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j].equals(<span class="hljs-string">&quot;Q&quot;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><pre><code>示例：输入：4输出：[[&quot;.Q..&quot;,  // 解法 1&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,  // 解法 2&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><p>提示：</p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h2 id="方法（回溯法）"><a href="#方法（回溯法）" class="headerlink" title="方法（回溯法）"></a>方法（回溯法）</h2><p>方法大体与上一道题相同，只是输出不同。具体见以下代码。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>        <span class="hljs-comment">//构建并初始化象棋棋盘,初始化时所有位置都没有皇后</span><br>        String[][] board = <span class="hljs-keyword">new</span> String[n][n];<br>        <span class="hljs-keyword">for</span> (String[] strings : board) <br>            Arrays.fill(strings, <span class="hljs-string">&quot;.&quot;</span>);<br>        backtrack(board, <span class="hljs-number">0</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(String[][] board, <span class="hljs-keyword">int</span> row, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span> (board.length == row) &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>                String temp = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++)<br>                    temp += board[i][j];<br>                list.add(temp);<br>            &#125;<br>            result.add(list);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; board[row].length; col++) &#123;<br>            <span class="hljs-comment">//剪枝:如果board[row][col]不能放置皇后，则跳过</span><br>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) <br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            board[row][col] = <span class="hljs-string">&quot;Q&quot;</span>;<br>            <span class="hljs-comment">//进入下一行</span><br>            backtrack(board, row + <span class="hljs-number">1</span>, result);<br>            <span class="hljs-comment">//撤销选择</span><br>            board[row][col] = <span class="hljs-string">&quot;.&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>        <span class="hljs-comment">//检查同一列是否有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col].equals(<span class="hljs-string">&quot;Q&quot;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查左上的斜线上有没有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j].equals(<span class="hljs-string">&quot;Q&quot;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查右上的斜线上有没有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board.length; i--, j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j].equals(<span class="hljs-string">&quot;Q&quot;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】79.单词搜索</title>
    <link href="/2021/02/18/79.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/02/18/79.%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.单词搜索</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p> </p><pre><code>示例:board =[[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],[&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],[&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false</code></pre><h2 id="方法（回溯算法）"><a href="#方法（回溯算法）" class="headerlink" title="方法（回溯算法）"></a>方法（回溯算法）</h2><p>回溯法需要重点考察三个内容：</p><ul><li>路径：记录我们当前匹配到了word中的哪个字符。我们用index表示当前匹配到的word字符的索引。</li><li>结束条件：当匹配到了word中的最后一个字符并且匹配成功时，回溯结束，返回true</li><li>选择：由于同一个单元格中的字母不能被重复使用，因此我们用一个矩阵uesd记录位置[i,j]上的字符是否被使用过。如果board的当前位置[i,j]上的字符与word的index位置上的字符匹配，那么就做选择（使用[i,j]位置上的元素）。做完选择之后，我们递归匹配board中的下一个位置字符是否与word的index+1位置上的字符匹配（下一个位置有上下左右四种可能的情况，如果这个下一个位置已经使用过，那么剪枝即可），最后撤销选择。</li></ul><p>具体见代码注释</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[][] board;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[][] used;<br>    <span class="hljs-keyword">private</span> String word;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//代表往上下左右四个方向走</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.board = board;<br>        <span class="hljs-keyword">this</span>.word = word;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-comment">//以board矩阵中的每一个位置为起点开始，尝试能否和word匹配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(backtrack(i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span>(board[i][j] != word.charAt(index))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index == word.length() - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果该位置元素和word中index位置上的元素相等，那么做选择（使用这个位置的元素）</span><br>        used[i][j] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//递归匹配下一个位置：下一个位置有上下左右四种情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] dir : direction)&#123;<br>            <span class="hljs-comment">//newi和newj为下一个位置的坐标</span><br>            <span class="hljs-keyword">int</span> newi = i + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> newj = j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//下一个位置的坐标不能越界</span><br>            <span class="hljs-keyword">if</span>(newi &gt;= <span class="hljs-number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="hljs-number">0</span> &amp;&amp; newj &lt; board[<span class="hljs-number">0</span>].length)&#123;<br>                <span class="hljs-comment">//如果下一个位置已经使用过，就直接跳过</span><br>                <span class="hljs-keyword">if</span>(used[newi][newj])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(backtrack(newi, newj, index + <span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-comment">//撤销选择</span><br>        used[i][j] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】93.复原IP地址</title>
    <link href="/2021/02/18/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2021/02/18/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#64;&#x31;&#46;&#x31;">&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#64;&#x31;&#46;&#x31;</a>“ 是 无效的 IP 地址。</p><p> </p><pre><code>示例 1：输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]示例 2：输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;]示例 3：输入：s = &quot;1111&quot;输出：[&quot;1.1.1.1&quot;]示例 4：输入：s = &quot;010010&quot;输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]示例 5：输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></pre><h2 id="方法（暴力法）"><a href="#方法（暴力法）" class="headerlink" title="方法（暴力法）"></a>方法（暴力法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span> || s.length() &gt; <span class="hljs-number">12</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    StringBuffer ip = <span class="hljs-keyword">new</span> StringBuffer();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; a &lt; <span class="hljs-number">4</span>; a++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>; b &lt; a + <span class="hljs-number">4</span>; b++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = b + <span class="hljs-number">1</span>; c &lt; s.length(); c++)&#123;<br>                <span class="hljs-keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="hljs-number">0</span>, a));<br>                <span class="hljs-keyword">int</span> n2 = Integer.parseInt(s.substring(a, b));<br>                <span class="hljs-keyword">int</span> n3 = Integer.parseInt(s.substring(b, c));<br>                <span class="hljs-keyword">int</span> n4 = Integer.parseInt(s.substring(c, s.length()));<br>                <span class="hljs-keyword">if</span>(n1 &lt;= <span class="hljs-number">255</span> &amp;&amp; n2 &lt;= <span class="hljs-number">255</span> &amp;&amp; n3 &lt;= <span class="hljs-number">255</span> &amp;&amp; n4 &lt;= <span class="hljs-number">255</span>)<br>                    ip.append(n1).append(<span class="hljs-string">&quot;.&quot;</span>).append(n2).append(<span class="hljs-string">&quot;.&quot;</span>).append(n3).append(<span class="hljs-string">&quot;.&quot;</span>).append(n4);<br>                <span class="hljs-keyword">if</span>(ip.length() == s.length() + <span class="hljs-number">3</span>)<br>                    res.add(ip.toString());<br>                ip.delete(<span class="hljs-number">0</span>, ip.length());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法（回溯法）"><a href="#方法（回溯法）" class="headerlink" title="方法（回溯法）"></a>方法（回溯法）</h2><ul><li>递归终止条件：当遍历完S的每一位时，如果已经切分好了IP地址的四段，那么将切分好的IP地址加入结果。否则直接返回。</li><li>选择：在每一个位置都有三种选择：截取当前位置和后1位作为IP地址中的一段、截取当前位置和后2位作为IP地址中的一段、截取当前位置和后3位作为IP地址中的一段</li><li>路径：用一个列表记录分割成的IP地址的每一段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; res;<br>String s;<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.s = s;<br>    res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">12</span> || s.length() &lt; <span class="hljs-number">4</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    List&lt;String&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//start代表从哪个位置开始回溯</span><br><span class="hljs-comment">//cutNum代表已经分割了IP地址中的多少段（最多为4段）</span><br><span class="hljs-comment">//path记录当前分割成的IP地址中的每一段</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> cutNum, List&lt;String&gt; path)</span></span>&#123;<br>    <span class="hljs-comment">//终止条件</span><br>    <span class="hljs-keyword">if</span>(start == s.length())&#123;<br>        <span class="hljs-keyword">if</span>(cutNum == <span class="hljs-number">4</span>)<br>            res.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, path));<br>    &#125;<br>    <span class="hljs-comment">//在每一个结点处可以选择截取的方法只有 3 种：向后截 1 位、截 2 位、截 3 位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt; start + <span class="hljs-number">3</span>; i++)&#123;<br>        <span class="hljs-comment">//一下两个if判断为剪枝条件</span><br>        <span class="hljs-keyword">if</span>(i &gt; s.length())<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">4</span> - cutNum) * <span class="hljs-number">3</span> &lt; s.length() - i)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(validIPsegment(start, i))&#123;<br>            String temp = s.substring(start, i + <span class="hljs-number">1</span>);<br>            path.add(temp);<br>            backtrack(i + <span class="hljs-number">1</span>, cutNum + <span class="hljs-number">1</span>, path);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//判断S中从left到right中间的部分是否是合法的IP地址段</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validIPsegment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((left &lt; right &amp;&amp; s.charAt(left) == <span class="hljs-string">&#x27;0&#x27;</span>) || right &gt;= s.length())<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++)&#123;<br>        count = count * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count &gt;= <span class="hljs-number">0</span> &amp;&amp; count &lt;= <span class="hljs-number">255</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/hui-su-suan-fa-hua-tu-fen-xi-jian-zhi-tiao-jian-by/">Leetcode题解区</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】167.两数之和 II - 输入有序数组</title>
    <link href="/2021/02/18/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/18/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h1><p><strong>题目：</strong><br>给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1必须小于index2。</p><p>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p><p><strong>思路：双指针法</strong><br>定义两个指针left和right，初始化时分别指向数组的两端<br>如果left和right对应的值加起来等于target，那么可直接返回。因为数组是排序好的，如果和小于target，也即希望和大一些，所以将left右移一位。如果和大于target，也即希望和小一些，所以将right左移一位。如此进行循环直到找到相等的时候，若找不到则返回null</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span>(numbers == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = numbers.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] == target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] &lt; target)<br>            left++;<br>        <span class="hljs-keyword">else</span><br>            right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】11.盛水最多的容器</title>
    <link href="/2021/02/18/11.%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/02/18/11.%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11 盛水最多的容器"></a>11 盛水最多的容器</h1><p><strong>题目：</strong><br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p>示例：<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p><p><strong>思路：双指针法</strong><br>水的面积为左柱子和右柱子中高度的最小值乘上两个柱子之间的距离。最开始将左右柱子分别设为最左边和最右边的柱子，此时两柱子间的距离是最大的，但两柱子的高度未必是。记下当前的面积，之后不断将两柱子向内移动，并同时更新最大面积。当两柱子相遇时，代表所有有可能产生最大面积的柱子组合都被尝试完毕，此时返回最大面积。</p><p>但两柱子具体是怎样移动的呢？考虑将两柱子向内移动意味着两根柱子之间的距离不断地缩小,所以要达到最大面积，必然寄希望于移动后两根柱子中的最小值大于当前两柱子中的最小值。如果较短的柱子不移动，两柱子高度的最小值则不变化，但两柱子间距变小了，这种情况肯定不可能得到更大的面积，所以这种情况就不必尝试。   </p><p>每次将两柱子中较短的那个柱子向内移动，较长的柱子不移动。这种情况移动后可能产生更大面积，也可能不会产生更大面积。但每一次尝试都将当前的面积与之前保存的最大面积比较，并更新最大面积，这样就可以通过不断尝试获得最大面积。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> max_area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">int</span> cur_area = Math.min(height[left],height[right]) * (right - left);<br>        max_area = Math.max(max_area, cur_area);<br>        <span class="hljs-keyword">if</span>(height[left] &lt; height[right])<br>            left++;<br>        <span class="hljs-keyword">else</span><br>            right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_area;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】131.分割回文串</title>
    <link href="/2021/02/18/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <url>/2021/02/18/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><pre><code>示例:输入: &quot;aab&quot;输出:[[&quot;aa&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><h2 id="方法（回溯）"><a href="#方法（回溯）" class="headerlink" title="方法（回溯）"></a>方法（回溯）</h2><ul><li>选择: 在决策树的每一个节点。我们可以做的选择为：只截取当前字符、截取当前字符和后一个字符、截取当前字符和后两个字符……截取当前字符和之后所有的字符。截取之后进行是否是回文的判断，如果是回文，则就是一个合理的选择。</li><li>路径：记录结果的path列表。</li><li>终止条件：遍历完了字符串s的每一个节点。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>String s;<br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;<br>    <span class="hljs-keyword">this</span>.s = s;<br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> LinkedList&lt;&gt;());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;String&gt; path)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start == s.length())&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(!isPalindrome(start, i))<br>            <span class="hljs-keyword">continue</span>;<br>        path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>        backtrack(i + <span class="hljs-number">1</span>, path);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> &amp;&amp; end &gt; s.length() - <span class="hljs-number">1</span> &amp;&amp; start &gt;= end)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> left = start;<br>    <span class="hljs-keyword">int</span> right = end;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(left) != s.charAt(right))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】179.最大数</title>
    <link href="/2021/02/18/179.%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <url>/2021/02/18/179.%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179.最大数"></a>179.最大数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><pre><code>示例 1:输入: [10,2]输出: 210示例 2:输入: [3,30,34,5,9]输出: 9534330</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>先创建一个字符串数组strs，用来保存各数字的字符串格式</p></li><li><p>应用以下排序判断规则，对strs进行排序：  </p><ul><li>若拼接字符串 $x+y &gt; y+x, 则x大于y$</li><li>若拼接字符串 $x+y &lt; y+x, 则x小于y$</li><li>例如：”330” &gt; “303”,则3大于30</li></ul><p>注意处理”0”的情况</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">largestNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br>        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            strs[i] = String.valueOf(nums[i]);<br>        &#125;<br>        Arrays.sort(strs, <span class="hljs-keyword">new</span> MyComparator());<br>        <span class="hljs-keyword">if</span>(strs[strs.length - <span class="hljs-number">1</span>].equals(<span class="hljs-string">&quot;0&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-comment">//Arrays.sort默认是从小到大排序，因此我们从排序后的字符串数组中从后向前依次读出大数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            res += strs[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> (o1 + o2).compareTo(o2 + o1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】208.实现Trie树（前缀树）</title>
    <link href="/2021/02/18/208.%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/"/>
    <url>/2021/02/18/208.%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="208-实现Trie树（前缀树）"><a href="#208-实现Trie树（前缀树）" class="headerlink" title="208. 实现Trie树（前缀树）"></a>208. 实现Trie树（前缀树）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:</p><pre><code>Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 truetrie.search(&quot;app&quot;);     // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;);   trie.search(&quot;app&quot;);     // 返回 true</code></pre><p>说明:</p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Trie树又叫前缀树又叫单词查找树，它的每个节点既不包含字符串，也不包含字符串中的某一个字符，它仅保存一个链接数组和一个boolean类型的值isEnd（标记是否有字符串以它结尾）。</p><p><img src="/img/208.%E5%9B%BE1.jpg"></p><p>以本题为例，一个节点会有26个子节点。<br><strong>一个节点表示的字符是c，等价于这个节点与字符c对应的子节点非空</strong></p><h3 id="Trie树的插入"><a href="#Trie树的插入" class="headerlink" title="Trie树的插入"></a>Trie树的插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span></span>&#123;<br>    TrieNode node = root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word.toCharArray())&#123;<br>        <span class="hljs-comment">//如果没有字符c，就建立与字符c对应的节点</span><br>        <span class="hljs-keyword">if</span>(node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>            node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>        node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    node.isEnd = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Trie树的查找"><a href="#Trie树的查找" class="headerlink" title="Trie树的查找"></a>Trie树的查找</h3><p>从根节点的子节点开始一直向下匹配字符串中的字符c，如果出现null说明匹配失败，返回false。如果匹配到了最后一个字符，说明该字符串的所有字符都能在Trie树中匹配，这是只需检查字符串是否以当前node结尾即可。（例如，word为”sea”,Trie树中含有字符串”seal”,那么即使sea这三个字符都能在Trie树中匹配成功，但是a对应的节点的isEnd为false，那么依然匹配失败）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span></span>&#123;<br>    TrieNode node = root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word.toCharArray())&#123;<br>        node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node.isEnd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Tire树的前缀匹配"><a href="#Tire树的前缀匹配" class="headerlink" title="Tire树的前缀匹配"></a>Tire树的前缀匹配</h3><p>大体上和search操作类似，只是无需判断最后一个字符对应节点的isEnd。因为既然能遍历到最后一个字符，说明前面的字符都匹配成功，Trie树中一定有单词是以该字符串为前缀的。</p><p>例如上面的例子:匹配完字符串”sea”,说明sea着三个字符都在Trie树中匹配成功，那么不管a是否是一个Trie树中字符串的结尾，都返回True。（因为Trie中虽没有sea，但有以它为前缀的seal）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span></span>&#123;<br>    TrieNode node = root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : prefix.toCharArray())&#123;<br>        node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Trie树的大小"><a href="#Trie树的大小" class="headerlink" title="Trie树的大小"></a>Trie树的大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以x为根节点的单词查找树中的单词个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(TrieNode x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(x.isEnd)<br>        count++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">26</span>; c++)<br>        count += size(x.next[c]);<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br>        <span class="hljs-keyword">private</span> TrieNode[] next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span></span>&#123;<br>            isEnd = <span class="hljs-keyword">false</span>;<br>            next = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>        root = <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span></span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)<br>                node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>            node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span></span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word.toCharArray())&#123;<br>            node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node.isEnd;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span></span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : prefix.toCharArray())&#123;<br>            node = node.next[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//以x为根节点的单词查找树中的单词个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(TrieNode x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x.isEnd)<br>            count++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">26</span>; c++)<br>            count += size(x.next[c]);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】202.快乐数</title>
    <link href="/2021/02/18/202.%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <url>/2021/02/18/202.%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：<br>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1  </p><h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p>只会有以下可能的情况：</p><ul><li>最终得到1</li><li>最终走进循环</li><li>数越来越大趋近于无穷（但其实不可能，因为即使是最大的三位数999的下一个数也只能是243</li></ul><p>所以只有前两种情况可能出现，只需要判断最后是否进入循环即可。即是否出现过已经出现过的数字。分析到这里自然会想到用哈希（HashSet）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>分两部分实现<br>首先判断<strong>一个数字对应的下一个数是什么</strong>，这很容易，我们只需要提取出这个数字的每个位即可，之前也有过类似的题目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//此函数用来获得n的每个位上的数字的平方和</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>        sum += (n%<span class="hljs-number">10</span>) * (n%<span class="hljs-number">10</span>);<br>        n = n / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>其次，判断这个数是否已经在HashSet中，若不在将它加入，若要放入的数字已经在HashSet中，说明走进了循环，返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//只有两种情况，一种循环到1，另一种循环到已经到过的一个数，进入了一个环。前者为true，后者为false</span><br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-number">1</span> &amp;&amp; !seen.contains(n))&#123;<br>        seen.add(n);<br>        n = getsum(n);<br>    &#125;<br>    <span class="hljs-comment">//退出循环有两种情况</span><br>    <span class="hljs-comment">//1.已经循环到了1.</span><br>    <span class="hljs-comment">//2. 循环到了曾经走过的点</span><br>    <span class="hljs-keyword">return</span> n==<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意对于HahSet的操作:</strong>  </p><ul><li>加入元素：seen.==add==(n)</li><li>检查一个元素n是否在seen中：seen.==contains==(n)。此步只需要O(1)的时间复杂度  </li></ul><p><strong>时间复杂度和空间复杂度:</strong><br>都是O(logn)</p><h2 id="另一种方法：快慢指针法"><a href="#另一种方法：快慢指针法" class="headerlink" title="另一种方法：快慢指针法"></a>另一种方法：快慢指针法</h2><p>既然上述分析时考虑到了是否存在循环的问题，则可以用链表的思想来考虑。一个节点计算其各位平方再求和的过程可以类似于链表用next指针指向下一个节点。<br>于是可以用快慢指针检查是否出现了环</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean is<span class="hljs-constructor">Happy(<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> slowRunner = n;<br>    <span class="hljs-built_in">int</span> fastRunner = get<span class="hljs-constructor">Next(<span class="hljs-params">n</span>)</span>;<br>    <span class="hljs-keyword">while</span> (fastRunner != <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>slowRunner != fastRunner) &#123;<br>        <span class="hljs-comment">//以下两步可看作</span><br>        <span class="hljs-comment">//slowRunner = slowRunner.next;</span><br>        <span class="hljs-comment">//fastRunner = fastRunnr.next;</span><br>        slowRunner = get<span class="hljs-constructor">Next(<span class="hljs-params">slowRunner</span>)</span>;<br>        fastRunner = get<span class="hljs-constructor">Next(<span class="hljs-params">getNext</span>(<span class="hljs-params">fastRunner</span>)</span>);<br>    &#125;<br>    return fastRunner<span class="hljs-operator"> == </span><span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】205.同构字符串</title>
    <link href="/2021/02/18/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/02/18/205.%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><pre><code>示例 1:输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true示例 2:输入: s = &quot;foo&quot;, t = &quot;bar&quot;输出: false示例 3:输入: s = &quot;paper&quot;, t = &quot;title&quot;输出: true</code></pre><p>简单来说，同构的意思是结构相同。即若s和t是同构的，那么：</p><ul><li>s如果是ABB的结构，t也必须是ABB的结构</li><li>s如果是AABB的结构，t也必须是AABB的结构</li><li>以此类推</li></ul><h2 id="方法（用哈希表）"><a href="#方法（用哈希表）" class="headerlink" title="方法（用哈希表）"></a>方法（用哈希表）</h2><p>准备一个哈希表。用于将s中的一个字符映射到t中的一个字符。</p><p>算法步骤：</p><ul><li>遍历s中的每一个字符</li><li>如果s中的一个字符还未入哈希表（之前未出现过），但t中该位置的元素已作为value处在哈希表中（之前出现过），说明不同构，返回false。否则将该字符作为key，t中同位置的字符作为value，将这对(key, value)入哈希表。</li><li>如果s中的一个字符已经存在于哈希表中，那么就检查该字符在哈希表中的value值于t中同位置的字符是否相同，如果不同，说明s和t结构不同，直接返回false</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    HashMap&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">char</span>[] sChar = s.toCharArray();<br>    <span class="hljs-keyword">char</span>[] tChar = t.toCharArray();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(sChar[i]))&#123;<br>            <span class="hljs-comment">//如果s中该位置元素之前未出现过，但是t中该位置元素已出现过</span><br>            <span class="hljs-comment">//说明s和t不不同构，返回false。例如&quot;ab&quot;和&quot;aa&quot;</span><br>            <span class="hljs-keyword">if</span>(map.containsValue(tChar[i]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            map.put(sChar[i], tChar[i]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (map.get(sChar[i]) != tChar[i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】43.字符串相乘</title>
    <link href="/2021/02/18/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2021/02/18/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><pre><code>示例 1:输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot;示例 2:输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot;</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于这类题目，一定要想到大数溢出的情况。如果给定字符串num1和num2特别长，其自己也许都无法转换成int甚至long类型，更不用说让他们转换后再相乘了。所以这种办法行不通，必须要从对字符串的操作中寻找办法。</p><p>我们在小学时就学过字符串相乘，现在我们来回忆一下这个过程：例如对于123*45，我们会这样操作：让123先乘5，得到一个结果，再让123乘4得到另一个结果，两个结果相加即为乘法的结果。但如果123乘5这一步，如果数很大的话，还是可能溢出。因此我们的计算过程需要再简单一点，如下所示：</p><p><img src="/img/43.%E5%9B%BE1.png"></p><p>即：我们将num1和num2的每一个字符进行相乘，再错位进行相加得到结果。<br>这一用人类思维方式表示的计算过程，对于计算机来说需要这样组织：<br>定义两个指针i和j，分别指向num1和num2上的某一位置上的字符，计算这两个字符串的乘积，同时将乘积叠加到结果数组res上的正确位置（数组res用于在地下接收相加的结果）。</p><p>但res上哪个位置是与字符num1[i]和num2[j]的乘积有关的呢？仔细观察上述计算过程就可发现，num1[i]和num2[j]的乘积对应这数组中的i+j位置和i+j+1位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(num1.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> || num2.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    <span class="hljs-keyword">int</span> len1 = num1.length(), len2 = num2.length();<br>    <span class="hljs-comment">//定义结果数组并初始化（结果数组最多有len1+len2位数）</span><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + len2];<br>    Arrays.fill(res, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//从num1和num2的个位数开始逐个位相乘</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            <span class="hljs-comment">//mul为相乘的结果，由于是两个个位数相乘，mul最多为二位数。它的个位和十位分别影响res的i+j+1位和i+j位</span><br>            <span class="hljs-keyword">int</span> mul = (num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">int</span> p1 = i + j, p2 = i + j + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//用mul加上res的i + j + 1位上原有的值后，更新res数组。</span><br>            <span class="hljs-keyword">int</span> sum = mul + res[p2];<br>            res[p2] = sum % <span class="hljs-number">10</span>;<br>            res[p1] += sum / <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将结果数组转化为字符串</span><br>    String s = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++)<br>        s += (<span class="hljs-keyword">char</span>)(res[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-comment">//结果字符串前缀可能会有0，需要去掉</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(s.charAt(count) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; count &lt; res.length)<br>        count++;<br>    <span class="hljs-keyword">return</span> s.substring(count, s.length());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】459.重复的字符串</title>
    <link href="/2021/02/18/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/02/18/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="459-重复的字符串"><a href="#459-重复的字符串" class="headerlink" title="459. 重复的字符串"></a>459. 重复的字符串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><pre><code>示例 1:输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。示例 2:输入: &quot;aba&quot;输出: False示例 3:输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</code></pre><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>一个字符串若可以由它的子串重复多次构成，那么这个子串的长度只可能为1、2、3、…n/2，且字符串s的长度必须要是子串长度的倍数。我们只要分别进行如下判断即可：</p><ul><li>长度为1的子串能否重复多次构成字符串s</li><li>长度为2的子串能否重复多次构成字符串s</li><li>长度为3的子串能否重复多次构成字符串s</li><li>…….</li><li>长度为$n/2$的子串能否重复多次构成字符串s</li></ul><p>对于以上每种可能的情况，我们都需要遍历整个字符串，检查是否满足重复条件$s[j] == s[j - i]$ (其中，i为子串长度)。只要以上情况有一种满足，即可返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-comment">//i为可能的重复子串长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n/<span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-comment">//字符串长度必须要是子串长度的倍数</span><br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//flag用来记录长度为i的子串能否重复构成字符串</span><br>            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(j) != s.charAt(j - i))<br>                    flag = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>将两个s拼接到一起形成$s’$,然后在$s’$中寻找s（易知：如果某一重复子串能构成s，那么肯定也能构成$s’$）</p><ul><li>如果s不能由一子串重复构成，如”aba”,那么$s’$中只有两个s，在$s’:“abaaba”$中查找s，第一个出现s的位置必然是s的长度n</li><li>如果s能由一子串重复构成，如”abab”,那么$s’$中将不只有两个s（此例子中有3个），在$s’:“abababab”$中查找s，第一个出现s的位置肯定不是s的长度n</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (s + s).indexOf(s, <span class="hljs-number">1</span>) != s.length();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】468.验证IP地址</title>
    <link href="/2021/02/18/468.%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2021/02/18/468.%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="468-验证IP地址"><a href="#468-验证IP地址" class="headerlink" title="468.验证IP地址"></a>468.验证IP地址</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。</p><ul><li>如果是有效的 IPv4 地址，返回 “IPv4” ；</li><li>如果是有效的 IPv6 地址，返回 “IPv6” ；</li><li>如果不是上述类型的 IP 地址，返回 “Neither” 。</li></ul><p>IPv4 地址由十进制数和点来表示，每个地址包含<strong>4个十进制数</strong>，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；</p><p>IPv6 地址由 <strong>8 组 16 进制的数字</strong>来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址</p><p><strong>示例</strong></p><pre><code>示例 1：输入：IP = &quot;172.16.254.1&quot;输出：&quot;IPv4&quot;解释：有效的 IPv4 地址，返回 &quot;IPv4&quot;示例 2：输入：IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;输出：&quot;IPv6&quot;解释：有效的 IPv6 地址，返回 &quot;IPv6&quot;示例 3：输入：IP = &quot;256.256.256.256&quot;输出：&quot;Neither&quot;解释：既不是 IPv4 地址，又不是 IPv6 地址示例 4：输入：IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;输出：&quot;Neither&quot;示例 5：输入：IP = &quot;1e1.4.5.6&quot;输出：&quot;Neither&quot;</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于给定的字符串IP</p><ul><li>如果IP中有3个’.’那么其只可能是IPv4地址，不可能是IPv6地址，用validIPv4函数对其验证<ul><li>如果validIPv4返回true，那么是有效的IPv4地址，返回”IPv4”</li><li>否则，返回”Neither”</li></ul></li><li>如果IP中有7个’:’那么其只可能是IPv6地址，不可能是IPv4地址，用validIPv6函数对其验证<ul><li>如果validIPv6返回true，那么是有效的IPv6地址，返回”IPv6”</li><li>否则，返回”Neither”</li></ul></li><li>否则，IP不可能是有效的IPv4或IPv6地址，返回”Neither”</li></ul><p>validIPv4()函数：  </p><ul><li>用’.’将字符串IP进行分割。判断是否分割成了4块</li><li>对于分割出的每一块，首先检查其长度（应在[1,3]之间），其次验0（在以’0’开头时长度只能为1），最后检查对应的值是否在0-255之间，并且每一位上是否都是数字</li></ul><p>validIPv4()函数： </p><ul><li>用’:’将字符串IP进行分割。判断是否分割成了8块</li><li>对于分割出的每一块，首先检查其长度（应在[1,4]之间），其次检查每个位对应的字符是否在0123456789abcdefABCDEF的范围内</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">validIPAddress</span><span class="hljs-params">(String IP)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; IP.length(); i++)&#123;<br>            count1 += IP.charAt(i) == <span class="hljs-string">&#x27;.&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            count2 += IP.charAt(i) == <span class="hljs-string">&#x27;:&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count1 == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span>(validIPv4(IP))<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv4&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count2 == <span class="hljs-number">7</span>)&#123;<br>            <span class="hljs-keyword">if</span>(validIPv6(IP))<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IPv6&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validIPv4</span><span class="hljs-params">(String IP)</span></span>&#123;<br>        <span class="hljs-comment">//split函数以&#x27;.&#x27;来进行分割时，必须要加上转义字符\\</span><br>        String[] strs = IP.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        <span class="hljs-keyword">if</span>(strs.length != <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-keyword">if</span> (str.length() &lt; <span class="hljs-number">1</span> || str.length() &gt; <span class="hljs-number">3</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (str.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str.length() != <span class="hljs-number">1</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (!Character.isDigit(str.charAt(i))) <br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(Integer.valueOf(str) &gt; <span class="hljs-number">255</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validIPv6</span><span class="hljs-params">(String IP)</span></span>&#123;<br>        String[] strs = IP.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-keyword">if</span>(strs.length != <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-string">&#x27;0&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; i++)<br>            set.add((<span class="hljs-keyword">char</span>)i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;f&#x27;</span>; i++)<br>            set.add((<span class="hljs-keyword">char</span>)i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-string">&#x27;A&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;F&#x27;</span>; i++)<br>            set.add((<span class="hljs-keyword">char</span>)i);<br>        <span class="hljs-keyword">for</span>(String str : strs) &#123;<br>            <span class="hljs-keyword">if</span>(str.length() &lt; <span class="hljs-number">1</span> || str.length() &gt; <span class="hljs-number">4</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                <span class="hljs-keyword">if</span>(!set.contains(str.charAt(i))) <br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】5.最长回文子串</title>
    <link href="/2021/02/18/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/18/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre><code>示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><h2 id="方法1（动态规划）"><a href="#方法1（动态规划）" class="headerlink" title="方法1（动态规划）"></a>方法1（动态规划）</h2><p>一个长度大于2的回文串，去掉首尾两个字母后仍然是一个回文串。<br>用dp[i][j]表示字符串s的第i到j个字母组成的串是否为回文串。即有动态规划状态转移方程</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span><br></code></pre></td></tr></table></figure><p>意为：如果从i+1到j-1的一个子串是回文串，并且s[i]和s[j]相等，则从i到j的子串也是回文串<br>接下来考虑边界条件：（回文串长度小于等于2时）  </p><ul><li>s长度为1：肯定为回文串</li><li>s长度为2：判断s[i]和s[j]是否相等  </li></ul><p>由于在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，所以要先遍历j，再遍历i。在遍历的过程中不断更新max_len，即可获得最长回文子串长度j-i+1和起始位置start。</p><p><strong>代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-comment">//dp[i][j]表示字符串s的第i到j个字母组成的串是否为回文串</span><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[length][length];<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//max_len记录最长回文子串的长度</span><br>        <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>                <span class="hljs-comment">//i必须小于j，因此当i大于j时可以直接continue跳过不处理</span><br>                <span class="hljs-keyword">if</span>(i &gt; j)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">//长度为1的子串肯定是回文串</span><br>                <span class="hljs-keyword">if</span>(i == j)<br>                    dp[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//子串长度为2并且i和j对应的字符相等时，为回文字符串</span><br>                <span class="hljs-keyword">if</span>(j == i + <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = s.charAt(i) == s.charAt(j);<br>                &#125;<br>                <span class="hljs-comment">//子串长度大于2时，依据动态规划的状态转移方程判断</span><br>                <span class="hljs-keyword">if</span>(j - i &gt; <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j);<br>                &#125;<br>                <span class="hljs-comment">//更新回文子串的最长长度max_len以及这个子串的起始位置start</span><br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="hljs-number">1</span> &gt; max_len)&#123;<br>                    max_len = j-i+<span class="hljs-number">1</span>;<br>                    start = i;<br>                &#125; <br>            &#125;<br>        &#125;<br>        String res = <span class="hljs-keyword">new</span> String(s.toCharArray(), start, max_len);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法2（中心扩展法）"><a href="#方法2（中心扩展法）" class="headerlink" title="方法2（中心扩展法）"></a>方法2（中心扩展法）</h2><p>假设字符串的长度为N，那么回文串可能的中心有2N-1种。其中，每个单字符串都可作为回文串的中心，这种情况有N种。其次，双字符串也可作为回文串的中心，这种情况有N-1种。单字符中心负责扩展成长度为奇数的字符串，双字符串中心可以扩展成长度为偶数的字符串。例如：</p><ul><li>字符串“aba”有5种可能的中心：a、b、c、ab、ba  </li><li>字符串“abba”有7种可能的中心：a、b、b、a、ab、bb、ba</li></ul><p>中心扩展法的基本思想为：对于每一个中心都计算一次以其为中心的最长回文串长度</p><p>具体算法：对于每一个可能的回文中心，都尽可能地扩展它对应的回文区间[left, right]，直到left&lt;0或者right&gt;=N或者S[left]不等于S[right]为止</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.length();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> left = i / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> right = left + i % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>            String tmp = s.substring(left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (tmp.length() &gt; res.length()) &#123;<br>                res = tmp;<br>            &#125;<br>            left--;<br>            right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的中心扩展法思路与<a href="https://github.com/wyh317/Leetcode/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/647%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md">647 回文子串</a>一致</p><p>时间复杂度：$O(n^2)$（对于每一个可能的中心都要遍历一次字符串）<br>空间复杂度：O(1)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】647.回文子串</title>
    <link href="/2021/02/18/647%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/18/647%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647 回文子串"></a>647 回文子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><pre><code>示例 1：输入：&quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;示例 2：输入：&quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre><h2 id="方法1（动态规划）"><a href="#方法1（动态规划）" class="headerlink" title="方法1（动态规划）"></a>方法1（动态规划）</h2><ul><li>dp数组定义：dp[i][j]表示字符串s在[i,j]区间的子串是否是一个回文串</li><li>状态转移方程：当s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])时，dp[i][j] = true,否则为false。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()][s.length()];<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= j; i++) &#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                dp[i][j] = <span class="hljs-keyword">true</span>;<br>                res++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(n^2)$</p><h2 id="方法2（中心扩展法）"><a href="#方法2（中心扩展法）" class="headerlink" title="方法2（中心扩展法）"></a>方法2（中心扩展法）</h2><p>假设字符串的长度为N，那么回文串可能的中心有2N-1种。其中，每个单字符串都可作为回文串的中心，这种情况有N种。其次，双字符串也可作为回文串的中心，这种情况有N-1种。单字符中心负责扩展成长度为奇数的字符串，双字符串中心可以扩展成长度为偶数的字符串。例如：</p><ul><li>字符串“aba”有5种可能的中心：a、b、c、ab、ba  </li><li>字符串“abba”有7种可能的中心：a、b、b、a、ab、bb、ba</li></ul><p>中心扩展法的基本思想为：对于每一个中心都计算一次以其为中心的回文串个数。</p><p>具体算法：对于每一个可能的回文中心，都尽可能地扩展它对应的回文区间[left, right]，直到left&lt;0或者right&gt;=N或者S[left] != S[right]为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, N = s.length();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> center = <span class="hljs-number">0</span>; center &lt; 2N - <span class="hljs-number">1</span>; center++)&#123;<br>        <span class="hljs-comment">//center为偶数时left和right指向同一个位置，center为奇数时right指向left的后一个位置</span><br>        <span class="hljs-keyword">int</span> left = center / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> right = left + center % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;<br>            res++;<br>            left--;<br>            right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$（对于每一个可能的中心都要遍历一次字符串）<br>空间复杂度：O(1)</p><p>对于本题的中心扩展法稍加修改，可以解决<a href="https://github.com/wyh317/Leetcode/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md">5.最长回文子串</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】75.颜色分类</title>
    <link href="/2021/02/18/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2021/02/18/75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75 颜色分类"></a>75 颜色分类</h1><p><strong>题目：</strong><br>给定一个包含红色、白色和蓝色，一共n个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  </p><p>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p><p><strong>直观思路：</strong><br>两次遍历数组，第一次遍历时记录下红白蓝三色(0、1、2)分别出现的次数,第二次遍历时重写当前数组</p><p><strong>只用一次遍历的方法：</strong><br>同荷兰国旗问题的解决方法类似。方法阐述见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//red表示红色区域的右边界，blue表示蓝色区域的左边界</span><br>    <span class="hljs-comment">//初始化时，红色区域和蓝色区域都不存在</span><br>    <span class="hljs-keyword">int</span> red = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> blue = nums.length;<br>    <span class="hljs-comment">//cur为游标，代表遍历到的当前位置</span><br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//等到cur与blue区域相遇时，跳出循环，遍历结束</span><br>    <span class="hljs-keyword">while</span>(cur &lt; blue)&#123;<br>        <span class="hljs-comment">//如果当前节点是红色的，交换这个节点与红色区域的下一个节点，红色区域右移一位。</span><br>        <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">0</span>)<br>            swap(nums, ++red, cur++);<br>        <span class="hljs-comment">//如果当前节点是蓝色的，交换这个节点与蓝色区域的前一个节点，蓝色区域左移一位</span><br>        <span class="hljs-comment">//当前cur不变，交换过来的cur位置值需要继续进入while循环，判断此处是蓝色白色还是红色</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[cur] == <span class="hljs-number">2</span>)<br>            swap(nums, --blue, cur);<br>        <span class="hljs-comment">//如果当前节点是白色的，红色区域和蓝色区域均不变，cur继续右移</span><br>        <span class="hljs-keyword">else</span><br>            cur++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】88.合并两个有序数组</title>
    <link href="/2021/02/18/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/18/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明：</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 </p><pre><code>示例：输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出：[1,2,2,3,5,6]</code></pre><h2 id="方法（双指针）"><a href="#方法（双指针）" class="headerlink" title="方法（双指针）"></a>方法（双指针）</h2><p>使用两个指针，一个指向nums1中的元素，一个指向nums2中的元素</p><p>如果从前向后遍历的话，由于是从小到大重置数组nums1，向nums1中插入nums2元素的操作会造成后面元素的移动，增加时间复杂度。</p><p>因此我们需要从后向前遍历，也就是按元素从大到小重置数组nums1，每次比较指针p1和指针p2指向的nums1和nums2中的元素，每次将大的元素往nums1末尾放，直到放置好所有的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p1 = m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> p2 = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> index = m + n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>)&#123;<br>        nums1[index--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1 &gt;= <span class="hljs-number">0</span>)<br>        nums1[index--] = nums1[p1--];<br>    <span class="hljs-keyword">while</span>(p2 &gt;= <span class="hljs-number">0</span>)<br>        nums1[index--] = nums2[p2--];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)</li><li>空间复杂度:O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】130.被围绕的区域</title>
    <link href="/2021/02/17/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <url>/2021/02/17/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130 被围绕的区域"></a>130 被围绕的区域</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><pre><code>示例:X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为：X X X XX X X XX X X XX O X X解释:被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</code></pre><h2 id="方法-DFS"><a href="#方法-DFS" class="headerlink" title="方法(DFS)"></a>方法(DFS)</h2><p>据题意，我们需要将矩阵中的中的’O’分为以下两种：</p><ul><li>边界上的’O’和与边界上相邻的’O’</li><li>被’X’围绕的’O’  </li></ul><p>对于后者，我们需要将其改为’X’。而前者则无需改动。</p><p>先写一个深度优先遍历的函数，暂且叫它感染函数。它能实现将所有与当前位置相连的’O’修改成’#’。<br>所以第一步，我们先处理矩阵的四个边界，若在遍历边界的时候遇到’O’,则进入感染过程，将与边界上的’O’相连的’O’全都改写成’#’，以将上述两种’O’区别开来。</p><p>第二步，我们遍历整个矩阵，若遇到’O’，则这个’O’是被围绕的’O’，于是将其改为’X’。若遇到’#’，则代表其是边界上的’O’，于是将其改为’O’。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(board == <span class="hljs-keyword">null</span> || board.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//第一步：处理边界</span><br>    <span class="hljs-keyword">int</span> rows = board.length;<br>    <span class="hljs-keyword">int</span> cols = board[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols ; j++)&#123;<br>        <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            infect(board, <span class="hljs-number">0</span>, j);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols ; j++)&#123;<br>        <span class="hljs-keyword">if</span>(board[rows - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            infect(board, rows - <span class="hljs-number">1</span>, j);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows ; i++)&#123;<br>        <span class="hljs-keyword">if</span>(board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            infect(board, i, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)&#123;<br>        <span class="hljs-keyword">if</span>(board[i][cols - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            infect(board, i, cols - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//第二步：遍历矩阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infect</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j &gt;= board[<span class="hljs-number">0</span>].length || board[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> || board[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>        <span class="hljs-keyword">return</span>;<br>    board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    infect(board, i - <span class="hljs-number">1</span>, j);<br>    infect(board, i + <span class="hljs-number">1</span>, j);<br>    infect(board, i, j - <span class="hljs-number">1</span>);<br>    infect(board, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】127.单词接龙</title>
    <link href="/2021/02/17/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <url>/2021/02/17/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<h1 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127.单词接龙"></a>127.单词接龙</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p><p>说明:</p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例：</p><pre><code>示例 1:输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,返回它的长度 5。示例 2:输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><h2 id="方法（广度优先遍历）"><a href="#方法（广度优先遍历）" class="headerlink" title="方法（广度优先遍历）"></a>方法（广度优先遍历）</h2><p>我们可以把beginWord、endWord还有wordList中的所有单词想象成一张无向图中的节点。如果两个单词只有一个字符不同，则这两个节点相连。</p><p><img src="/img/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.jpg"></p><p>因此题意就变为了：在beginWord到endWord两个节点间，找到一条最短路径。我们由“最短”想到了广度优先遍历。</p><p>要进行BFS，我们需要两个复制结构：</p><ul><li>一个队列</li><li>一个visited数组(或集合)，记录一个节点有没有被BFS遍历过，以避免重复遍历造成在图中无限循环。</li></ul><p>注意：对于树的BFS只需要一个队列即可，因为树从上到下的结构决定了不会在其中重复遍历。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;<br>    <span class="hljs-comment">//将wordList中的单词加入HashSet，以便我们在之后快速查询一个单词是否在字典中</span><br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordList);<br>    <span class="hljs-comment">//如果字典中有beginWord，先要把它删掉</span><br>    <span class="hljs-keyword">if</span>(set.contains(beginWord))<br>        set.remove(beginWord);<br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">//uesd集合记录哪些字符串已经在BFS中被遍历过</span><br>    Set&lt;String&gt; used = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    queue.add(beginWord);<br>    used.add(beginWord);<br>    <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//进入BFS流程</span><br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        step++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            String str = queue.poll();<br>            <span class="hljs-comment">//如果找到了endWord，直接返回</span><br>            <span class="hljs-keyword">if</span>(str.equals(endWord))<br>                <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-comment">//依次尝试将str中的每一个字符修改为a到z中的一个，看看字典中有没有相应字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; str.length(); j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-string">&#x27;a&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; k++)&#123;<br>                    <span class="hljs-keyword">char</span>[] arr = str.toCharArray();<br>                    arr[j] = (<span class="hljs-keyword">char</span>)k;<br>                    String new_str = <span class="hljs-keyword">new</span> String(arr);<br>                    <span class="hljs-keyword">if</span>(set.contains(new_str) &amp;&amp; !used.contains(new_str))&#123;<br>                        queue.add(new_str);<br>                        used.add(new_str);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】200.岛屿数量</title>
    <link href="/2021/02/17/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2021/02/17/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><pre><code>示例 1:输入:[[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]]输出: 1示例 2:输入:[[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],[&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;],[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>每遍历矩阵中的一个值，进入到感染函数中去，感染函数会把连在一块的1全部变成2。感染过程完成后，岛数量加1（初始为0）。之后遍历过程中如果是2或0直接跳过，直到再遇到1时进入感染过程。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-keyword">null</span> || m.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> N = m.length;<br>    <span class="hljs-keyword">int</span> M = m[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-keyword">if</span> (m[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                res++;<br>                infect(m, i, j, N, M);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">infect</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] m, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> M)</span> </span>&#123;<br>    <span class="hljs-comment">//只当一个位置为1时才进行感染过程</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || m[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    m[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    infect(m, i + <span class="hljs-number">1</span>, j, N, M);<br>    infect(m, i - <span class="hljs-number">1</span>, j, N, M);<br>    infect(m, i, j + <span class="hljs-number">1</span>, N, M);<br>    infect(m, i, j - <span class="hljs-number">1</span>, N, M);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】133.克隆图</title>
    <link href="/2021/02/17/133%20%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <url>/2021/02/17/133%20%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133 克隆图"></a>133 克隆图</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><pre><code>class Node &#123;    public int val;    public List&lt;Node&gt; neighbors;&#125;</code></pre><p> 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><h2 id="方法一（DFS）"><a href="#方法一（DFS）" class="headerlink" title="方法一（DFS）"></a>方法一（DFS）</h2><p>深拷贝一个图的意思为：要重新构建一张新的图，其中所有的节点都需要new出来，图的值和结构都和原图一样。</p><p>根据给定的这个节点，可以通过深度优先遍历走遍图中的所有节点。每到一个节点，先判断其是否访问过。</p><ul><li>若这个节点已经访问过，则直接返回它的拷贝节点。</li><li>若这个节点还未访问过，就根据这个节点new出一个新的拷贝节点。先给这个新节点赋值，再填充它的邻接列表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//map的key为原图中的节点，value为根据它拷贝出的新节点</span><br>    Map&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//此递归函数会返回node的深拷贝节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">//递归结束条件</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//若这个节点已经访问过，则直接返回它的拷贝节点。</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(node))<br>            <span class="hljs-keyword">return</span> map.get(node);<br>        <span class="hljs-comment">//若这个节点还未访问过，就根据这个节点构造一个新的拷贝节点</span><br>        Node newNode = <span class="hljs-keyword">new</span> Node(node.val);<br>        <span class="hljs-comment">//这时已经访问完了节点node，因此要更新map</span><br>        map.put(node, newNode);<br>        <span class="hljs-comment">//根据node的邻接列表，填充新节点newNode的邻接列表</span><br>        <span class="hljs-keyword">for</span>(Node neighbor: node.neighbors)&#123;<br>            newNode.neighbors.add(cloneGraph(neighbor));<br>        &#125;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N) 每个节点只会被访问一次</li><li>空间复杂度：O(N) 哈希表需要O(N)的空间，递归使用的栈深度需要O(H)的空间（H为图的深度）。总空间复杂度为O(N)</li></ul><h2 id="方法二（BFS）"><a href="#方法二（BFS）" class="headerlink" title="方法二（BFS）"></a>方法二（BFS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//map的key为原图中的节点，value为根据它拷贝出的新节点</span><br>        Map&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//先将node节点入队列</span><br>        queue.add(node);<br>        map.put(node, <span class="hljs-keyword">new</span> Node(node.val));<br>        <span class="hljs-comment">//通过BFS遍历到所有节点，在遍历的过程中更新map</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            Node temp = queue.poll();<br>            <span class="hljs-keyword">for</span>(Node neighbor: temp.neighbors)&#123;<br>                <span class="hljs-comment">//如果此节点未被遍历过，一方面正常的走BFS的流程，将其入队列</span><br>                <span class="hljs-comment">//另一方面构造它的拷贝节点，填充拷贝节点的值，并更新map</span><br>                <span class="hljs-keyword">if</span>(!map.containsKey(neighbor))&#123;<br>                    map.put(neighbor, <span class="hljs-keyword">new</span> Node(neighbor.val));<br>                    queue.add(neighbor);<br>                &#125;<br>                <span class="hljs-comment">//填充该节点neighbor对应的拷贝节点neighbor&#x27;的邻接列表</span><br>                <span class="hljs-comment">//在邻接链表中加入temp&#x27;和neighbor&#x27;的邻接关系</span><br>                map.get(neighbor).neighbors.add(map.get(temp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//至此，所有新节点的值和邻接列表都已填充好，可以返回。</span><br>        <span class="hljs-keyword">return</span> map.get(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N) 每个节点只会被访问一次</li><li>空间复杂度：O(N) 哈希表需要O(N)的空间，BFS所用的队列最多需要O(N)的空间，总空间复杂度为O(N)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】207.课程表</title>
    <link href="/2021/02/17/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <url>/2021/02/17/207.%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207.课程表"></a>207.课程表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><p> </p><pre><code>示例 1:输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2:输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于这种问题，我们都可以画一张有向图，其中节点对应课程，有向边表示优先级顺序。<br>那么在优先级限制下的调度问题就等价于拓扑排序问题。</p><p><strong>**拓扑排序</strong>：给定一幅有向图，将所有的节点排序，使得所有有向边均从排在前面的节点指向排在后面的节点。</p><p>而一旦一个优先级问题的有向图中存在环，则不可能找出一个正确的拓扑排序。因此，本题目实则是判断这个有向图中是否存在环。我们有DFS和BFS两种方式。</p><h2 id="方法一-DFS"><a href="#方法一-DFS" class="headerlink" title="方法一(DFS)"></a>方法一(DFS)</h2><p>算法步骤：</p><ul><li>首先进行建图操作，即通过给定的prerequisites建立一张用邻接表表示的图。</li><li>status数组用于记录节点的访问状态，访问过了标记 -1，正在访问标记 1，还未访问标记 0</li><li>从图中的每个节点开始进行深度优先搜索，一旦从该节点出发可以找到环，则返回false.如果从所有节点开始都找不到环，则返回true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; adj;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            status[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//第一步：将给定的prerequisites转换为邻接表</span><br>        adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] item: prerequisites)&#123;<br>            adj.get(item[<span class="hljs-number">1</span>]).add(item[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//从图中的每一个节点开始进行DFS，如果以任意一个节点开始都不存在环，则返回true</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(i, status))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断从节点i出发，能否找到一个环。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> status[])</span></span>&#123;<br>        <span class="hljs-comment">//若当前节点i在此轮dfs中的状态为正在访问，说明在本轮dfs中之前遍历到了i,现在又回到了i，则存在环</span><br>        <span class="hljs-keyword">if</span>(status[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//如果当前节点i在之前某次dfs中已经访问完了，说明从i出发不会有环，返回false。</span><br>        <span class="hljs-keyword">if</span>(status[i] == -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        status[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor : adj.get(i))&#123;<br>            <span class="hljs-comment">//如果从i的一个邻居neighbor出发可以找到一个环，因为i可以走到neighbor。所以从i出发也可以找到一个环，返回true</span><br>            <span class="hljs-keyword">if</span>(dfs(neighbor, status))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//此刻i已经访问完，标记其为已访问</span><br>        status[i] = -<span class="hljs-number">1</span>;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n + m) 对图进行深度优先搜索的时间复杂度</li><li>空间复杂度：O(n + m) 邻接表需要O(n + m)的空间，DFS队列需要O(n)的栈空间，总空间复杂度为O(n + m)</li></ul><h2 id="方法二（BFS"><a href="#方法二（BFS" class="headerlink" title="方法二（BFS)"></a>方法二（BFS)</h2><p>算法步骤：</p><ul><li>准备一个队列，先让入度为0的节点入队列。（入度为0代表此课无先修课程，可以选）</li><li>接着进入BFS流程，每次让队首节点出列，并相应地更新相连节点的入度。（出列代表课被选，同时相邻节点的先修课程就少了一门）</li><li>如果某个节点的入度更新后为0，则让它入队列。</li></ul><p>我们用一个变量count记录遍历过的节点数。如果BFS流程走完时，count不等于prerequisites，则意味着无法选齐所有的课，返回false。否则返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; adj;<br>    <span class="hljs-keyword">int</span>[] indegree;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>        <span class="hljs-comment">//根据给定的prerequisites构造邻接表和入度表</span><br>        adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        indegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] item: prerequisites)&#123;<br>            adj.get(item[<span class="hljs-number">1</span>]).add(item[<span class="hljs-number">0</span>]);<br>            indegree[item[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-comment">//先让入度为0的节点入队列</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(indegree[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        &#125;<br>        <span class="hljs-comment">//count用来记录遍历到的节点个数</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> temp = queue.poll();<br>            count++;<br>            <span class="hljs-comment">//每遍历到一个节点，便更新它相邻节点的入度。</span><br>            <span class="hljs-comment">//如果相邻节点的入度更新后为0，则将其入队</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor: adj.get(temp))&#123;<br>                indegree[neighbor]--;<br>                <span class="hljs-keyword">if</span>(indegree[neighbor] == <span class="hljs-number">0</span>)<br>                    queue.offer(neighbor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count == numCourses;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n + m) 对图进行广度优先搜索的时间复杂度</li><li>空间复杂度：O(n + m) 邻接表需要O(n + m)的空间，BFS队列需要O(n)的空间，总空间复杂度为O(n + m)</li></ul><h1 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210.课程表 II"></a>210.课程表 II</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><pre><code>示例 1:输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</code></pre><h2 id="方法一（DFS）"><a href="#方法一（DFS）" class="headerlink" title="方法一（DFS）"></a>方法一（DFS）</h2><p>此题与第207题的唯一不同在于，207题只需要判断是否能找到一种可能的拓扑排序。这道题让我们求出具体的一种拓扑排序。</p><p>我们只需用一个栈纪录已访问的序列即可，在dfs函数中，一旦遍历完当前节点i的所有邻居，并且从所有邻居开始都不存在有向环，则将节点i入栈。（注意：若不存在有向环，当i入栈时，它的所有邻居均已入栈，于是i位于栈顶，同时i是拓扑排序的起点）。</p><p>在深度优先遍历后，我们将栈中的元素依次弹出，就可以得到正确的拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; adj;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;<br>        <span class="hljs-keyword">if</span>(numCourses == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//status数组用于记录节点的访问状态，访问过了标记 -1，正在访问标记 1，还未访问标记 0。数组初始化为全0</span><br>        <span class="hljs-keyword">int</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            status[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//第一步：将给定的prerequisites转换为邻接表</span><br>        adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] item: prerequisites)&#123;<br>            adj.get(item[<span class="hljs-number">1</span>]).add(item[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//栈stack用于保存拓扑排序的序列</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(i, status, stack))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            res[i] = stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//判断从节点i出发，能否找到一个环。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> status[], Stack&lt;Integer&gt; stack)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(status[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(status[i] == -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        status[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor : adj.get(i))&#123;<br>            <span class="hljs-keyword">if</span>(dfs(neighbor, status, stack))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        status[i] = -<span class="hljs-number">1</span>;<br>        stack.push(i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二（BFS-1"><a href="#方法二（BFS-1" class="headerlink" title="方法二（BFS)"></a>方法二（BFS)</h2><p>和上一题的唯一不同在于，上一题只需要判断BFS结束后的count是否等于numCourses即可。这道题我们要用一个数组记录下BFS过程中所经过的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; adj;<br>    <span class="hljs-keyword">int</span>[] indegree;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;<br>        <span class="hljs-keyword">if</span>(numCourses == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-comment">//根据给定的prerequisites构造邻接表和入度表</span><br>        adj = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        indegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>            adj.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] item: prerequisites)&#123;<br>            adj.get(item[<span class="hljs-number">1</span>]).add(item[<span class="hljs-number">0</span>]);<br>            indegree[item[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-comment">//先让入度为0的节点入队列</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(indegree[i] == <span class="hljs-number">0</span>)<br>                queue.offer(i);<br>        &#125;<br>        <span class="hljs-comment">//count用来记录遍历到的节点个数</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> temp = queue.poll();<br>            res[count++] = temp;<br>            <span class="hljs-comment">//每遍历到一个节点，便更新它相邻节点的入度。</span><br>            <span class="hljs-comment">//如果相邻节点的入度更新后为0，则将其入队</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor: adj.get(temp))&#123;<br>                indegree[neighbor]--;<br>                <span class="hljs-keyword">if</span>(indegree[neighbor] == <span class="hljs-number">0</span>)<br>                    queue.offer(neighbor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count != numCourses)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】515.在每个树行中找最大值</title>
    <link href="/2021/02/17/515.%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2021/02/17/515.%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>您需要在二叉树的每一行中找到最大的值。</p><pre><code>示例：输入:           1         / \        3   2       / \   \        5   3   9 输出: [1, 3, 9]</code></pre><h2 id="方法一（BFS"><a href="#方法一（BFS" class="headerlink" title="方法一（BFS)"></a>方法一（BFS)</h2><p>在广度优先遍历的时候用变量size记录每一层的节点个数，在遍历这一层时找到此层中的最大值，添加到结果数组中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> res;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-comment">//while循环代表整个BFS的逻辑</span><br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-comment">//当前层节点数量</span><br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>        <span class="hljs-comment">//for循环表示每一层的遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i++)&#123;<br>            TreeNode node = queue.poll();<br>            max = Math.max(max, node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)<br>                queue.add(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)<br>                queue.add(node.right);<br>        &#125;<br>        res.add(max);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二（DFS"><a href="#方法二（DFS" class="headerlink" title="方法二（DFS)"></a>方法二（DFS)</h2><p>在进行深度优先遍历时，每次遍历到新的一层时，我们都将现在遍历到的这个该层节点加入到结果数组res中（但其实上这个节点并不一定是该层最大的，不过没关系，我们之后再更新它）。之后再遍历到同在这一层的其他节点时再进行更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//如果是第一次来到第level层，那就先把当前遍历到达level层的这个节点加入到结果数组res中</span><br>        <span class="hljs-keyword">if</span>(level == res.size() + <span class="hljs-number">1</span>)<br>            res.add(root.val);<br>        <span class="hljs-comment">//之后再遍历到同在level层的其他节点时对res中的值进行更新</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> max = Math.max(res.get(level - <span class="hljs-number">1</span>), root.val);<br>            res.set(level - <span class="hljs-number">1</span>, max);<br>        &#125;<br>        dfs(root.left, level + <span class="hljs-number">1</span>);<br>        dfs(root.right, level + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】542.01矩阵</title>
    <link href="/2021/02/17/542.01%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/02/17/542.01%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="542-01矩阵"><a href="#542-01矩阵" class="headerlink" title="542.01矩阵"></a>542.01矩阵</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><pre><code>示例 1:输入:0 0 00 1 00 0 0输出:0 0 00 1 00 0 0示例 2:输入:0 0 00 1 01 1 1输出:0 0 00 1 01 2 1</code></pre><h2 id="方法（BFS）"><a href="#方法（BFS）" class="headerlink" title="方法（BFS）"></a>方法（BFS）</h2><p>对于二叉树的BFS，都是单源BFS。<br>而对于图的BFS，大多是多源BFS</p><p>因为二叉树只有一个根节点，先把根节点入队，再一层层遍历即可。而图可以有许多源点，因此需要先把这些源点都入队，再一层层遍历。</p><p>对于本题来说，先将所有的0（源点）入队列，再从0开始一层一层向周围未遍历到的1扩散。最后将矩阵中所有的点都遍历到。</p><p>注意：树是有向的，因此无需标记一个节点是否被访问过。而对于无向图来说，为了防止一个节点多次入队，需要在访问它之后将它标记为已访问。（对于本题来说，将其标记为非-1）</p><p>算法步骤：</p><ul><li>先遍历一遍矩阵，将0出现的位置索引入队列，并将所有的1置为-1，表明这是还没被访问过的1.</li><li>用dx和dy两个矩阵来表示向上下左右四个位置的移动</li><li>移动到没有访问过的1时，将其入队列，并更新matrix[newX][newY]（本来为-1）为matrix[x][y] + 1。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] updateMatrix(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">//先遍历一次矩阵，将0出现的位置索引入队列</span><br>    <span class="hljs-comment">//并把1的位置设置为-1，表示这是还没被访问的1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;i, j&#125;);<br>            <span class="hljs-keyword">else</span><br>                matrix[i][j] = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] dx = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] dy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span>[] node = queue.poll();<br>        <span class="hljs-keyword">int</span> x = node[<span class="hljs-number">0</span>], y = node[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-comment">//newX和newY为附近邻居的位置索引</span><br>            <span class="hljs-keyword">int</span> newX = x + dx[i];<br>            <span class="hljs-keyword">int</span> newY = y + dy[i];<br>            <span class="hljs-comment">//如果邻居值为-1，说明它是还没被访问过的1.</span><br>            <span class="hljs-comment">//则这个点到0的距离就可以更新为matrix[x][y] + 1,注意：这步更新完之后这个点就有实际值而不是-1了，相当于被标记了。</span><br>            <span class="hljs-comment">//当遇到被标记过（访问过）的点时，不将其入队列</span><br>            <span class="hljs-keyword">if</span>(newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; matrix[newX][newY] == -<span class="hljs-number">1</span>)&#123;<br>                matrix[newX][newY] = matrix[x][y] + <span class="hljs-number">1</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;newX, newY&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br></code></pre></td></tr></table></figure><p>题目<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">1162. 地图分析</a>和此题目类似</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/">Sweetiee的leetcode题解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】785.判断二分图</title>
    <link href="/2021/02/17/785%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2021/02/17/785%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785 判断二分图"></a>785 判断二分图</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个无向图graph，当这个图为二分图时返回true。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。</p><pre><code>示例 1:输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1|    ||    |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。示例 2:输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \  ||  \ |3----2我们不能将节点分割成两个独立的子集。</code></pre><h2 id="方法一（深度优先搜索）"><a href="#方法一（深度优先搜索）" class="headerlink" title="方法一（深度优先搜索）"></a>方法一（深度优先搜索）</h2><p>对图进行DFS，在遍历的过程中用两种颜色对节点进行染色，其中相邻的节点要染成不同的颜色。如果在遍历的过程中发现相邻的节点颜色相同，那么它不是二分图。如果用这样的染色策略对所有节点染色成功，那么它是二分图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] visited;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;<br>    <span class="hljs-comment">//visited数组记录一个节点有没有被染色，若为0则没被染色，若为-1或1则被染成相应的颜色</span><br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[graph.length];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.length; i++)&#123;<br>        <span class="hljs-comment">//如果一个节点没有被染色，并且从它出发不能成功地将图染成两种颜色，则返回false</span><br>        <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!dfs(graph, i, <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">//从将节点i染成颜色color开始，判断能否将图染成二分图</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> color)</span></span>&#123;<br>    <span class="hljs-comment">//递归返回条件：如果一个节点已经染色了，判断这个节点的颜色和当前要给它染的颜色color是否相同</span><br>    <span class="hljs-keyword">if</span>(visited[i] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> visited[i] == color;<br>    <span class="hljs-comment">//将当前节点染成color色，并将它的所有相邻节点染成-color色</span><br>    visited[i] = color;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j : graph[i])&#123;<br>        <span class="hljs-comment">//如果从i的一个相邻节点j开始，都没能成功地将图染成两种颜色，那么从i开始肯定也不行，返回false</span><br>        <span class="hljs-keyword">if</span>(!dfs(graph, j, -color))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二（广度优先遍历）"><a href="#方法二（广度优先遍历）" class="headerlink" title="方法二（广度优先遍历）"></a>方法二（广度优先遍历）</h2><p>思路和方法一相同，只是遍历的方法从DFS改成了BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;<br>    <span class="hljs-comment">//visited数组记录一个节点有没有被染色，若为0则没被染色，若为-1或1则被染成相应的颜色</span><br>    <span class="hljs-keyword">int</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[graph.length];<br>    <span class="hljs-comment">//如果经过一遍BFS，尚且有节点未被染色，说明这个节点和刚才遍历到的节点不在一个连通图，要从这个节点开始再进行BFS</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(visited[i] != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(i);<br>        visited[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> cur = queue.poll();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor : graph[cur])&#123;<br>                <span class="hljs-comment">//如果相邻节点已经染色，并且和cur颜色一样，说明不是二分图，返回false</span><br>                <span class="hljs-keyword">if</span>(visited[neighbor] == visited[cur])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">//如果有cur的相邻节点尚未染色，则将这个相邻节点染成和cur不同的颜色</span><br>                <span class="hljs-keyword">if</span>(visited[neighbor] == <span class="hljs-number">0</span>)&#123;<br>                    visited[neighbor] = -visited[cur];<br>                    queue.add(neighbor);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法三（并查集）"><a href="#方法三（并查集）" class="headerlink" title="方法三（并查集）"></a>方法三（并查集）</h2><p>在一个二分图中，一个节点的所有邻居都具有相同的颜色，并且和这个节点颜色不同。</p><p>因此我们如果用并查集来看这个问题，则上面一句话可以翻译如下：在二分图中，一个节点的所有邻居都在相同的集合中，并且和这个节点所在的集合不同。</p><p>我们可以遍历所有节点，当遍历到一个节点时，先判断它是否有邻居节点和它已经在一个集合中了(find)，如果有则不是二分图，直接返回false，否则将它的所有邻居节点所在的集合合并(union)，再接着遍历下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;<br>        UnionFindSet ufs = <span class="hljs-keyword">new</span> UnionFindSet();<br>        List&lt;Integer&gt; nodes = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.length; i++)<br>            nodes.add(i);<br>        ufs.makeSets(nodes);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> cur = i;<br>            <span class="hljs-keyword">int</span>[] neighbors = graph[cur];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor : neighbors)&#123;<br>                <span class="hljs-keyword">if</span>(ufs.findHead(neighbor) == ufs.findHead(cur))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                ufs.union(neighbor, neighbors[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> HashMap&lt;Integer, Integer&gt; fatherMap;   <span class="hljs-comment">//key为child，value为father</span><br>        <span class="hljs-keyword">public</span> HashMap&lt;Integer, Integer&gt; sizeMap;<span class="hljs-comment">//value为key所在的集合的大小是多少</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFindSet</span><span class="hljs-params">()</span> </span>&#123;<br>            fatherMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>            sizeMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeSets</span><span class="hljs-params">(List&lt;Integer&gt; nodes)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> node : nodes) &#123;<br>                fatherMap.put(node, node);   <span class="hljs-comment">//在最开始，每一个节点自己成一个集合</span><br>                sizeMap.put(node, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//给一个元素node，返回它所处集合的代表节点。在这个过程中将链变扁平</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> father = fatherMap.get(node);<br>            <span class="hljs-keyword">if</span> (father != node) &#123;<br>                father = findHead(father);<br>            &#125;<br>            fatherMap.put(node, father);<br>            <span class="hljs-keyword">return</span> father;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> aHead = findHead(a);<br>            <span class="hljs-keyword">int</span> bHead = findHead(b);<br>            <span class="hljs-keyword">if</span> (aHead != bHead) &#123;<br>                <span class="hljs-keyword">int</span> aSetSize= sizeMap.get(aHead);<br>                <span class="hljs-keyword">int</span> bSetSize = sizeMap.get(bHead);<br>                <span class="hljs-keyword">if</span> (aSetSize &lt;= bSetSize) &#123;<br>                    fatherMap.put(aHead, bHead);<br>                    sizeMap.put(bHead, aSetSize + bSetSize);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    fatherMap.put(bHead, aHead);<br>                    sizeMap.put(aHead, aSetSize + bSetSize);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/">Leetcode官方题解</a></li><li><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/">Sweetiee的Leetcode题解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度（广度）优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】134.加油站</title>
    <link href="/2021/02/17/134.%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <url>/2021/02/17/134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><p>如果题目有解，该答案即为唯一答案。<br>输入数组均为非空数组，且长度相同。<br>输入数组中的元素均为非负数。</p><pre><code>示例 1:输入: gas  = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。示例 2:输入: gas  = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><h2 id="方法（贪心算法）"><a href="#方法（贪心算法）" class="headerlink" title="方法（贪心算法）"></a>方法（贪心算法）</h2><p>在考虑问题的时候，可以把问题理解成图的形式，每个节点表示添加的油量，每条边表示消耗的油量。题目即让我们找到从哪个节点出发走完每一条边还能回到该节点。  </p><p>如果加油站提供的总油量大于走完每条边消耗的总油量（即gas[i]-cost[i]累加和大于0），则一定可以环绕一周，否则一定不可环绕一周。</p><p>算法步骤：</p><ul><li>从0位置开始遍历，一边记录gas[i]-cost[i]的差值总和total，一边寻找正确的出发点start</li><li>如果一个位置的gas[i]-cost[i]小于0，则它不能作为起始位置（因为从它开始根本跑不到下一个节点），于是我们把可能的开始位置更新为它的下一个节点。当前油量cur重置为0.</li><li>无论油够不够，一直遍历到结尾。如果遍历完成后（每个节点都走过了），total大于等于0，说明可以环绕一周，返回start。如果total小于0，说明不能环绕一周，返回-1.</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] gas, <span class="hljs-keyword">int</span>[] cost)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;       <span class="hljs-comment">//cur记录目前的油量</span><br>    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;     <span class="hljs-comment">//记录开始位置（遍历过程不断更新）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;gas.length;i++)&#123;<br>        total += (gas[i] - cost[i]);<br>        <span class="hljs-comment">//gas[i]-cost[i]小于0的位置不能作为开始位置，于是需要更新开始位置为下一个位置。cur重置0</span><br>        cur += (gas[i] - cost[i]);<br>        <span class="hljs-keyword">if</span>(cur &lt; <span class="hljs-number">0</span>)&#123;<br>            cur = <span class="hljs-number">0</span>;<br>            start = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> total &gt;= <span class="hljs-number">0</span> ? start: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】141.环形链表</title>
    <link href="/2021/02/17/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h1><p><strong>题目：</strong><br>给定一个链表。判断链表中是否有环</p><p><strong>思路：</strong><br>双指针思路：一个快指针，一个慢指针。快指针一次走两步，慢指针一次走一步。两个指针若相遇，则有环。</p><p>哈希表思路：我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。</p><p>算法：我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>    Set&lt;ListNode&gt; nodesSeen = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(nodesSeen.contains(head))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span><br>            nodesSeen.add(head);<br>        head = head.next;    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】142.环形链表II</title>
    <link href="/2021/02/17/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2021/02/17/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142 环形链表 II"></a>142 环形链表 II</h1><p><strong>题目：</strong><br>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。</p><p>示例 1：<br>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p>示例 2：<br>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p>不仅要判断是否有环，还要找到入环的第一个节点</p><p><strong>思路：</strong><br>在上一道题中已经知道如何判断一个链表有没有环。即采用快慢指针法，如果相遇则有环。进一步思考：两个指针相遇的节点一定在环中。可以从这个结点出发，一边继续移动一边计数，当再次回到这个节点时，就可以得到环中节点个数了。</p><p>知道了节点个数n。我们可以让快指针先向前移动n步。然后两个指针一起移动。当第慢指针指向环的入口节点时，快指针也已经围绕着环走了一圈，回到了入口节点，两指针相遇</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode meetnode = meetingNode(head);<br>        <span class="hljs-keyword">if</span>(meetnode == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//nodeinLoop变量用来保存环中节点的数目</span><br>        <span class="hljs-keyword">int</span> nodeinLoop = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//从相遇的节点meetnode出发,继续移动，再回到meetnode时，计数结束,得到环中节点数目</span><br>        ListNode cur = meetnode;<br>        <span class="hljs-keyword">while</span>(cur.next != meetnode)&#123;<br>            cur = cur.next;<br>            nodeinLoop++;<br>        &#125;<br>        <span class="hljs-comment">//知道节点数目后找入口节点</span><br>        <span class="hljs-comment">//先让快指针移动nodeinLoop步</span><br>        ListNode fast = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeinLoop; i++)<br>            fast = fast.next;<br>        <span class="hljs-comment">//再一起移动快慢指针，知道它们相遇于入口节点</span><br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>    <span class="hljs-comment">//meetingNode函数找到快慢指针在环中相遇的节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">meetingNode</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//定义快慢指针，快指针一次走两步，满指针一次走一步。如果链表有环，则两指针一定会相遇</span><br>        ListNode fast = head;<br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)<br>                <span class="hljs-keyword">return</span> fast;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】148.排序链表</title>
    <link href="/2021/02/17/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><pre><code>示例 1:输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2:输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><h2 id="方法-归并排序思路"><a href="#方法-归并排序思路" class="headerlink" title="方法(归并排序思路)"></a>方法(归并排序思路)</h2><ol><li>首先用快慢指针法将链表从中间断开</li><li>对左边链表排序</li><li>对右边链表排序</li><li>合并左右两个链表，返回链表头</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//递归中止条件：链表只有一个节点</span><br>    <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    <span class="hljs-comment">//快慢指针，快指针走到尾，慢指针走到中点</span><br>    ListNode fast = head, slow = head;<br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>)&#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">//从中点将链表断成两部分</span><br>    ListNode tail = slow;<br>    slow = slow.next;<br>    tail.next = <span class="hljs-keyword">null</span>;<br>    ListNode L = sortList(head);<br>    ListNode R = sortList(slow);<br>    <span class="hljs-keyword">return</span> merge(L, R);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span></span>&#123;<br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode cur = dummy;<br>    <span class="hljs-keyword">while</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(left.val &lt;= right.val)&#123;<br>            cur.next = left;<br>            cur = cur.next;<br>            left = left.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur.next = right;<br>            cur = cur.next;<br>            right = right.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)<br>        cur.next = left;<br>    <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>)<br>        cur.next = right;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】143.重排链表</title>
    <link href="/2021/02/17/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143 重排链表"></a>143 重排链表</h1><p><strong>题目：</strong><br>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:<br>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:<br>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><p><strong>思路：</strong><br>分三个步骤：</p><ol><li>找到中间节点，根据中间节点把链表分为左右两部分</li><li>把右半部分节点反转</li><li>将右半部分链表的节点插入左半部分中点</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>    ListNode pre = <span class="hljs-keyword">null</span>;<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        ListNode temp = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】147.对链表进行插入排序</title>
    <link href="/2021/02/17/147.%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/02/17/147.%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147.对链表进行插入排序"></a>147.对链表进行插入排序</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>对链表进行插入排序。</p><pre><code>示例 1：输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2：输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>新建一个列表，将链表中的元素全部加入到这个链表中。然后对这个列表进行排序。最后将列表中排序好的元素再依次放回链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        list.add(cur.val);<br>        cur = cur.next;<br>    &#125;<br>    Collections.sort(list);<br>    cur = head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : list)&#123;<br>        cur.val = num;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>设置一个指针pre和一个指针cur，pre初始化为head，cur初始化为head.next。从前到后遍历链表中的每一个元素</p><ul><li>如果pre所指的值小于cur所指的值（已经有序），那么pre和cur正常向后移动</li><li>如果pre所指的值大于cur所指的值，那么cur所指节点需要在前面已经有序的部分找到相应位置进行插入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">//链表为空或者只有一个节点的情况</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br>    ListNode pre = head, cur = head.next;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(pre.val &lt;= cur.val)&#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//节点node用来遍历找到插入位置</span><br>            ListNode node = dummy;<br>            <span class="hljs-comment">//找到一个位置，使得node &lt; cur &lt; node.next</span><br>            <span class="hljs-keyword">while</span>(node.next != <span class="hljs-keyword">null</span> &amp;&amp; node.next.val &lt; cur.val)<br>                node = node.next;<br>            <span class="hljs-comment">//将原有位置的cur删除</span><br>            pre.next = cur.next;<br>            <span class="hljs-comment">//将cur插入到新位置</span><br>            cur.next = node.next;<br>            node.next = cur;<br>            <span class="hljs-comment">//插入结束后，cur回到原有位置（pre后面），继续后面的遍历</span><br>            cur = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】2.两数相加</title>
    <link href="/2021/02/17/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/02/17/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储 一位数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><pre><code>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补0，比如 987 + 23 = 987 + 023 = 1010<br>每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值<br>如果两个链表全部遍历完毕后，进位值为1，则在新链表最前方添加节点1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode cur = dummy;<br>    <span class="hljs-comment">//carry表示进位值</span><br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> x = l1 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>        <span class="hljs-keyword">int</span> y = l2 == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>        <span class="hljs-keyword">int</span> sum = x + y + carry;<br>        <span class="hljs-comment">//更新向下一位的进位值</span><br>        carry = sum / <span class="hljs-number">10</span>;<br>        sum = sum % <span class="hljs-number">10</span>;<br>        cur.next = <span class="hljs-keyword">new</span> ListNode(sum);<br>        cur = cur.next;<br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>)<br>            l1 = l1.next;<br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>)<br>            l2 = l2.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)<br>        cur.next = <span class="hljs-keyword">new</span> ListNode(carry);<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】1579.保证图可完全遍历</title>
    <link href="/2021/02/17/1579.%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/"/>
    <url>/2021/02/17/1579.%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1579-保证图可完全遍历"><a href="#1579-保证图可完全遍历" class="headerlink" title="1579.保证图可完全遍历"></a>1579.保证图可完全遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：</p><ul><li>类型 1：只能由 Alice 遍历。</li><li>类型 2：只能由 Bob 遍历。</li><li>类型 3：Alice 和 Bob 都可以遍历（共享边）。</li></ul><p>给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的共享边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p><p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p><p><strong>示例</strong></p><pre><code>输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]输出：2解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]输出：0解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]输出：-1解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</code></pre><h2 id="方法（并查集-贪心）"><a href="#方法（并查集-贪心）" class="headerlink" title="方法（并查集 + 贪心）"></a>方法（并查集 + 贪心）</h2><p><strong>判断能否遍历整个图：</strong><br>因为要保证Alice和Bob两个人都可以遍历整个图，所以要分别为Alice和Bob构造单独的并查集。</p><p>初始时，两人的并查集中集合数目都为节点数n。如果最后Alice的并查集中集合数目变为1，说明所有的顶点在Alice的并查集中都被连接到了一起，即Alice可以遍历整个图。Bob同理。</p><p><strong>贪心策略</strong>：能使用共享边时就使用共享边，因为共享边让Alice和Bob在遍历时都可以使用。只用一条共享边就可以达到两条独享边的效果。因此我们先使用共享边对节点进行连接，之后再使用Alice和Bob的独享边进行连接。</p><p>注意：共享边同时可以连接Alice和Bob的并查集中的节点。而Alice的独享边只能连接Alice并查集中的节点。Bob的独享边只能连接Bob并查集中的节点。</p><p><strong>判断一条边可否删除：</strong><br>遍历到一条边时，只需要判断这条边的两个顶点此时在相应的并查集中是否已经在同一个集合内，如果是的话，那么就不再需要它进行连接，这条边可以删除。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxNumEdgesToRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges)</span> </span>&#123;<br>        UnionFindSet alice = <span class="hljs-keyword">new</span> UnionFindSet();<br>        UnionFindSet bob = <span class="hljs-keyword">new</span> UnionFindSet();<br>        List&lt;Integer&gt; nodes = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            nodes.add(i);<br>        alice.makeSet(nodes);<br>        bob.makeSet(nodes);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">//res代表可删除的边个数</span><br>        <span class="hljs-comment">//先遍历所有的双向边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            <span class="hljs-keyword">if</span>(edge[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">boolean</span> a = alice.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>                <span class="hljs-keyword">boolean</span> b = bob.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>                <span class="hljs-comment">//如果对于alice和bob，此边的两个顶点都已经在一个集合中，那么这条共享边可以删除</span><br>                <span class="hljs-keyword">if</span>(!a &amp;&amp; !b)<br>                    res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//再遍历单向边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] edge : edges)&#123;<br>            <span class="hljs-comment">//如果这条边是alice独享的，那么判断它的两个顶点在alice的并查集中是否已在一个集合中，若是，则可删除</span><br>            <span class="hljs-keyword">if</span>(edge[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">boolean</span> canUnion = alice.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>                res += canUnion ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//bob同理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(edge[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">boolean</span> canUnion = bob.union(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);<br>                res += canUnion ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果两人中至少有一人不能遍历整个图，那么返回-1</span><br>        <span class="hljs-keyword">return</span> alice.getSize() == <span class="hljs-number">1</span> &amp;&amp; bob.getSize() == <span class="hljs-number">1</span> ? res : -<span class="hljs-number">1</span>;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span></span>&#123;<br>    Map&lt;Integer, Integer&gt; fatherMap;<br>    Map&lt;Integer, Integer&gt; sizeMap;<br>    <span class="hljs-keyword">int</span> size;  <span class="hljs-comment">//size代表并查集中集合的数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFindSet</span><span class="hljs-params">()</span></span>&#123;<br>        fatherMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        sizeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(List&lt;Integer&gt; nodes)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> node : nodes)&#123;<br>            sizeMap.put(node, <span class="hljs-number">1</span>);<br>            fatherMap.put(node, node);<br>        &#125;<br>        size = nodes.size();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> father = fatherMap.get(node);<br>        <span class="hljs-keyword">if</span>(father != node)&#123;<br>            father = findHead(father);<br>        &#125;<br>        fatherMap.put(node, father);<br>        <span class="hljs-keyword">return</span> father;<br>    &#125;<br>    <span class="hljs-comment">//若成功进行union操作则返回true。</span><br>    <span class="hljs-comment">//若a和b已经在一个集合中，不需要进行union操作则返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> headA = findHead(a);<br>        <span class="hljs-keyword">int</span> headB = findHead(b);<br>        <span class="hljs-keyword">if</span>(headA != headB)&#123;<br>            <span class="hljs-keyword">int</span> sizeA = sizeMap.get(headA);<br>            <span class="hljs-keyword">int</span> sizeB = sizeMap.get(headB);<br>            <span class="hljs-keyword">if</span>(sizeA &lt; sizeB)&#123;<br>                fatherMap.put(headA, headB);<br>                sizeMap.put(sizeB, sizeA + sizeB);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                fatherMap.put(headB, headA);<br>                sizeMap.put(sizeA, sizeA + sizeB);<br>            &#125;<br>            size--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】160.相交链表</title>
    <link href="/2021/02/17/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h1><p><strong>题目：</strong><br>编写一个程序，找到两个单链表相交的起始节点。</p><p><strong>方法一：</strong><br>分三个步骤： </p><ol><li>获得两个链表的长度，相减得到长度差。</li><li>让长的链表先走长度差步</li><li>两个链表一起走，直到碰上相同的节点返回  </li></ol><p>注意：<br>边界处理 </p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lenA = getLength(headA);<br>    <span class="hljs-keyword">int</span> lenB = getLength(headB);<br>    <span class="hljs-keyword">int</span> diff = Math.abs(lenA - lenB);<br>    <span class="hljs-keyword">if</span>(lenA &gt; lenB)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; diff; i++)<br>            headA = headA.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lenB &gt; lenA)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; diff; i++)<br>            headB = headB.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(headA != headB)&#123;<br>        headA = headA.next;<br>        headB = headB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> headA;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        count++;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong><br>设链表A前半部分长度为a，链表B前半部分长度为b，链表A和链表B相交的部分长度为c。<br>易知：a + c + b = a + b + c</p><p>因此我们先让指针curA在链表A上走a+c步，走到链表A末尾后，再让curA从链表B的头部开始走，在链表B上再走b步。</p><p>同理：让指针curB在链表B上走b+c步，走到链表B末尾后，再让curB从链表A的头部开始走，在链表A上再走a步。</p><p>这样当两个指针都走了a+b+c步时，它们会相遇于两个链表的交点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>    ListNode curA = headA;<br>    ListNode curB = headB;<br>    <span class="hljs-keyword">while</span>(curA != curB)&#123;<br>        curA = (curA == <span class="hljs-keyword">null</span>) ? headB : curA.next;<br>        curB = (curB == <span class="hljs-keyword">null</span>) ? headA : curB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> curA;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】1663.具有给定数值的最小字符串</title>
    <link href="/2021/02/17/1663.%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/02/17/1663.%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1663-具有给定数值的最小字符串"><a href="#1663-具有给定数值的最小字符串" class="headerlink" title="1663.具有给定数值的最小字符串"></a>1663.具有给定数值的最小字符串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。</p><p>字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 “abe” 的数值等于 1 + 2 + 5 = 8 。</p><p>给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。</p><p>注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况：</p><p>x 是 y 的一个前缀；<br>如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。 </p><pre><code>示例 1：输入：n = 3, k = 27输出：&quot;aay&quot;解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。示例 2：输入：n = 5, k = 73输出：&quot;aaszz&quot;</code></pre><h2 id="方法（贪心算法）"><a href="#方法（贪心算法）" class="headerlink" title="方法（贪心算法）"></a>方法（贪心算法）</h2><p>假设当前来到了一个位置，要往这个位置放一个字符。包括这个位置在内还需要放n’个位置，这些位置的和为k’</p><p>放完这个位置后，剩余还有n’-1个位置，这些位置的和最大值为26(n’-1),最小值为n’-1。分别为全为z和全为a的情况。因此，只有满足：n’ - 1 &lt;= k’ - c &lt;= 26 * (n’ - 1) 时，我们才能往这个位置放字符c。即：c需要满足：k’ - 26(n’ - 1) &lt;= c &lt;= k’ - (n’ - 1)</p><p>我们的贪心策略总是希望放一个尽可能小的字符，因此我们就放c的下限：k’ - 26(n’ - 1)。如果这个下限小于0，我们就放a。否则，我们放这个下限对应的字符</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getSmallestString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    StringBuilder str = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> bound = k - <span class="hljs-number">26</span> * (n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(bound &gt; <span class="hljs-number">0</span>) &#123;<br>            str.append((<span class="hljs-keyword">char</span>) (bound + <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">1</span>));<br>            k -= bound;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            str.append(<span class="hljs-string">&#x27;a&#x27;</span>);<br>            k -= <span class="hljs-number">1</span>;<br>        &#125;<br>        n--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】234.回文链表</title>
    <link href="/2021/02/17/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>请判断一个链表是否为回文链表。</p><pre><code>示例 1:输入: 1-&gt;2输出: false示例 2:输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><h2 id="方法1：用栈"><a href="#方法1：用栈" class="headerlink" title="方法1：用栈"></a>方法1：用栈</h2><p>将链表中的节点全部放入一个栈中，由于栈的先进后出的特性，它依次弹出的顺序为链表的逆序。因此，依次比较链表节点和栈弹出的节点，就可以判断链表是否为回文链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    ListNode cur = head;<br>    <span class="hljs-comment">//将链表节点全部入栈</span><br>    Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;ListNode&gt;();<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        stack.push(cur);<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">//依次比较链表节点和栈中弹出节点</span><br>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span>(head.val != stack.pop().val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="方法2-反转链表"><a href="#方法2-反转链表" class="headerlink" title="方法2:反转链表"></a>方法2:反转链表</h2><p>彻底不用额外辅助空间的做法：<br>利用双指针，快指针一次走两步，慢指针一次走一步。快指针走完时，慢指针来到中点。然后将右半部分逆序。最后，一个指针指向链表尾，向前走，遍历右半部分；另一个指针指向链表头，向后走，遍历前半部分。依次比对这两个指<br>针所指元素是否相同。<br>注意：题目只让我们判断链表是否回文，我们不能改变题目给我们的结构，所以判断完之后别忘了把链表的指针恢复回来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    ListNode fast = head, slow = head;<br>    <span class="hljs-comment">//快指针走到末尾，慢指针走到中点</span><br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>)&#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">//从中点开始，反转后部分链表</span><br>    ListNode tail = reverseList(slow);<br>    ListNode head_cur = head, tail_cur = tail;<br>    <span class="hljs-comment">//分别从头和尾开始，比较链表节点</span><br>    <span class="hljs-keyword">while</span>(head_cur != <span class="hljs-keyword">null</span> &amp;&amp; tail_cur != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(head_cur.val != tail_cur.val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        head_cur = head_cur.next;<br>        tail_cur = tail_cur.next;<br>    &#125;<br>    <span class="hljs-comment">//恢复链表</span><br>    slow.next = reverseList(tail);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <br>&#125;<br><span class="hljs-comment">//反转以head为头节点的链表</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    ListNode pre = head, cur = pre.next;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        ListNode temp = cur;<br>        cur = cur.next;<br>        temp.next = pre;<br>        pre = temp;<br>    &#125;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】435.无重叠区间</title>
    <link href="/2021/02/17/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/02/17/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:<br>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><pre><code>示例 1:输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。示例 2:输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。示例 3:输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre><h2 id="方法（贪心算法）"><a href="#方法（贪心算法）" class="headerlink" title="方法（贪心算法）"></a>方法（贪心算法）</h2><p>题目要我们找最少需要移除多少个区间，实际上就是要找最多能选择多少个不重叠的区间。最后用总区间减去最多不重叠区间的个数，就是想要的结果。</p><p>贪心策略：选择不重叠的区间时，我们在不重叠的前提下，尽可能地选择长度最短的区间，这样可以给后面的区间留下更大的选择空间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Arrays.sort(intervals, <span class="hljs-keyword">new</span> Mycomparator());<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> bound = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] num : intervals)&#123;<br>        <span class="hljs-keyword">if</span>(num[<span class="hljs-number">0</span>] &gt;= bound)&#123;<br>            count++;<br>            bound = num[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> intervals.length - count;<br>&#125;<br><br>public class Mycomparator implements Comparator&lt;int[]&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] o1, <span class="hljs-keyword">int</span>[] o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】502.IPO</title>
    <link href="/2021/02/17/502.IPO/"/>
    <url>/2021/02/17/502.IPO/</url>
    
    <content type="html"><![CDATA[<h1 id="502-IPO"><a href="#502-IPO" class="headerlink" title="502 IPO"></a>502 IPO</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。</p><p>给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p><p>总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。</p><pre><code>示例 1:输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。</code></pre><h2 id="思路（贪心策略）"><a href="#思路（贪心策略）" class="headerlink" title="思路（贪心策略）"></a>思路（贪心策略）</h2><p>准备一个小根堆和一个大根堆。先将所有的项目放进小根堆，小根堆的堆顶为堆中cost最小的项目。然后让所有cost小于W的项目（即当前可以做的项目）进大根堆，大根堆的堆顶为profit最大的项目。每次从大根堆里取出项目做，每做完项目取得收益后W会更新，这时就会有新的项目从小根堆进入到大根堆。当做满了k个项目或者大根堆中没有项目可做时，结束。</p><p>每次在所有项目中找利润最高的项目做，是一种贪心策略。也符合生活中面临此类问题时的常规做法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//Project项目类包含两个实例域，p代指利润，c代指花销</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Project</span></span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> c;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Project</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.p = p;<br>            <span class="hljs-keyword">this</span>.c = c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个比较器，根据项目的花销值c比较Project（花销值小的Project小）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Project</span>&gt;</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Project o1, Project o2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> o1.c - o2.c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//定义一个比较器，根据项目的利润值p比较Project（利润值高的Project小）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Project</span>&gt;</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Project o1, Project o2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> o2.p - o1.p;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span>[] Profits, <span class="hljs-keyword">int</span>[] Capital)</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个项目数组并将其初始化</span><br>        Project[] projects = <span class="hljs-keyword">new</span> Project[Profits.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Profits.length; i++)&#123;<br>            projects[i] = <span class="hljs-keyword">new</span> Project(Profits[i], Capital[i]);<br>        &#125;<br>        <span class="hljs-comment">//准备两个堆，一个堆顶表示堆中cost最小的项目，另一个堆顶表示堆中profit最大的项目</span><br>        PriorityQueue&lt;Project&gt; minCostHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MinCostComparator());<br>        PriorityQueue&lt;Project&gt; maxProfitHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> MaxProfitComparator());<br>        <span class="hljs-keyword">for</span>(Project item: projects)&#123;<br>            minCostHeap.add(item);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-comment">//小根堆堆顶依次弹出进大根堆，直到堆顶大于w，遇到了没有足够资金做的项目为止</span><br>            <span class="hljs-keyword">while</span>(!minCostHeap.isEmpty() &amp;&amp; minCostHeap.peek().c &lt;= W)<br>                maxProfitHeap.add(minCostHeap.poll());<br>            <span class="hljs-comment">//循环结束时有两种可能，一种为已经做完了k个项目，另一种为没做到k个项目但能做到项目都做完了</span><br>            <span class="hljs-keyword">if</span>(maxProfitHeap.isEmpty())<br>                <span class="hljs-keyword">return</span> W;<br>            W += maxProfitHeap.poll().p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> W;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】252.会议室</title>
    <link href="/2021/02/17/252.%E4%BC%9A%E8%AE%AE%E5%AE%A4/"/>
    <url>/2021/02/17/252.%E4%BC%9A%E8%AE%AE%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="252-会议室"><a href="#252-会议室" class="headerlink" title="252.会议室"></a>252.会议室</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。</p><pre><code>示例 1：输入：intervals = [[0,30],[5,10],[15,20]]输出：false示例 2：输入：intervals = [[7,10],[2,4]]输出：true</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>将所有的会议按照开始时间排序，之后只需要判断在一个会议开始时，上一个会议是否结束即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canAttendMeetings</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    Arrays.sort(intervals, (v1, v2) -&gt; (v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253.会议室 II"></a>253.会议室 II</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi]，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p><pre><code>示例 1:输入: [[0, 30],[5, 10],[15, 20]]输出: 2示例 2:输入: [[7,10],[2,4]]输出: 1</code></pre><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><strong>基本思路</strong>：<br>如果我们能统计出每一个时刻要开会的会议数量，就能知道各时刻对于会议室数量的需求，则会议最繁忙的那个时刻需要的会议室数量就是我们想要的结果。只要我们的会议室数量满足了这个时刻的开会要求，则其他时刻都能够满足。</p><p><strong>算法流程</strong>：  </p><ul><li>因为我们要按时间顺序遍历，所以先将数组按照会议的开始时间排序</li><li>准备一个最小堆，堆中元素为每一个正在进行中会议的结束时间</li><li>遍历数组，如果发现在当前时刻，有已经过了结束时间但还在堆中的会议，便将其从堆中弹出。之后将当前的会议加入到堆中</li><li>在遍历过程中不断统计堆中元素的数量，这个数量代表一个时刻正在进行中的会议数量，也即对会议室数量的需求，这个需求的最大值即为结果。</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Arrays.sort(intervals, (v1, v2) -&gt; (v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>]));<br>    PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    <span class="hljs-keyword">int</span> meetingCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] meeting : intervals)&#123;<br>        <span class="hljs-keyword">while</span>(!heap.isEmpty() &amp;&amp; meeting[<span class="hljs-number">0</span>] &gt;= heap.peek())<br>            heap.poll();<br>        heap.add(meeting[<span class="hljs-number">1</span>]);<br>        meetingCount = Math.max(meetingCount, heap.size());<br>    &#125;<br>    <span class="hljs-keyword">return</span> meetingCount;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】621.任务调度器</title>
    <link href="/2021/02/17/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <url>/2021/02/17/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a>621. 任务调度器</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 最短时间 。 </p><pre><code>示例 1：输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出：8解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B    在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 示例 2：输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0输出：6解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;][&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;][&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]...诸如此类示例 3：输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2输出：16解释：一种可能的解决方案是：    A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>容易想到的一种贪心策略为：先安排出现次数最多的任务，让这个任务两次执行的时间间隔正好为n。再在这个时间间隔内安排其他的任务。</p><p>例如：tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2</p><p>我们先安排出现次数最多的任务”A”,并且让执行两个”A”的时间间隔2。在这个时间间隔内，我们用其他任务类型去填充，又因为其他任务类型只有”B”一个，不够填充2的时间间隔，因此额外需要一个冷却时间间隔。具体安排如下图所示：</p><p><img src="/img/621.png"></p><p>其中，maxTimes为出现次数最多的那个任务出现的次数。maxCount为一共有多少个任务和出现最多的那个任务出现次数一样。</p><p>图中一共占用的方格即为完成所有任务需要的时间，即：<br>$$(maxTimes - 1)*(n + 1) + maxCount$$</p><p>此外，如果任务种类很多，在安排时无需冷却时间，只需要在一个任务的两次出现间填充其他任务，然后从左到右从上到下依次执行即可，由于每一个任务占用一个时间单位，我们又正正好好地使用了tasks中的所有任务，而且我们只使用tasks中的任务来占用方格（没用冷却时间）。因此这种情况下，所需要的时间即为tasks的长度。</p><p>由于这种情况时再用上述公式计算会得到一个不正确且偏小的结果，因此，我们只需把公式计算的结果和tasks的长度取最大即为最终结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tasks, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tasks.length; i++)&#123;<br>        buckets[tasks[i] - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>    &#125;<br>    Arrays.sort(buckets);<br>    <span class="hljs-keyword">int</span> maxTimes = buckets[<span class="hljs-number">25</span>];<br>    <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span>(buckets[i] == buckets[i - <span class="hljs-number">1</span>])<br>            maxCount++;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = (maxTimes - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>) + maxCount;<br>    <span class="hljs-keyword">return</span> Math.max(res, tasks.length);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】61.旋转链表</title>
    <link href="/2021/02/17/61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61 旋转链表"></a>61 旋转链表</h1><p><strong>题目：</strong><br>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL  </p><p>示例 2:<br>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL  </p><p><strong>思路：</strong><br>只需要O(n)时间复杂度的算法：</p><ul><li>求出链表的长度n</li><li>k = k % n</li><li>用双指针法找到链表倒数第k个位置</li><li>记录慢指针的next节点，这就是要返回链表的头结点</li><li>从慢指针的next节点开始断开链接，后一段的尾结点指向前一段的头结点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> length = getLength(head);<br>        k = k % length;<br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">1</span> || k == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k;i++)&#123;<br>            <span class="hljs-comment">//找到倒数第二个节点</span><br>            ListNode cur = head;<br>            <span class="hljs-keyword">while</span>(cur.next.next != <span class="hljs-keyword">null</span>)<br>                cur = cur.next;<br>            <span class="hljs-comment">//在倒数第二个节点的地方进行操作</span><br>            cur.next.next= head;<br>            head = cur.next;<br>            cur.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-keyword">null</span>)&#123;<br>            cur = cur.next;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】82.删除排序链表中的重复元素 II</title>
    <link href="/2021/02/17/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/"/>
    <url>/2021/02/17/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82 删除排序链表中的重复元素 II"></a>82 删除排序链表中的重复元素 II</h1><p><strong>题目：</strong><br>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:<br>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:<br>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3  </p><p><strong>思路：</strong><br>在迭代过程中，如果cur.next.val == cur.next.next.val说明此时有重复元素，此时创建一个临时指针temp，指向cur的下一个节点，即temp指向的第一个重复元素所在的位置。通过while循环去重，去重后，temp指向的是重复元素中的最后一个位置。最后cur.next = temp.next就实现了消除重复元素。<br>当然，如果未发现重复元素，则直接向后迭代即可。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">//为了防止删除的是头节点，新建一个节点dummy，在头节点之前</span><br>    <span class="hljs-comment">//cur从dummy开始遍历</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br>    ListNode cur = dummy;<br>    <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-comment">//当cur之后开始重复时，新建一个节点temp指向重复的第一个节点</span><br>        <span class="hljs-keyword">if</span>(cur.next.val == cur.next.next.val)&#123;<br>            ListNode temp = cur.next;<br>            <span class="hljs-comment">//然后temp不断移动到该重复的最后一个节点</span><br>            <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span> &amp;&amp; temp.val == temp.next.val)<br>                temp = temp.next;<br>            <span class="hljs-comment">//temp标记着重复的最后一个节点。让cur的下一个节点指向它之后，即跳过了所有重复节点</span><br>            cur.next = temp.next;<br>        &#125;<br>        <span class="hljs-comment">//如果cur之后不遇到重复节点，则cur正常向后移动</span><br>        <span class="hljs-keyword">else</span><br>            cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong><br>对于此类链表题目，为了防止删除头节点的极端情况的产生。设置一个空结点dummy，使dummy指向传入的head头节点。cur遍历链表从dummy结点开始。最后函数返回dummy.next即head。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】861.翻转矩阵后的得分</title>
    <link href="/2021/02/17/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/"/>
    <url>/2021/02/17/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a>861. 翻转矩阵后的得分</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><p> </p><pre><code>示例：输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出：39解释：转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</code></pre><h2 id="方法（贪心算法）"><a href="#方法（贪心算法）" class="headerlink" title="方法（贪心算法）"></a>方法（贪心算法）</h2><p>因为我们想要让数字总和最大，那么就需要让每一行的所代表的数字尽可能大。又因为矩阵中的第一列是每一行代表数字的最高位。</p><p>因此第一步：我们先遍历第一列的各个行，如果发现有元素为0，将该行进行转换。（让最高位尽可能大）</p><p>第一步结束后，每一行的最高位就都为1了。而对于之后的每一列，我们统计列中0的个数和1的个数，如果0的个数大于1的个数，则将该列进行转换。（让一列中1的个数尽可能多）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贪心策略：</span><br><span class="hljs-comment">//第一步：遍历第一列的各行，如果发现有0的，将此行转换</span><br><span class="hljs-comment">//第二步：从第二列起遍历各列，如果一列中0的个数高于1的个数，将该列转换</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] A;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matrixScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] A)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.A = A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(A[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>            reverseRow(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; A[<span class="hljs-number">0</span>].length; j++)&#123;<br>        <span class="hljs-keyword">int</span> count0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i][j] == <span class="hljs-number">0</span>)<br>                count0++;<br>            <span class="hljs-keyword">if</span>(count0 &gt; A.length / <span class="hljs-number">2</span>)&#123;<br>                reverseCol(j);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; A[<span class="hljs-number">0</span>].length; j++)&#123;<br>            num = (num &lt;&lt; <span class="hljs-number">1</span>) + A[i][j];<br>        &#125;<br>        res += num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; A[<span class="hljs-number">0</span>].length; j++)&#123;<br>        A[i][j] = A[i][j] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseCol</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>        A[i][j] = A[i][j] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法改进"><a href="#方法改进" class="headerlink" title="方法改进"></a>方法改进</h2><p>在上述方法第二步中，我们真的需要对列进行转换吗？</p><p>实则不然。考虑在二进制的表示中，一个位数上的1对结果的贡献其实是相同的。就比如：1100和1111，这两个二进制表示中次高位的1对结果的贡献都为4。</p><p>而A中的同一列又代表着相同的位数。因此我们只需要统计该列中0的数量和1的数量即可：</p><ul><li>如果一列中0的数量大于1的数量，则该列将被反转（并不实际需要反转操作），反转前的count0就是反转后的1的数量，于是用count0对结果进行更新</li><li>如果一列中1的数量大于0的数量，则该列不需要反转，直接用count1对结果进行更新<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] A;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">matrixScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] A)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.A = A;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>        <span class="hljs-comment">//如果当前位置为0，那么它之后要转换成为1</span><br>        <span class="hljs-comment">//所有行在第0列（最高位）的1对结果的贡献都是一样的，因此再这里直接对res进行更新</span><br>        <span class="hljs-keyword">if</span>(A[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>            reverseRow(i);<br>        &#125;<br>        res += (<span class="hljs-number">1</span> &lt;&lt; (A[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; A[<span class="hljs-number">0</span>].length; j++)&#123;<br>        <span class="hljs-keyword">int</span> count0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i][j] == <span class="hljs-number">0</span>)<br>                count0++;<br>            <span class="hljs-keyword">else</span><br>                count1++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count0 &gt; count1)<br>            res += count0 * (<span class="hljs-number">1</span> &lt;&lt; (A[<span class="hljs-number">0</span>].length - j - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span><br>            res += count1 * (<span class="hljs-number">1</span> &lt;&lt; (A[<span class="hljs-number">0</span>].length - j - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//转换A的第i行</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; A[<span class="hljs-number">0</span>].length; j++)&#123;<br>        A[i][j] = A[i][j] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】92.反转链表 II</title>
    <link href="/2021/02/17/92.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2021/02/17/92.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92 反转链表 II"></a>92 反转链表 II</h1><p><strong>题目：</strong><br>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>$1 ≤ m ≤ n ≤$链表长度。<br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><p><strong>思路：</strong>  </p><ol><li><p>我们定义两个指针，分别称之为cur和pre。我们首先根据方法的参数m确定cur和pre的位置。将pre移动到第一个要反转的节点的前面，将cur移动到第一个要反转的节点的位置上</p></li><li><p>将cur后面的元素删除，然后添加到pre的后面。也即头插法。</p></li><li><p>根据m和n重复步骤2</p></li></ol><p><strong>注意:</strong><br>不能依赖头节点作pre，头节点的下一个节点做cur。这样的话当m=1时即第一个节点也要参与反转时就不适用了。于是建立一个在head前面的节点，并将它和链表联系起来，在通过它将pre和cur初始化</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//新建一个节点，并将这个节点和原有链表联系起来</span><br>    ListNode preHeadNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    preHeadNode.next = head;<br>    <span class="hljs-comment">//新建并初始化两个指针</span><br>    ListNode pre = preHeadNode;<br>    ListNode cur = preHeadNode.next;<br>    <span class="hljs-comment">//移动这两个指针，直到cur指向要反转的第一个节点，pre指向它的前面</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++)&#123;<br>        cur = cur.next;<br>        pre = pre.next;<br>    &#125;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - n;i++)&#123;<br>        <span class="hljs-comment">//先拿到要删除（即要插入）的节点</span><br>        ListNode remove = cur.next;<br>        <span class="hljs-comment">//经过下面这步，跳过了cur的下一个节点。达到了把这个节点删除的效果</span><br>        cur.next = cur.next.next;<br>        <span class="hljs-comment">//接下来是插入操作</span><br>        remove.next = pre.next;<br>        pre.next = remove;<br>    &#125;<br>    <span class="hljs-keyword">return</span> preHeadNode.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】86.分割链表</title>
    <link href="/2021/02/17/86.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/02/17/86.%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="86-分割链表"><a href="#86-分割链表" class="headerlink" title="86 分割链表"></a>86 分割链表</h1><p><strong>题目：</strong><br>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p><strong>示例:</strong><br>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><p><strong>思路：</strong></p><ul><li>建立两个链表min和max，分别收集小于x的元素和大于等于x的元素。头结点分别设为两个哑节点minhead和maxhead，也就是说实际的第一个节点为哑节点的next。</li><li>遍历原有链表的每一个元素，若元素值小于x，则放入min链表中，若元素值大于等于x，则放入max链表中。</li><li>遍历完所有元素之后，将min链表和max链表连接，max的最后指向null，min的最后指向max的开头，即maxhead.next</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    ListNode minhead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode mincur = minhead;<br>    ListNode maxhead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode maxcur = maxhead;<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(cur.val &lt; x)&#123;<br>            mincur.next = cur;<br>            mincur = mincur.next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            maxcur.next = cur;<br>            maxcur = maxcur.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    maxcur.next = <span class="hljs-keyword">null</span>;<br>    mincur.next = maxhead.next;<br>    <span class="hljs-keyword">return</span> minhead.next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：O(n)</strong><br><strong>空间复杂度：O(1)</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】225.用队列实现栈</title>
    <link href="/2021/02/16/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2021/02/16/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225 用队列实现栈"></a>225 用队列实现栈</h1><p><strong>注意</strong>: 队列的基本操作为add和poll和isEmpty，栈的基本操作为push和pop和empty</p><p><strong>思路：</strong>  </p><ul><li><p>准备两个队列，一个queue队列一个help队列</p></li><li><p>执行push操作时，只向queue队列中add元素</p></li><li><p>执行pop操作时，将queue中元素弹入help中，只剩下一个需要弹出的元素，将queue中剩下的这一个元素保存后弹出。 最后，将help和queue互换，因为此时queue已弹空，原来queue元素均导入到help中。为了实现任何入列都是入到queue中，因此需将两个队列互换  </p></li><li><p>执行peek操作时，与pop操作大体相同。只是peek并未真要弹出栈顶元素，只是取出而已。所以需要将这个元素也加进help中。最终的效果相当于把queue中元素均加入到help中，再将help与queue互换  </p></li><li><p>queue队列为空栈即为空  </p></li><li><p>*代码：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;<br><br>    Queue&lt;Integer&gt; queue1;<br>    Queue&lt;Integer&gt; help;<br>    <br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;<br>        queue1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        help = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">//只向队列queue中push元素</span><br>        queue1.add(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//将queue中元素弹入help中，只剩下一个需要弹出的元素</span><br>        <span class="hljs-keyword">while</span>(queue1.size() != <span class="hljs-number">1</span>)<br>            help.add(queue1.poll());<br>        <span class="hljs-comment">//将queue中剩下的这一个元素保存后弹出</span><br>        <span class="hljs-keyword">int</span> res = queue1.poll();<br>        <span class="hljs-comment">//将help和queue互换</span><br><span class="hljs-comment">//因为此时queue已弹空，原来queue元素均导入到help中。</span><br><span class="hljs-comment">//为了实现任何入列都是入到queue中，因此需将两个队列互换</span><br>        swap();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-comment">//取队顶元素的peek操作大体与pop相同，只是peek并未真要弹出栈顶元素，只是取出而已</span><br><span class="hljs-comment">//所以需要将这个元素也加进help中。最终的效果相当于把queue中元素均加入到help中，再将help与queue互换</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(queue1.size() != <span class="hljs-number">1</span>)<br>            help.add(queue1.poll());<br>        <span class="hljs-keyword">int</span> res = queue1.poll();<br>        help.add(res);<br>        swap();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.isEmpty();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">()</span> </span>&#123;<br>        Queue&lt;Integer&gt; tmp = help;<br>        help = queue1;<br>        queue1 = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】5614.找出最具竞争力的子序列</title>
    <link href="/2021/02/16/5614.%E6%89%BE%E5%87%BA%E6%9C%80%E5%85%B7%E7%AB%9E%E4%BA%89%E5%8A%9B%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/02/16/5614.%E6%89%BE%E5%87%BA%E6%9C%80%E5%85%B7%E7%AB%9E%E4%BA%89%E5%8A%9B%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="5614-找出最具竞争力的子序列"><a href="#5614-找出最具竞争力的子序列" class="headerlink" title="5614.找出最具竞争力的子序列"></a>5614.找出最具竞争力的子序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。</p><p>在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。</p><pre><code>示例 1：输入：nums = [3,5,2,6], k = 2输出：[2,6]解释：在所有可能的子序列集合 &#123;[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]&#125; 中，[2,6] 最具竞争力。示例 2：输入：nums = [2,4,3,3,5,4,9,6], k = 4输出：[2,3,3,4]</code></pre><h2 id="方法（单调栈）"><a href="#方法（单调栈）" class="headerlink" title="方法（单调栈）"></a>方法（单调栈）</h2><p>单调栈可以用于寻找在一个数组中，一个元素右边比它大的最小元素是谁，以及左边比它小的最大元素是谁。</p><p>而反观这道题，要寻找最具竞争力的子序列，不就是不断地在一个元素右边尽可能找到一个比它大的更小的元素吗</p><p>算法步骤如下：<br>准备一个栈，这个栈需要保持从栈底到栈顶元素大小从小到大，依次遍历数组中的每个元素</p><ul><li>如果该元素小于栈顶，并且这时弹出栈顶不会造成栈中元素和数组中剩余元素加在一起都凑不到k的情况，那么就放心弹出栈顶</li><li>如果该元素大于栈顶，并且栈中元素尚未到K，那么就将该元素入栈。</li><li>最后，将这个大小为K的栈弹出作为结果。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] mostCompetitive(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    stack.push(nums[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; nums[i] &amp;&amp; stack.size() + nums.length - i &gt; k)&#123;<br>            stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stack.size() &lt; k)<br>            stack.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        res[i] = stack.pop();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】232.用栈实现队列</title>
    <link href="/2021/02/16/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/02/16/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h1><p><strong>思路：</strong>  </p><ul><li><p>准备两个栈，一个push栈，一个pop栈</p></li><li><p>执行push操作时，只向push栈中添加元素</p></li><li><p>执行pop操作时，若pop栈为空，则先将push栈中的元素全倒入到pop栈中，然后弹出pop栈的栈顶</p></li><li><p>执行peek操作时，和pop操作基本相同</p></li><li><p>当push栈和pop栈均为空时，队列为空</p></li><li><p>*代码：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackPop;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackPush; <br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stackPop = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">this</span>.stackPush = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stackPush.push(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//当pop栈为空时，将push栈中的元素都加入到pop栈中来</span><br>        <span class="hljs-keyword">if</span>(stackPop.empty())&#123;<br>            <span class="hljs-keyword">while</span>(!stackPush.empty())<br>                stackPop.push(stackPush.pop());<br>        &#125;<br>        <span class="hljs-comment">//pop不空时，直接弹出pop栈的栈顶</span><br>        <span class="hljs-keyword">return</span> stackPop.pop();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-comment">//除了最后一行外，和pop操作基本一致</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//当pop栈为空时，将push栈中的元素都加入到pop栈中来</span><br>        <span class="hljs-keyword">if</span>(stackPop.empty())&#123;<br>            <span class="hljs-keyword">while</span>(!stackPush.empty())<br>                stackPop.push(stackPush.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> stackPop.peek();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackPush.empty() &amp;&amp; stackPop.empty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】72.编辑距离</title>
    <link href="/2021/02/16/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2021/02/16/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符     </p><pre><code>示例 1：输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)示例 2：输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义dp[i][j] 为 word1的前i个字符word1[0…i-1]转换成word2的前j个字符word2[0…j-1]需要的最少操作数</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><ul><li>首先，空串到到空串不需要任何操作。因此dp[0][0] = 0</li><li>i=0时，要找空串word1匹配到word2前j个字符的最小步数，也即对word1进行插入操作的数量,也就是j</li><li>j=0时，要找word1前i个字符匹配到空串word2的最小步数，也即对word1进行删除操作的数量，也就是i</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><ul><li>当word1[i-1]等于word2[j-1]时，相当于在这一步不需要任何操作，因此dp[i][j] = dp[i-1][j-1]</li><li>当word1[i-1]不等于word2[j-1]，可以对word1[i-1]进行替换、插入、删除三种操作<ol><li><p>替换：将word1[i-1]替换成word2[j-1],需要一次操作。替换后二者相等，于是：dp[i][j] = dp[i - 1][j - 1] + 1</p></li><li><p>插入：在word1[i-1]后面插入与word2[j-1]相等的字符，需要一次操作，插入的字符和word2[j-1]匹配，二者抵消，在word2中就不用再考虑word2[j-1]位置了。于是：dp[i][j] = dp[i][j - 1] + 1</p></li><li><p>删除：既然word1[i-1]与word2[j-1]不相等，那我们就删除掉word1[i-1]这个字符，需要一次操作。于是：dp[i][j] = dp[i - 1][j] + 1  </p><p>最后取上述三种操作的最小值即为dp[i][j],即：<br>$$dp[i][j] = min(dp[i - 1][j - 1],dp[i - 1][j - 1],dp[i - 1][j]) + 1$$</p></li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= word1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= word2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】503.下一个更大元素II</title>
    <link href="/2021/02/16/503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/"/>
    <url>/2021/02/16/503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><pre><code>示例 1:输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre><h2 id="方法（栈）"><a href="#方法（栈）" class="headerlink" title="方法（栈）"></a>方法（栈）</h2><p>题目的核心是要找一个数右边最近的比它大的数，因此我们想到用单调栈来解决。</p><p>但此题的特点在于，给定数组是一个循环数组。也就是说：对于数组中的一个数来说，下一个比它大的数可能在它的右边，也可能在它的左边。</p><p>那么最直观的方法，就是拿原来的两个数组拼成一个新数组，然后对这个新数组应用单调栈的流程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length * <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>        arr[i] = nums[i % nums.length];<br>    &#125;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[i] &gt; arr[stack.peek()])&#123;<br>            <span class="hljs-keyword">int</span> index = stack.pop();<br>            arr[index] = arr[i];<br>        &#125;<br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span> index = stack.pop();<br>        arr[index] = -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Arrays.copyOf(arr, nums.length);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以不构造新数组，用”%”运算符来模拟循环数组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] nextGreaterElements(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++)&#123;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()])&#123;<br>            <span class="hljs-keyword">int</span> index = stack.pop();<br>            arr[index] = nums[i % n];<br>        &#125;<br>        <span class="hljs-comment">//注意，当i大于n小于2n时，不再需要将元素重复入栈</span><br>        <span class="hljs-keyword">if</span>(i &lt; n)<br>            stack.push(i % n);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span> index = stack.pop();<br>        arr[index] = -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】71.简化路径</title>
    <link href="/2021/02/16/71.%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/02/16/71.%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71.简化路径"></a>71.简化路径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。</p><p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p><pre><code>示例 1：输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。示例 2：输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。示例 3：输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。示例 4：输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot;示例 5：输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot;示例 6：输入：&quot;/a//b////c/d//././/..&quot;输出：&quot;/a/b/c&quot;</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>用栈解决，具体步骤如下：</p><ul><li>先将给定路径以”/“分割，分割得到的元素可能包含”.” , “..” , “”这三种特殊情况以及正常的目录。</li><li>如果遍历到正常的目录，则入栈。如果遍历到””和”.”,不入栈。如果遍历到”..”,则弹出栈顶目录。</li><li>遍历栈中的每一层目录，拼出规范路径的结果res</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">simplifyPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>    Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(String str: path.split(<span class="hljs-string">&quot;/&quot;</span>))&#123;<br>        <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;..&quot;</span>))&#123;<br>            <span class="hljs-keyword">if</span>(!stack.isEmpty())<br>                stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(!str.isEmpty() &amp;&amp; !str.equals(<span class="hljs-string">&quot;.&quot;</span>))<br>                stack.push(str);<br>        &#125;<br>    &#125;<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(String str: stack)<br>        res += <span class="hljs-string">&quot;/&quot;</span> + str;<br>    <span class="hljs-keyword">return</span> res.isEmpty() ? <span class="hljs-string">&quot;/&quot;</span> : res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/simplify-path/solution/zhan-by-powcai/">leetcode题解区</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】739.每日温度</title>
    <link href="/2021/02/16/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <url>/2021/02/16/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><pre><code>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</code></pre><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><h2 id="方法（单调栈）"><a href="#方法（单调栈）" class="headerlink" title="方法（单调栈）"></a>方法（单调栈）</h2><p>题目的意思为：要我们对于数组中的每一个数，找到右边最近的比它大的那个数离它有多远</p><p><strong>对于在数组中寻找左右两边最近的比它大或比它小的数的情况，我们可以使用单调栈来解决。</strong></p><p>算法流程：<br>准备一个栈，然后遍历数组：</p><ul><li><p>如果当前元素比栈顶元素小，那么直接入栈。</p></li><li><p>如果当前元素比栈顶元素大，那么不断地将栈顶元素弹出，直到当前元素比栈顶元素小为止，再将当前元素入栈。以让栈保持从栈底到栈顶从大到小的单调性。</p></li><li><p>每当栈中一个元素弹出时，说明让它弹出的那个元素就是它右边最近的比它大的元素。我们这时进行结算，它们之间的距离就是它们在数组中的位置（索引）之差。也正因为如此，为了方便，我们在将元素入栈出栈时，都针对的是它在数组中的索引，而不是它具体的值。</p></li><li><p>当遍历完所有元素后，如果栈中还有元素没有弹出，说明这些元素没有遇到右边比它大的元素，将结果数组中这些元素对应的位置处置0</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T.length; i++)&#123;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()])&#123;<br>            <span class="hljs-keyword">int</span> index = stack.pop();<br>            res[index] = i - index;<br>        &#125;<br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span> index = stack.pop();<br>        res[index] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】 84.柱状图中最大的矩形</title>
    <link href="/2021/02/16/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <url>/2021/02/16/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><pre><code>例如:height = [4,3,2,5,6].则柱状图中每一竖列的高分别为4，3，2，5，6。能找到的最大矩形即为以5为底，以2为高的矩形。面积为10.</code></pre><h2 id="方法（单调栈）"><a href="#方法（单调栈）" class="headerlink" title="方法（单调栈）"></a>方法（单调栈）</h2><p>依次计算以每一竖列为高的所有矩形中最大的面积。即统计从一个竖列向左右扩，左边和右边分别能扩多远（如果在左右遇到了低于它的竖列，则无法扩）。</p><p>我们维护一个单调栈结构来做到这一点（由栈底到栈顶，元素大小从小到大），准备一个栈。先将第一个元素入栈。之后尝试将数组中的每一个元素入栈。</p><ul><li>如果要加入的元素小于栈顶元素，那么为了维护栈的单调性，将栈顶依次弹出，直到栈顶元素小于要加入元素了，将元素入栈。对于弹出的每个元素，都代表着直方图中的每一个竖列。弹出时进行结算，此单调栈的原则是：谁让它弹出，谁就是它右边最近比它小的。而它在栈中下面的那个元素代表着它左边最近比它小的。因此，知道它左右两边最近比它小的，就可以知道以它为竖列的最大矩形面积。</li><li>如果要加入的元素大于栈顶元素，符合栈的单调性，直接入栈。</li></ul><p>当遍历完数组中的所有元素后，如果栈非空，将栈中元素弹空。每弹出一个元素，对它进行结算。计算以它为竖列的最大矩形面积。对于这些元素，因为没有元素使得它弹出，因此它没有右边比它小的元素，它可以扩到直方图的最右边。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxRecFromBottom</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height.length; i++)&#123;<br>        <span class="hljs-comment">//如果要加入的元素小于栈顶元素，将栈顶依次弹出。弹出时进行结算</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &lt;=height[stack.peek()])&#123;<br>            <span class="hljs-keyword">int</span> j = stack.pop();<br>            <span class="hljs-comment">//k是以j为竖列能扩到的左边界。即它在栈中下面的那个元素。</span><br>            <span class="hljs-comment">//如果j弹出时，它下面没元素，那么左边界为-1.否则，它的左边界为它下面那个元素在数组中的下标。</span><br>            <span class="hljs-keyword">int</span> k = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>            <span class="hljs-comment">//遍历到i位置令j弹出，因此i为以j为竖列能扩到的右边界。</span><br>            <span class="hljs-comment">//所以以j为竖列能扩出的最大矩形：底为i - k - 1。高为height[j]</span><br>            <span class="hljs-keyword">int</span> curArea = (i - k - <span class="hljs-number">1</span>) * height[j];<br>            maxArea = Math.max(maxArea, curArea);<br>        &#125;<br>        <span class="hljs-comment">//否则，直接将元素入栈。</span><br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-comment">//在对数组遍历完后，对于栈中剩余的那些元素，不要忘记结算。</span><br>    <span class="hljs-comment">//因为没有元素令它们弹出，所以它们在右边没有比它们小的元素。向右可以扩到头height.length</span><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        <span class="hljs-keyword">int</span> j = stack.pop();<br>        <span class="hljs-keyword">int</span> k = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>        <span class="hljs-keyword">int</span> curArea = (height.length - k - <span class="hljs-number">1</span>) * height[j];<br>        maxArea = Math.max(maxArea, curArea);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】20.有效的括号</title>
    <link href="/2021/02/15/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/02/15/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h1><p><strong>题目：</strong><br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>  示例 1:<br>  输入: “()”<br>  输出: true  </p><p>  示例 2:<br>  输入: “()[]{}”<br>  输出: true  </p><p>  示例 3:<br>  输入: “(]”<br>  输出: false </p><p>  示例 4:<br>  输入: “([)]”<br>  输出: false  </p><p>  示例 5:<br>  输入: “{[]}”<br>  输出: true  </p><p><strong>思路：</strong><br>核心思路是用栈来解决问题，哈希表用来简化问题。遍历整个字符串的每一个字符，如果是左括号则入栈；如果是右括号，则判断栈顶是否是它所对应的左括号，如果不是直接返回true，如果是则将栈顶的左括号弹出。这样一来，遍历完整个字符串后，如果栈中还有元素，则说明没有完全匹配，返回false。如果遍历完栈空了，则返回true。<br>哈希表是用来将右括号（key）和左括号（value）对应起来。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Character, Character&gt; map;<br>    <span class="hljs-comment">//构造器中初始化mappings</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//将哈希表map中放入三个键值对</span><br>        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Character&gt;();<br>        <span class="hljs-keyword">this</span>.map.put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-keyword">this</span>.map.put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        <span class="hljs-keyword">this</span>.map.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-comment">//如果目前的字符是一个右括号</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.map.containsKey(c))&#123;<br>                <span class="hljs-comment">//获得栈顶元素，如果栈顶是空，则记为#</span><br>                <span class="hljs-keyword">char</span> topElement = stack.empty() ? <span class="hljs-string">&#x27;#&#x27;</span> : stack.pop();<br>                <span class="hljs-comment">//若栈顶不等于对应的左括号，直接返回false</span><br>                <span class="hljs-keyword">if</span> (topElement != <span class="hljs-keyword">this</span>.map.get(c))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">//否则栈顶等于对应的左括号，则什么都不用做，上面已经把栈顶pop了</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果目前字符是一个左括号，就把它压进栈</span><br>                stack.push(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果经过上述遍历，栈中仍有元素，则返回false。</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2020-8-14二刷更新"><a href="#2020-8-14二刷更新" class="headerlink" title="2020.8.14二刷更新"></a>2020.8.14二刷更新</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>我们先分析有效括号的定义：</p><ul><li>首先，对于每一个出现过的左括号，之后都需要出现一个相对应的右括号。</li><li>其次，“括号必须以正确的顺序括回”。这句话可以理解为：在当前遍历到的左括号仍然完全全部匹配时，第一个出现的左括号，必须要与最后一个出现的右括号对应，最后一个出现的左括号，必须要与第一个出现的右括号对应。（如示例5）</li></ul><p>这样的先入后出的顺序自然让我们想到了栈结构。因此我们可以借助一个栈来实现算法。算法流程如下：</p><ul><li>准备一个栈，之后依次遍历字符串的每一个字符</li><li>如果遍历到左括号，则将一个相应的右括号加入到栈中。</li><li>如果遍历到右括号，则检查这个右括号和栈顶的右括号类型是否相等，如果不相等或栈中不存在可以比较的括号了，则不匹配直接返回false。如果相等则弹出这个栈中元素，继续向下遍历。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-comment">//遍历到左括号的情况</span><br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>            stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        <span class="hljs-comment">//遍历到右括号的情况</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || s.charAt(i) != stack.peek())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">else</span><br>                stack.pop();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2021-1-3三刷更新"><a href="#2021-1-3三刷更新" class="headerlink" title="2021.1.3三刷更新"></a>2021.1.3三刷更新</h1><p>从头到尾遍历字符串</p><ul><li>如果当前字符为左括号，则将这个左括号入栈</li><li>如果当前字符是右括号，则比较当前栈顶的左括号是否和它对应，如果对应则匹配，可以将这个左括号出栈了。如果不匹配或者栈已空（没有左括号来和这个右括号匹配了），则返回false。</li><li>遍历完字符串后，如果栈中还有尚未匹配的左括号，则返回false。否则返回true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;]&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || map.get(stack.peek()) != s.charAt(i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            stack.push(s.charAt(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFPRT算法</title>
    <link href="/2021/02/15/BFPRT%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/BFPRT%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="BFPRT算法"><a href="#BFPRT算法" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h1><h2 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h2><p>在无序数组中找到第K小的数，时间复杂度O(N)</p><h2 id="基于partition思路的算法"><a href="#基于partition思路的算法" class="headerlink" title="基于partition思路的算法"></a>基于partition思路的算法</h2><p>和快速排序中partition的思想有些相像。比如说我们要在长度为1000的数组中找到第n小的数，于是我们现在数组中随机找一个数进行partition的过程，小于它的放左边，等于它的放中间，大于它的放右边。完成后的情况如下图所示，等于区域范围为500-600</p><p><img src="/img/BFPRT.jpg"></p><p>因为我们要找第n小的数，因此：</p><ul><li>如果500 &lt; n &lt; 600,因此这个第n小的数就在等于区域，即我们进行partition的基准元素。</li><li>如果n &lt; 500, 那么这个第n小的数肯定在小于区域，我们继续对小于区域进行partition过程。</li><li>如果n &gt; 600，那么这个第n小的数肯定在大于区域，我们继续对大于区域进行partition过程。</li></ul><p>该算法的平均时间复杂度基于概率，其长期期望为:O(N)</p><h2 id="BFPRT算法-1"><a href="#BFPRT算法-1" class="headerlink" title="BFPRT算法"></a>BFPRT算法</h2><p>BFPRT算法的时间复杂度不基于概率，严格O(N)</p><p>BFPRT与上述算法的唯一区别在于：<strong>选择partition基准元素的这一步不是随机选取的</strong>。一旦选好了这个基准元素，之后的过程和上述算法相同。 </p><p>选择基准元素的方式：</p><ol><li>先将长度为N的数组进行分组，每5个元素一组</li><li>在每一组的组内进行排序(组间不排序)，也即将每一个长度为5的小组排序，小组内排序的时间复杂度为O(1)，一共有N/5个小组，因此这一步的时间复杂度为O(N)</li><li>将每一小组的中位数拿出来，构成一个长度为N/5的新数组</li><li>递归调用BFPRT算法，找到新数组中的中位数num</li><li>将这个元素num作为基准元素，进行partition</li></ol><p>为什么要这么选基准元素：<br>num在长度为N/5的新数组中是中位数，因此这个新数组中有N/10个数比num大，这N/10个数中的每个数a在它的原数组里又是中位数，即长度为5的原数组中有2个数比a大。因此，所有比num大的数统计起来，至少有$3N/10$个，也即最多有$7N/10$个数比num小.</p><p>同理，如果统计比num小的数，发现至少也有$3N/10$个数比它小，即最多有$7N/10$个数比num大.</p><p>那么我们用这个num做划分进行partition，会发现最多就有$7N/10$个数比它大，也最多有$7N/10$个数比它小。因此，下一步partition的范围最多也就是$7N/10$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>选基准元素的代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在arr中从begin到end间的元素范围内，选基准元素的过程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">medianOfMedians</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num = end - begin + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> offset = num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//mArr为中位数构成的新数组</span><br>    <span class="hljs-keyword">int</span>[] mArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num / <span class="hljs-number">5</span> + offset];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mArr.length; i++)&#123;<br>        <span class="hljs-comment">//beginI和endI为每个长度为5的小组的首尾</span><br>        <span class="hljs-keyword">int</span> beginI = begin + i * <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">int</span> endI = beginI + <span class="hljs-number">4</span>;<br>        <span class="hljs-comment">//取出每个小组的中位数，构成新数组</span><br>        mArr[i] = getMedian(arr, beginI, Math.min(end, endI));<br>    &#125;<br>    <span class="hljs-comment">//返回新数组的中位数</span><br>    <span class="hljs-keyword">return</span> bfprt(mArr, <span class="hljs-number">0</span>, mArr.length - <span class="hljs-number">1</span>, mArr.length / <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">//返回数组arr中从begin到end间所有元素的中位数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - begin + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)<br>        res[index++] = arr[i];<br>    Arrays.sort(res);<br>    <span class="hljs-keyword">return</span> res[res.length / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>获得基准元素pivot后，以它为基准进行partition操作，并进入BFPRT流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinKthByBFPRT</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[] copyArr = Arrays.copyOf(arr, arr.length);<br>    <span class="hljs-keyword">return</span> bfprt(copyArr, <span class="hljs-number">0</span>, copyArr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//bfprt算法主体，在begin和end间的范围里求第i小的数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfprt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(begin == end)<br>        <span class="hljs-keyword">return</span> arr[begin];<br>    <span class="hljs-comment">//求每个小组中位数组成的新数组的中位数</span><br>    <span class="hljs-keyword">int</span> pivot = medianOfMedians(arr, begin, end);<br>    <span class="hljs-comment">//将pivot作为基准元素进行partition，返回等于区域的范围</span><br>    <span class="hljs-keyword">int</span>[] pivotRange = partition(arr, begin, end, pivot);<br>    <span class="hljs-keyword">if</span>(i &gt;= pivotRange[<span class="hljs-number">0</span>] &amp;&amp; i &lt;= pivotRange[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> arr[i];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; pivotRange[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> bfprt(arr, begin, pivotRange[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> bfprt(arr, pivotRange[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, end, i);<br>&#125;<br><br><span class="hljs-comment">//在数组arr中从begin到end的范围内以pivot为基准元素进行划分，返回等于区域范围</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] partition(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> pivot)&#123;<br>    <span class="hljs-comment">//用small分别代表小于区域的右边界和大于区域的左边界，初始化时两个区域都没有元素</span><br>    <span class="hljs-keyword">int</span> small = begin - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> big = end + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cur = begin;<br>    <span class="hljs-keyword">while</span>(cur != big)&#123;<br>        <span class="hljs-keyword">if</span>(arr[cur] &lt; pivot)<br>            swap(arr, ++small, cur++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[cur] &gt; pivot)<br>            swap(arr, --big, cur);<br>        <span class="hljs-keyword">else</span><br>            cur++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;small + <span class="hljs-number">1</span>, big - <span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/02/15/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法目的"><a href="#KMP算法目的" class="headerlink" title="KMP算法目的"></a>KMP算法目的</h2><p>在str1中寻找str2出现的位置<br>假设str1长度为N，str2长度为M  </p><p>暴力方法：尝试从str1的每一个位置开始，让str2来匹配，暴力方法时间复杂度：O(MN)</p><h2 id="KMP算法流程："><a href="#KMP算法流程：" class="headerlink" title="KMP算法流程："></a>KMP算法流程：</h2><p><img src="/img/kmp.jpg"></p><ul><li>i1代表str1的索引，i2代表str2的索引。二者都从零位置开始尝试匹配。每一次匹配成功，i1和i2都右移</li><li>当匹配失败时（以图中为例：X != Y)，有一个推论为：在str1从i到j中任何一个位置开始，都匹配不出str2。既然明知匹配不出，那就不用再像暴力法那样从str1中i的下一个位置开始尝试匹配str2。只需从下一个不确定能不能匹配的位置（即j）开始尝试匹配str2。即i1从j开始，i2从0开始。<br>又因为str1中从j到x的字符与str2中Y的前next[Y]个字符相等（曾经匹配成功过），str2中Y的前next[Y]个字符与str2的前next[Y]个字符相等（next数组的定义）。因此可以推出：str1中从j到x的字符与str2中Y的前next[Y]个字符相等。<br>所以str1中从j开始的next[Y]个字符和str2中从0开始的前next[Y]个字符是肯定相等、不用匹配的。因此i1可以直接从X处开始（匹配失败的位置），i2可以直接从next[Y]处开始。</li><li>还需注意一个特殊情况：当i2为str2的第一个位置（next[i2] == -1），且str2中i2与str1中i1对应字符不相等时，意味着str2中第一个位置和str1的i1处都不匹配。那么从str1的i1开始肯定匹配不出str2，于是i1++。</li><li>当while循环退出时，说明str1或str2中的任意一个走到末尾了。如果str2走到末尾了，则说明匹配成功了，返回str2在str1中出现位置的索引：i1-i2。否则，str2没走到末尾str1却走到了末尾，说明匹配失败，str2中没有str1,返回-1。</li></ul><p>Q &amp; A<br>问：为什么当匹配失败时可以说：在str1中从i到j任何一个位置开始，都匹配不出str2？<br>答：假设从str1中i到j的一个位置k开始，可以匹配出str2。即从k到X的这n个字符应该和str2中从0开始的前n个字符匹配（注意：n &gt; next[Y])。又因为str1中k到X的这n个字符已经和str2中Y的前n个字符匹配过了，它们是相等的。于是str2中从0开始的前n个字符（前缀）应该和Y前面的n个字符相等（后缀）。但由next数组的定义可知，它们是不相等的。因此这种假设不成立。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndexOf</span><span class="hljs-params">(String s, String m)</span></span>&#123;<br>    <span class="hljs-comment">//在s中找不到m，返回-1</span><br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || m == <span class="hljs-keyword">null</span> || m.length() &lt; <span class="hljs-number">1</span> || s.length() &lt; m.length())<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span>[] str1 = s.toCharArray();<br>    <span class="hljs-keyword">char</span>[] str2 = m.toCharArray();<br>    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//根据str生成next数组</span><br>    <span class="hljs-keyword">int</span>[] next = getNextArray(str2);<br>    <span class="hljs-keyword">while</span>(i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length)&#123;<br>        <span class="hljs-keyword">if</span>(str1[i1] == str2[i2])&#123;<br>            i1++;<br>            i2++;<br>        &#125;<br>        <span class="hljs-comment">//next[i2]为1代表i2是str2中的第一个位置，即如果str2中第一个位置和str1的i1位置都不匹配</span><br>        <span class="hljs-comment">//那么让i1加1，让str2和在str1从i1的后一个位置开始匹配</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(next[i2] == -<span class="hljs-number">1</span>)<br>            i1++;<br>        <span class="hljs-keyword">else</span><br>            i2 = next[i2];<br>    &#125;<br>    <span class="hljs-keyword">return</span> i2 == str2.length ? i1 - i2 : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="next数组的构建"><a href="#next数组的构建" class="headerlink" title="next数组的构建"></a>next数组的构建</h2><p>next数组表示str2中任意一个字符<strong>前面的字符串的最长前缀和最长后缀的匹配长度</strong></p><p>比如：str2为abkababkabF,那么F在next数组中对应的数值就为5（F前面字符串的最长前缀和最长后缀最长匹配5个位置，abkab）</p><p>构建next数组的步骤：<br>例如str2为ababcababaK,那么K前面这个a对应的next值为4（最长前缀和最长后缀abab的长度）。现在已知这个next[a]，想要求next[K],于是我们比较next[a]对应的最长前缀的后一个字符c与next[a]对应的最长后缀的后一个字符a,发现二者不等。于是我们再将这个a与next[c]的最长前缀的后一个字符a相比，发现二者相等。于是next[K] = next[c] + 1,即2+1= 3</p><p>注：这里next[K]和next[c]都是简写，实际应该为next[11]和next<a href="%E5%8D%B3%E4%BD%8D%E7%BD%AE%E7%B4%A2%E5%BC%95%E5%80%BC">5</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] getNextArray(<span class="hljs-keyword">char</span>[] str)&#123;<br>    <span class="hljs-keyword">if</span>(str.length == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length];<br>    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//i为当前来到的位置索引</span><br>    <span class="hljs-comment">//cn为i-1对应的最长前缀的下一个字符的位置索引</span><br>    <span class="hljs-comment">//cn可以看作next[i-1]</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; next.length)&#123;<br>        <span class="hljs-keyword">if</span>(str[i - <span class="hljs-number">1</span>] == str[cn])<br>            <span class="hljs-comment">//相当于next[i]=next[i-1]+1</span><br>            next[i++] = ++cn;<br>        <span class="hljs-comment">//如果前一个位置的字符与cn处不等，那么cn往前跳</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cn &gt; <span class="hljs-number">0</span>)<br>            cn = next[cn];<br>        <span class="hljs-comment">//如果不等且cn不能往前跳了(其最长前缀和最长后缀为0）</span><br>        <span class="hljs-keyword">else</span><br>            next[i++] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】1143.最长公共子序列</title>
    <link href="/2021/02/15/Leetcode%201143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/02/15/Leetcode%201143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>注：两个字符串的「公共子序列」（Longest Common Subsequence，简称 LCS）是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。</p><pre><code>示例 1:输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。示例 2:输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。示例 3:输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><h2 id="方法（动态规划）"><a href="#方法（动态规划）" class="headerlink" title="方法（动态规划）"></a>方法（动态规划）</h2><p>遇到子序列相关的问题，可以往动态规划上考虑。这道题让我们在<strong>两个字符串</strong>中寻找共同拥有的最长子序列，因此很容易想到用二维动态规划来解决。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1.定义dp数组"></a>1.定义dp数组</h3><p>定义$dp[i][j]$为：$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度。</p><h3 id="2-Base-Case"><a href="#2-Base-Case" class="headerlink" title="2.Base Case"></a>2.Base Case</h3><p>根据上述dp数组的定义，可以写出如下Base Case：</p><ul><li>i为0时，str1[0…i-1]不构成一个字符串，因此不存在与str2的公共子序列，因此dp[0][j]为0</li><li>j为0时，str2[0…j-1]不构成一个字符串，因此不存在于str1的公共子序列，因此dp[i][0]为0</li></ul><h3 id="3-状态转移方程"><a href="#3-状态转移方程" class="headerlink" title="3.状态转移方程"></a>3.状态转移方程</h3><p>当str1遍历到i - 1，str2遍历到j - 1时，即要求$str1[0…i-1]和str2[0…j-1]$的最长公共子序列长度时，需要考虑以下的几种情况：</p><ul><li><p>如果str1[i - 1]与str2[j - 1]相等，那么肯定要将其放入str1[0…i−1]和str2[0…j−1]的LCS当中，有了这个字符，LCS的长度就会加1，因此<br>$$dp[i][j] = dp[i - 1][j - 1] + 1$$</p></li><li><p>如果str1[i - 1]与str2[j - 1]不等，则又会分为以下的三种情况：</p><ul><li><p>str1[i - 1]与str2[j - 1]都不放入LCS当中，那么LCS的长度不会产生变化，即dp[i][j] = dp[i - 1][j - 1]</p></li><li><p>str1[i - 1]放入LCS中，但str2[j - 1]不放。这时dp[i][j] = dp[i][j - 1]</p></li><li><p>str1[i - 1]不放入LCS中，但str2[j - 1]放。这时dp[i][j] = dp[i - 1][j]</p><p> 由于在dp[i][j]这个位置可以做上述三种选择，因此取三种选择可能产生的最大值，即为dp[i][j]。即：<br> $$dp[i][j] = max(dp[i - 1][j - 1],dp[i][j - 1],dp[i - 1][j])$$</p></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str1.length() + <span class="hljs-number">1</span>][str2.length() + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//Base Case,其实可以不用，因为数组初始化时全体元素就为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= str2.length(); j++)<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= str1.length(); i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= str1.length(); i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= str2.length(); j++)&#123;<br>            <span class="hljs-keyword">if</span>(str1.charAt(i - <span class="hljs-number">1</span>) == str2.charAt(j - <span class="hljs-number">1</span>))<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[str1.length()][str2.length()];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度:O(m * n)</li><li>空间复杂度:O(m * n)<br>其中，m和n分别为str1和str2的长度</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/02/15/git/"/>
    <url>/2021/02/15/git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>git命令必须在仓库目录内执行</p><ol><li><p>创建一个空目录并进入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir learngit<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> learngit<br></code></pre></td></tr></table></figure></li><li><p>将这个目录变成git可以管理的仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>将一个文件<strong>添加</strong>到仓库</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-builtin-name">add</span> readme.txt<br></code></pre></td></tr></table></figure><p>注意：添加某个文件时，该文件必须在当前目录下存在</p></li><li><p>将这个文件<strong>提交</strong>到仓库</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-string">$ </span>git commit -m <span class="hljs-comment">&quot;wrote a readme file&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>-m后面是本次提交的说明</p><h2 id="对仓库中内容进行修改"><a href="#对仓库中内容进行修改" class="headerlink" title="对仓库中内容进行修改"></a>对仓库中内容进行修改</h2><p>用以下命令可以掌握工作区的状态，它会告诉我们文件有没有修改过</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><p>而以下命令可以查看修改的内容</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">diff</span> readme.txt<br></code></pre></td></tr></table></figure><h3 id="1-版本回退"><a href="#1-版本回退" class="headerlink" title="1.版本回退"></a>1.版本回退</h3><p>我们在工作中会不断地对文件进行修改，当我们觉得修改到一定程度的时候，就可以进行一次commit，相当于打游戏时进行一次存档。一旦文件被该乱了，或者不小心删除了文件，还可以从最近的一个commit中恢复。</p><p>以下命令告诉我们commit的历史记录,它会显示从最近到最远的提交版本</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>在Git中，<strong>用HEAD表示当前版本</strong>，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本就是HEAD~100。如果我们要把当前版本回退到上一个版本，就可以用如下的命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure><p>显然，当回退到上一个版本之后，刚才的当前版本已经不会在git log中看到了。但扔可以通过commit id回到刚才的那个版本（7c0b9b为那个版本git版本号的前几位）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> reset --hard  <span class="hljs-number">7</span>c<span class="hljs-number">0</span>b<span class="hljs-number">9</span>b<br></code></pre></td></tr></table></figure><p>但是那个版本的版本号找不到或者不记得了怎么办？不要紧，git记录了我们的每一次命令,通过如下命令行查看命令历史，就可以找到我们想重返的版本的id</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br><span class="hljs-number">7</span>c0b9b5 (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">7</span>c0b9b<br><span class="hljs-number">06</span>d21e9 HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">7</span>c0b9b5 (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> a <span class="hljs-type">line</span><br><span class="hljs-number">06</span>d21e9 HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span> (initial): <span class="hljs-keyword">write</span> a readme <span class="hljs-type">text</span><br></code></pre></td></tr></table></figure><h3 id="2-工作区和暂存区"><a href="#2-工作区和暂存区" class="headerlink" title="2.工作区和暂存区"></a>2.工作区和暂存区</h3><p>Git管理的文件分为工作区和版本库(.git隐藏目录)。版本库又分为暂存区stage和git为我们创建的第一个分支master。</p><p>我们把文件添加到git版本库分为两步：</p><ul><li>用git add把文件修改添加到暂存区</li><li>用git commit将暂存区的内容添加到当前分支</li></ul><p>可以理解为：将需要提交的文件修改先全都放到暂存区，然后，一次性提交暂存区的所有修改。</p><h3 id="3-撤销修改和删除文件"><a href="#3-撤销修改和删除文件" class="headerlink" title="3.撤销修改和删除文件"></a>3.撤销修改和删除文件</h3><p>如下命令可以用来撤销对工作区的修改</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- readme.txt</span><br></code></pre></td></tr></table></figure><p>有两种情况：</p><ul><li>readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul><p>总之，以上命令就是让这个文件工作区回到最近一次git commit或git add时的状态。</p><p>但是如果对工作区修改后还add到了暂存区该怎么办呢？</p><ol><li>先用如下命令可以撤销对暂存区的修改（unstage），然后重新放回工作区<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset HEAD readme.txt<br></code></pre></td></tr></table></figure></li><li>现在暂存区干净了，但是工作区还有修改，接下来再撤销掉工作区的修改：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- readme.txt</span><br></code></pre></td></tr></table></figure>总结撤销修改的三种情况：</li></ol><ul><li>当改乱了文件的内容并且还未add，想直接丢弃工作区的修改时，用命令git checkout – file</li><li>当改乱了文件的内容并且add到了暂存区时，想丢弃修改，第一步先用命令git reset HEAD file丢弃暂存区的修改，第二步再用命令git checkout – file丢弃工作区的修改。</li><li>当已经把改乱的文件commit到版本库时，想撤销提交，这时就需要版本回退。</li></ul><p>总结删除文件的两种情况：<br>当我们把工作区的一个文件删除时：</p><ul><li><p>如果我们确实要从版本库中删除该文件，那么就用git rm file删除掉，并且git commit</p></li><li><p>如果我们其实是不小心删错了，那就可以用git checkout – file将误删的文件恢复到最新版本。</p><p>注意：git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p></li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>Github用来提供Git仓库托管服务，它相当于一个服务器，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><ol><li>在github中添加本地计算机的SSH Key。这样GitHub就可以识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</li><li>在github中建立一个 repository。并在本地库中运行如下命令将本地版本库和github上的远程库关联起来（远程库的名字就叫origin）<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/wyh317/</span>learnGit.git<br></code></pre></td></tr></table></figure></li><li>将本地库的所有内容推送到远程库上,实际上是把当前分支master推送到远程。并且本地的master分支和远程的master分支关联了起来<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>由于远程库是空的，所以第一次推送master分支时，带了”-u”。之后，只要本地做了提交，就可以通过如下命令将本地的master分支的最近修改推送至Github<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure>可以使用如下命令从github上克隆出一个本地库<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:wyh317/learnGit.git<br></code></pre></td></tr></table></figure>当从远程仓库克隆时，Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。可以用git remote或者git remote -v查看远程库的信息。</li></ol><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><ul><li>查看分支：git branch</li><li>创建分支：git branch name</li><li>创建一个分支并切换到它：git switch -c name</li><li>切换到某个分支：git switch name</li><li>合并某分支到当前分支：git merge name</li><li>删除分支：git branch -d name</li></ul><p>当两个分支的文件修改有冲突时，git无法完成自动合并，我们必须先手动把冲突解决然后提交，再合并。用git log –graph命令可以看到分支合并图。</p><p>通常在合并分支时，git会默认使用fast forward模式，但这种模式下删除分支后，会丢掉分支信息。如果使用以下命令行来merge(即将分支test合并到当前分支）：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">merge</span> --<span class="hljs-keyword">no</span>-ff -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;merge with no-ff&quot;</span> <span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><p>那么Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。（因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去），能看出来做过合并，而fast forward合并后就看不出来曾经做过合并</p><p><strong><em>分支策略</em></strong>：</p><ul><li>master分支应该是非常稳定的，仅用来发布版本，不能在上面工作</li><li>dev分支是不稳定的，用来工作用，到版本发布时，再把dev分支合并到master上</li><li>团队的每个成员都在dev的分支上工作，每个人有自己的分支，工作完往dev上合并即可。</li></ul><p><strong><em>Bug分支</em></strong>：<br>在修复bug时，我们通过创建新的bug分支来进行修复，修复完之后进行合并，最后将这个bug分支删除。</p><p>当手头上的工作还没有完成时，我们可以用git stash命令将当前工作现场“储藏”起来，然后去修复bug，修复后再用git stash pop命令恢复现场继续工作。</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用如下命令，把修复bug的commit（用其id表示）“复制”到当前分支，避免重复劳动。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git cherry-pick commitid</span><br></code></pre></td></tr></table></figure><p><strong><em>Feature分支</em></strong>：<br>每添加一个新功能，最好新建一个feature分支并在上面开发，完成后与主分支进行merge，最后删除该feature分支。</p><p><strong><em>多人协作</em></strong>：  </p><ul><li>首先，用git push origin <branch-name>向远程推送自己的更改</li><li>如果推送失败，说明队友的最新提交和我们正要试图的提交有冲突，那我们先用git pull抓取远程的新提交</li><li>在本地解决冲突，并在本地提交</li><li>将冲突解决后的分支提交到远程git push origin <branch-name></li></ul><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常会在版本库中打一个标签（tag），一个标签对应着一个commit，例如id为6a5819e的commit对应着标签为v1.2的版本，这样便与日后查找。</p><p>可以通过如下的命令进行打标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">3</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">2</span> <span class="hljs-number">6</span>a5819e<br></code></pre></td></tr></table></figure><p>第一行将标签v1.3打到当前分支最新提交的commit上，第二行将标签v1.2打到id为6a5819e的commit上。</p><p>命令git tag可以查看所有标签。git show <tagname>可以看到标签的说明文字。</p><p>删除一个本地标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>向远程推送一个本地标签：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;tagname&gt;<br></code></pre></td></tr></table></figure><p>向远程推送全部未推送过的本地标签:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br></code></pre></td></tr></table></figure><p>删除一个远程标签：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git push origin <span class="hljs-symbol">:refs/tags/&lt;tagname&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manacher遍历</title>
    <link href="/2021/02/15/Manacher%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/15/Manacher%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><h2 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h2><p>一个字符串中找到最长回文子串</p><h2 id="暴力方法（中心扩展法）"><a href="#暴力方法（中心扩展法）" class="headerlink" title="暴力方法（中心扩展法）"></a>暴力方法（中心扩展法）</h2><p>假设字符串的长度为N，那么回文串可能的中心有2N-1种。其中，每个单字符串都可作为回文串的中心，这种情况有N种。其次，双字符串也可作为回文串的中心，这种情况有N-1种。单字符中心负责扩展成长度为奇数的字符串，双字符串中心可以扩展成长度为偶数的字符串。例如：</p><ul><li><p>字符串“aba”有5种可能的中心：a、b、c、ab、ba  </p></li><li><p>字符串“abba”有7种可能的中心：a、b、b、a、ab、bb、ba</p><p>中心扩展法的基本思想为：对于每一个中心都计算一次以其为中心的最长回文串长度</p></li></ul><p>具体算法：对于每一个可能的回文中心，都尽可能地扩展它对应的回文区间[left, right]，直到left=N或者S[left]不等于S[right]为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.length();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> left = i / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> right = left + i % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>            String tmp = s.substring(left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (tmp.length() &gt; res.length()) &#123;<br>                res = tmp;<br>            &#125;<br>            left--;<br>            right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li></ul><h2 id="Manacher算法-1"><a href="#Manacher算法-1" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>一些概念：</p><ul><li>回文半径数组：记录以每一个位置为中心的回文半径的长度</li><li>最右回文右边界：所有位置对应的回文半径中最靠右的位置</li><li>回文右边界的中心：得到最右回文右边界的回文半径的回文中心是哪里（由哪个中心向右扩展得到最右回文右边界）</li></ul><p>在回文右边界和回文左边界中的字符串是回文串。假设最右回文右边界R的中心是c，当前位置i关于c在其左边的对称位置为i’。</p><p><img src="/img/Manacher.jpg"></p><p>算法步骤：<br>分析四种情况</p><ol><li>i在R外，用暴力法扩展。</li><li>i在R里，i’的回文半径整体彻底在L（回文左边界）和R的内部，那么以i为中心的回文半径等于以i’为中心的回文半径</li><li>i在R里，i’的回文半径在L和R的外面，那么以i为中心的回文半径等于i到R的距离</li><li>i在R里，i’的回文左边界和L压线，那么要将i’的回文半径继续向外扩展（i到R的区域肯定在i的回文半径里，不需扩展。R右边是否在i的回文半径里还不清楚，需要扩展才知道)</li></ol><p>上面四种情况中，需要扩展的只有情况1和情况4，对于情况2和情况3，以i为中心的回文半径可以用O(1)的时间开销直接得出。而情况1和情况4在扩展时，R不断向右扩。只要进行一次成功的扩展，R都必然会增加。也就是说R最多就是从0位置到n位置（n为字符串长度)且R不会回退，所以**<em>整个Manacher算法的时间复杂度为O(N)**</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给定一个字符串，返回它的最长回文字串长度</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//将字符串扩展为manacher字符串（每个字符中间和字符串前后加#)</span><br>    <span class="hljs-comment">//因为扩展后字符串长度翻倍，因此求扩展后的字符串的最大回文半径，即求原来字符串的最大回文直径</span><br>    <span class="hljs-keyword">char</span>[] charArr = manacherString(str);<br>    <span class="hljs-comment">//pArr为回文半径数组</span><br>    <span class="hljs-keyword">int</span>[] pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[charArr.length];<br>    <span class="hljs-keyword">int</span> C = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> R = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//max记录最长的回文半径长度</span><br>    <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != charArr.length; i++) &#123;<br>        <span class="hljs-comment">//i在R里时：对于情况2和3，在i&#x27;的回文半径和i与R的距离中取较小值，即为i的回文半径</span><br>                 <span class="hljs-comment">//对于情况4，先将回文半径设为R-i，再在之后while循环中将回文半径继续向外扩展</span><br>        <span class="hljs-comment">//i在R外时，先将i位置的回文半径置为1，之后再在while循环里扩展</span><br>        pArr[i] = R &gt; i ? Math.min(pArr[<span class="hljs-number">2</span> * C - i], R - i) : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//情况2和情况3即使进入了该while循环，但是第一次if都不会成立，会直接break退出循环</span><br>        <span class="hljs-comment">//只有情况1和情况4会在while循环里进行回文半径的扩展。</span><br>        <span class="hljs-keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])<br>                pArr[i]++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//更新最大回文右边界R和其对应的回文中心C</span><br>        <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;<br>            R = i + pArr[i];<br>            C = i;<br>        &#125;<br>        <span class="hljs-comment">//更新max</span><br>        max = Math.max(max, pArr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//生成manacher字符串，将给定字符串str的两端和每个字符中间全加上特殊符号#</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] manacherString(String str) &#123;<br>    <span class="hljs-keyword">char</span>[] charArr = str.toCharArray();<br>    <span class="hljs-keyword">char</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[str.length() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> C = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != res.length; i++) &#123;<br>        res[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : charArr[C++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Morris遍历</title>
    <link href="/2021/02/15/Morris%E9%81%8D%E5%8E%86/"/>
    <url>/2021/02/15/Morris%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h1><p>经典的二叉树遍历，无论是递归还是非递归。其空间复杂度都是O(h),其中h为二叉树的高度。<br>而Morris遍历可以做到时间复杂度O(N), 空间复杂度O(1)</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>记当前来到的节点引用为cur</p><ul><li>如果cur没有左孩子，那么cur向右移动：cur = cur.right</li><li>如果cur有左孩子，那么找到它左子树上最右的节点，记为mostright<ul><li>如果mostright的右指针right指向空，那么让其指向cur，然后cur向左移动：cur = cur.left</li><li>如果mostright的右指针right指向cur, 那么让其指向空，然后cur向右移动：cur = cur.right</li></ul></li></ul><p>举例说明：</p><pre><code>给定二叉树：          1        /   \       2     3      / \   /  \     4   5 6    7Morris遍历流程：1. cur在1：首先cur指向根节点1，当前cur有左孩子，所以找到左子树的最右节点5，5的右指针right现在为空，所以让其指向cur（5的right指向1），然后cur向左移动来到22. cur在2：cur有左孩子，找到其左子树的最右节点4，4的right为空，于是让其指向cur（4的right指向2），然后cur向左移动来到43. cur在4：当前cur没有左孩子，因此向右移动，回到24. cur在2：当前cur左子树的最右节点为4，4的right现在指向cur，于是让它指回空，然后cur向右移动来到55. cur在5：当前cur没有左孩子，因此向右移动，回到16. cur在1：cur左子树的最右节点为5，5的right现在指向cur，于是让它指回空，然后cur向右移动来到37. cur在3：cur左子树的最右节点为6，6的right指向空，于是让它指向cur，然后cur向左移动来到68. cur在5：当前cur没有左孩子，因此向右移动，回到39. cur在3：cur左子树的最右节点为6，6的right指向cur，于是让它指向空，然后cur向右移动来到710. cur在7：当前cur没有左孩子，因此向右移动，发现来到的位置上是空，于是整个遍历结束。总结下来：cur分别经过了1 2 4 2 5 1 3 5 3 7</code></pre><h2 id="Morris遍历的本质"><a href="#Morris遍历的本质" class="headerlink" title="Morris遍历的本质"></a>Morris遍历的本质</h2><p>在经典递归版的遍历中，只要一个节点不空，遍历会来到这个节点三次：</p><ul><li>首先来到这个节点</li><li>遍历完它的左子树后再回到这个节点</li><li>遍历完它的右子树后再回到这个节点</li></ul><p>如果把对这个节点的操作放在第一次来到这个节点的时候，就是先序遍历。<br>如果把对这个节点的操作放在第二次来到这个节点的时候，就是中序遍历。<br>如果把对这个节点的操作放在第三次来到这个节点的时候，就是后序遍历。  </p><p>而在Morris遍历中：</p><ul><li>如果一个节点有左子树，那么Morris遍历会回到它两次。并且第二次回到这个节点时，其左子树上所有的节点一定都已经遍历完了。Morris遍历根据左子树最右节点mostRight的右指针right指向谁来判断是第几次来到当前这个节点（指向空则是第一次，指向cur节点本身则是第二次）。</li><li>如果一个节点没有左子树，那么Morris遍历只会回到它一次</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Morris遍历的先序和中序思想一致，只是对节点操作（以打印为例）的时机不一致。在第一次来到节点时操作为先序，在第二次来到节点时操作为中序。</p><p>Morris遍历的中序遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(TreeNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode cur = head;<br>    TreeNode mostRight = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        mostRight = cur.left;<br>        <span class="hljs-comment">//如果cur有左孩子</span><br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//首先找到cur的左子树的最右节点</span><br>            <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;<br>                mostRight = mostRight.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;<br>                mostRight.right = cur;<br>                cur = cur.left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mostRight.right = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//若该节点有左子树，当把左子树处理完第二次回到这个节点时进行打印行为，即为中序遍历。</span><br>        <span class="hljs-comment">//如果该节点没有左子树，那么只会来到这个节点一次，在这时候打印即可。</span><br>        System.out.print(cur.val + <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-comment">//如果cur没有左孩子，cur直接向右移动</span><br>        cur = cur.right;<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>Morris遍历的先序遍历代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">morrisIn</span><span class="hljs-params">(TreeNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode cur = head;<br>    TreeNode mostRight = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>        mostRight = cur.left;<br>        <span class="hljs-comment">//如果cur有左孩子</span><br>        <span class="hljs-keyword">if</span> (mostRight != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//首先找到cur的左子树的最右节点</span><br>            <span class="hljs-keyword">while</span> (mostRight.right != <span class="hljs-keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;<br>                mostRight = mostRight.right;<br>            &#125;<br>            <span class="hljs-comment">//若一个节点有左子树，那么当mosRight的right为空时，为第一次到达这个节点的时候。</span><br><span class="hljs-comment">//在此时进行打印行为，即为先序遍历</span><br>            <span class="hljs-keyword">if</span> (mostRight.right == <span class="hljs-keyword">null</span>) &#123;<br>                mostRight.right = cur;<br>                System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>                cur = cur.left;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mostRight.right = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果一个节点没有左子树，那么只会来到这个节点一次，在这个时候打印即可。</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.print(cur.value + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果cur没有左孩子，cur直接向右移动</span><br>        cur = cur.right;<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2021/02/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>一句话描述：控制对其他对象的访问</strong></p><p>代理模式创建代理(Pxory)，让代理控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p><p><img src="/img/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg"></p><p>RealSubject和Pxory都实现了Subject接口，因此Pxory可以在RealSubject出现的地方取代它。</p><p>代理模式有以下几个代表：</p><ul><li>远程代理：控制访问远程对象</li><li>虚拟代理：控制访问创建开销大的资源</li><li>保护代理：基于权限控制对资源的访问</li></ul><h2 id="远程代理："><a href="#远程代理：" class="headerlink" title="远程代理："></a>远程代理：</h2><p>如果我们要访问的对象在另一个JVM堆中（即在不同的地址空间中运行的远程对象），我们就没办法通过引用来得到这个对象。</p><pre><code>注：Subject a = XXX对于这种语句，a只能引用与当前代码语句所在同一个堆空间的对象。</code></pre><p>对于这种情况，远程代理就可以作为另一个JVM上对象的本地代表。调用代理的方法会被代理利用网络转发给远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。</p><h2 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h2><p>保护代理根据访问权限决定客户是否可以访问对象。</p><p>例如：有一个雇员对象，保护代理允许一个雇员自己调用对象上的某些方法（如setName()),但不允许雇员自己调用类似于setSalary()的方法。<br>而保护代理允许经理调用setSalary()方法，但不允许经理调用setName()方法。<br><img src="/img/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86.jpg"></p><h2 id="虚拟代理："><a href="#虚拟代理：" class="headerlink" title="虚拟代理："></a>虚拟代理：</h2><p>虚拟代理作为创建开销大的对象的代表。虚拟代理在我们真正需要使用一个对象时才创建这个对象。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。当对象创建后，代理就会将请求直接委托给对象。</p><p><img src="/img/%E8%99%9A%E6%8B%9F%E4%BB%A3%E7%90%86.jpg"></p><h3 id="以下为虚拟代理的实现："><a href="#以下为虚拟代理的实现：" class="headerlink" title="以下为虚拟代理的实现："></a>以下为虚拟代理的实现：</h3><p><strong>背景说明</strong>：当加载一张图片时，限于连接带宽和网络负载，加载可能需要一些时间，所以在等待图像加载的时候，应该显示一些东西。（同时也不希望在显示这些东西时整个应用被挂起）一旦图像被加载完成后，刚才显示的东西应该消失，图像显示出来。</p><p>先定义一个接口Image，代理和真正的图片对象都要实现Image接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Image</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImagePxory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RealImage realImage;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImagePxory</span><span class="hljs-params">(RealImage realImage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.realImage = realImage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//当realImage加载完成时，显示realImage</span><br>        <span class="hljs-comment">//否则显示:Image is loading, please wait</span><br>        <span class="hljs-keyword">while</span>(!realImage.isLoad())&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println((<span class="hljs-string">&quot;Image is loading, please wait&quot;</span>));<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                e.printStackTrace();;<br>            &#125;<br>        &#125;<br>        realImage.showImage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实图片类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealImage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Image</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> URL imageURL;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> startTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RealImage</span><span class="hljs-params">(URL imageURL)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.imageURL = imageURL;<br>        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">this</span>.height = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">this</span>.startTime = System.currentTimeMillis();<br>    &#125;<br>    <span class="hljs-comment">//模拟图片加载过程，假定图片加载需要三秒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoad</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">return</span> endTime - startTime &gt; <span class="hljs-number">3000</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showImage</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(imageURL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    String image = <span class="hljs-string">&quot;http://image.jpg&quot;</span>;<br>    URL url = <span class="hljs-keyword">new</span> URL(image);<br>    RealImage realImage = <span class="hljs-keyword">new</span> RealImage(url);<br>    ImagePxory imagePxory = <span class="hljs-keyword">new</span> ImagePxory(realImage);<br>    imagePxory.showImage();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md">CyC2018: CS-Notes:设计模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2021/02/15/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2021/02/15/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><p>传输层包括以下两个协议：</p><ul><li><strong><em>TCP（Transmission Control Protocol）</em></strong>:TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li><li><strong><em>UDP（User Datagram Protocol）</em></strong>:UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li></ul><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><p>UDP从应用程序进程的得到数据，附加上用于多路复用/分解复用的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。</p><p>注意：使用UDP时，在发送报文段之前，发送方和接收方的传输层实体之间没有握手，因此UDP被称为是无连接的（DNS协议就是基于UDP的）</p><p>使用UDP的几个好处：</p><ul><li>因为实时应用通常要求最小的发送速率，不希望过分延迟报文段的传送，且能容忍一些数据丢失，这种情况用TCP就不太合适。</li><li>无需连接建立：UDP无需任何准备即可进行数据传输。因此，UDP不会引入建立连接的时延，这也是DNS使用UDP的原因。</li><li>无连接状态：TCP不仅要在端系统中维护连接状态，而且还要跟踪包括接收和发送缓存、拥塞控制参数以及序号与端口号的参数。而UDP不维护连接状态，也不跟踪这些参数。因此某些专门用于某种特定应用的服务器当应用程序运行在UDP之上时，一般都能支持更多的活跃用户。</li><li>分组首部开销小：UDP首部只有8字节的首部开销。而TCP首部则有20字节的首部开销。</li></ul><p><img src="/img/%E5%9B%BE%E7%89%873.1.jpg"></p><p>用UDP进行可靠数据传输的方法：<br>在应用程序自身中建立可靠性机制。这样的话，应用程序进程一方面可以进行可靠通信，另一方面也而无需受制由于TCP的拥塞控制带来的传输速率的限制。</p><p>TCP首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和（每个占2字节）。其中，长度指整个UDP报文段所占的字节数（首部+数据）</p><p><img src="/img/%E5%9B%BE%E7%89%873.2.jpg"> </p><p>注意：尽管UDP提供了差错检测，但它并没有提供恢复错误的机制。</p><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><p>TCP被称为是面向连接的，这是因为在两个进程互相发送数据之前，两个进程必须先相互握手。</p><h3 id="3-1-TCP报文段格式"><a href="#3-1-TCP报文段格式" class="headerlink" title="3.1 TCP报文段格式"></a>3.1 TCP报文段格式</h3><p><img src="/img/%E5%9B%BE%E7%89%873.3.jpg"></p><ul><li>序号(Sequence number)：一个报文段的序号是这个报文段的data字段的第一个字节的序号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li>确认号(Acknowledgement number)：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li>确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li>窗口(Receive window)：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="3-2-TCP的流量控制-Flow-Control"><a href="#3-2-TCP的流量控制-Flow-Control" class="headerlink" title="3.2 TCP的流量控制(Flow Control)"></a>3.2 TCP的流量控制(Flow Control)</h3><p>TCP为应用进程提供了流量控制服务，以消除发送方使接收方缓存溢出的可能性。流量控制服务是一个速度匹配服务，即让发送方发送的速率与接收方应用进程的读取速率相匹配，保证接收方来得及接收。而TCP发送方也可能因为IP网络的拥塞而被遏制，因为这种情况而对发送方的控制则是拥塞控制。</p><p><img src="/img/%E5%9B%BE%E7%89%873.4.jpg"></p><p>TCP通过让发送方维护一个称为接收窗口(receive window)的变量来提供流量控制，这个接收窗口用于告知发送方：该接收方还有多少可用的缓存空间。</p><p>由于TCP不允许已分配的缓存溢出，所以下式必须成立（不等式左边代表仍处在缓存中的数据量）：  </p><center>LastByteRcvd - LastByteRead <= RcvBuffer</center><p>接收窗口用rwnd表示，根据缓存空间的可用大小来设置：</p><center>rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)</center><p>由于该空间是随着时间变化的，所以rwnd是不断滑动的。</p><p>连接通过rwnd来提供流量控制的方式：主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段(reveive window)中，通知主机A它在该连接的缓存中还有多少可用空间。</p><p>而主机A也不断跟踪两个变量，LastByteSent和LastByteAcked,二者的差即是主机A发送到连接中但未被确认的数据量，通过将这个量控制在rwnd内，就可以保证主机A不会使主机B的缓存溢出。因此主机A必须始终保证：  </p><center>LastByteSent - LastByteAcked <= rwnd</center><p>注意：因为TCP仅当在它有数据或有ACK要发时才会发送报文段给A。因此当B的rwnd为0并且通知给A后，B不再向A发送带有rwnd的新报文段，即使之后B中rwnd不为0了，A也不会知道。所以TCP规范中要求：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段，这样B就能不断地回复A以ACK报文段，并向A通知rwnd状态。</p><h3 id="3-3-TCP的三次握手"><a href="#3-3-TCP的三次握手" class="headerlink" title="3.3 TCP的三次握手"></a>3.3 TCP的三次握手</h3><p>TCP的三次握手发生在连接建立时<br><img src="/img/%E5%9B%BE%E7%89%873.5.jpg"></p><p>假设 A 为客户端，B 为服务器端。  </p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。并且SYN被置0.</li><li>B 收到 A 的确认后，连接建立。在以后的报文段中，由于连接已建立，SYN都将是0.</li></ul><p><strong><em>三次握手的原因</em></strong><br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h3 id="3-4-TCP的四次握手"><a href="#3-4-TCP的四次握手" class="headerlink" title="3.4 TCP的四次握手"></a>3.4 TCP的四次握手</h3><p>TCP的三次握手发生在连接释放时</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认报文段，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><img src="/img/%E5%9B%BE%E7%89%873.6.jpg"></p><p><strong><em>四次挥手的原因</em></strong><br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong><em>TIME_WAIT</em></strong><br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p>TIME_WAIT结束之后，连接就正式关闭，客户端所有资源将被释放。</p><h3 id="3-5-TCP拥塞控制"><a href="#3-5-TCP拥塞控制" class="headerlink" title="3.5 TCP拥塞控制"></a>3.5 TCP拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><strong><em>TCP如何限制发送速率</em></strong><br>运行在发送方的TCP拥塞控制机制跟踪一个称为拥塞窗口的变量，记为cwnd。它对一个TCP发送方能像网络中发送流量的速率进行限制。即，在一个发送方中未被确认的数据量不会超过cwnd和rwnd中的最小值，即：</p><center>LastByteSent - LastByteAcked <= min{cwnd, rwnd}</center>以上约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率。<p><strong><em>TCP如何察觉拥塞</em></strong><br>当出现过度的拥塞时，在沿着这条路径上的一台或多台路由器的缓存会溢出，引起一个数据报被丢弃，丢弃的数据报接着会引起发送方的丢包事件（要么超时要么收到3个冗余ACK），发送方就认为在发送方到达接收方的路径上出现了拥塞。</p><p>TCP通过慢启动、拥塞避免和快速恢复这三个部分来实现拥塞控制。</p><p><img src="/img/%E5%9B%BE%E7%89%873.7.jpg"></p><ul><li>慢启动：发送的最初执行慢启动，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li><li>拥塞避免：注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</li><li>快速恢复：当丢包事件发生时，cwnd的值被设置成1个MSS，并且ssthresh的值设置为cwnd的一半，然后重新执行慢启动。</li></ul><p>上/img/图片中传输轮次1-4为慢启动过程，5-8为拥塞避免过程，之后为快速恢复过程。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2021/02/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式确保一个类只有一个实例，并提供一个全局访问点</p><p>通常使用一个私有构造器、一个静态函数、一个私有静态变量来实现。</p><ul><li>为了保证类只有一个实例，所以就不能用new关键字和构造器来创建对象实例，因此需要将构造器声明为私有的，只有在类的内部才能调用构造器。</li><li>与此同时，需要一个私有静态变量来记录这个唯一的对象实例</li><li>还需要一个私有静态函数来返回这个唯一的私有静态变量。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-懒汉模式与饿汉模式"><a href="#1-懒汉模式与饿汉模式" class="headerlink" title="1.懒汉模式与饿汉模式"></a>1.懒汉模式与饿汉模式</h3><p>以下为单例模式中的懒汉模式代码。它的特点是：uniqueInstance被延迟实例化(lazy instantiaze)，也就是说如果我们不需要这个实例（不适用getUniqueInstance()函数），那么它就永远不会产生。可以节约资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有静态变量：记录这个唯一的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-comment">//私有构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-comment">//私有静态函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但以上实现并非线程安全的。考虑线程A和线程B同时调用Singleton.getUniqueInstance(),进入以下的if语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure><p>此时实例并未被创建，所以A和B都通过了if判断，接下来A使用私有构造器构造了一个对象1。但B因为之前已通过了if判断，所以它也会构造一个对象2。如此一来就会多次实例化，在多线程的情况下无法保证只有一个实例对象。</p><hr><p>但如果我们在类初始化时就创建单例的话，就可以保证线程安全。以下为单例模式中的饿汉模式代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用这个做法，JVM在加载这个类时马上创建此唯一的单件实例。JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。</p><h3 id="2-双重校验锁："><a href="#2-双重校验锁：" class="headerlink" title="2.双重校验锁："></a>2.双重校验锁：</h3><p>首先检查实例uniqueInstance是否已经创建了，如果尚未创建，才对实例化语句进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//volatile关键字确保当uniqueInstacne被实例化时，多个线程能正确地处理uniqueInstacne变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstacne;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getIntance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;  <span class="hljs-comment">//同步锁</span><br>                <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-keyword">null</span>)&#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重校验锁使用两个if语句来保证线程安全：</p><ul><li>第一个if语句保证了只有在第一次调用getIntance()方法的时候才进行加锁操作，之后直接return已被构造的单例即可，无需加锁。</li><li>第二个if语句避免了重复实例化对象。例如：两个线程同时进入synchronized临界区，若没有这步if判断，当线程A构建完对象，B由于已经通过了第一个if语句，不知道A已经构造好了对象，于是它也会再构造另一个对象。</li></ul><p><strong>对单例uniqueInstacne使用volatile关键字的原因</strong> ：<br>在Java中这样一句uniqueInstance = new Singleton()，会被JVM编译成如下指令：</p><ol><li><p>给uniqueInstance分配内存空间</p></li><li><p>初始化该内存空间的对象</p></li><li><p>将uniqueInstance指向已分配的内存地址</p><p>但这几步顺序也有可能经过JVM和CPU的优化，被重排成1、3、2的顺序。在多线程的情况下：当线程A完成指令1、3后，对象还未被初始化但是uniqueInstance已经不指向null。这时如果线程B走到了第一步if判断，会发现uniqueInstance不为null，于是直接return uniqueInstance，但这时单例还未被初始化。从而会返回一个尚未初始化完成的对象。</p></li></ol><p>使用volatile可以避免JVM的指令重排，如此一来将始终保证1、2、3的顺序。所以uniqueInstacne要么指向null，要么指向一个已初始化的对象，不会出现中间状态，保证了线程安全。</p><h3 id="3-静态内部类实现"><a href="#3-静态内部类实现" class="headerlink" title="3.静态内部类实现"></a>3.静态内部类实现</h3><p>从外部无法访问静态内部类LazyHolder，当调用Singleton.getInstance()方法时，才能得到单例对象INSTANCE。</p><p>当加载类Singleton时，类LazyHolder并没有被加载，因此单例INSTANCE并未被初始化。当调用Singleton.getInstance()方法时，内部类LazyHolder才被加载，INSTANCE才被实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Eric Freeman. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192251&idx=2&sn=4acce2985ab4fcc908235891c9213628&chksm=8c99f2e1bbee7bf7f64132bb58d3023f79b3c11fe2043dcd29fe07f4ddb5b3c7d375252d8555&mpshare=1&scene=1&srcid=10145YhZbl4txuQIh5xlFBqA&sharer_sharetime=1602674938022&sharer_shareid=63ec0aac0cd5411bee34cfcffcb8dd13&key=39efdee81dad78454480c9b361da08ead78bf35d989c6aaa0d4edc8e92fa7b9ce91a527f838f4b0a7d81f2828cee6ace059f058b1394c2b39c5ef15f877901053d8f24be422fb2ca4c912f2ade0b016cff8a88b43e2bd8dbd0db14269a57cf17c1ee40c4b58e63e3602182361d2442145db6c25d6eb6463c1042ac218a37da4e&ascene=1&uin=MjMwMzI4OTM4MA==&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AZ9HDfnHe+jxOhY62YWHjFM=&pass_ticket=MWeci50fAmUpNH9xi84lqGhymZw0Eks6tmCWWalvvtE8ydesOK9/2HCdSS9Ucqzv&wx_header=0">漫画：什么是单例模式？</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%20-%20%E5%8D%95%E4%BE%8B.md">Cyc2018:设计模式-单例</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务</title>
    <link href="/2021/02/15/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/02/15/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="事物的概念"><a href="#事物的概念" class="headerlink" title="事物的概念"></a>事物的概念</h2><p>事物是访问并更新数据库中数据项的一组操作，它们要么都执行，要么都不执行。</p><p>可以通过commit提交一个事物，也可以通过rollback来进行回滚</p><p>MySQL默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每执行一个SQL语句后就会马上执行COMMIT操作。</p><h2 id="事物的四大特性ACID"><a href="#事物的四大特性ACID" class="headerlink" title="事物的四大特性ACID"></a>事物的四大特性ACID</h2><ul><li>原子性(Atomicity)：是指数据库事物是不可分割的最小工作单位，只有事物中的所有操作成功，事物才能进行提交。事物中有任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该回滚到执行事务之前的状态。</li><li>一致性(Consistency):在事物执行前后，数据库能从一个正确的状态转移到另一个正确的状态。依靠隔离性和原子性实现。</li><li>隔离性(Isolation)：一个事物在提交前对其他事物是不可见的。即在并发访问数据库时，各并发事物之间数据库是独立的。</li><li>持久性(Durability)：事物一旦提交，其所做的修改会永远保存到数据库中，即使系统崩溃，数据库也能通过重做日志(Redo log)将数据恢复。</li></ul><h2 id="事物的实现："><a href="#事物的实现：" class="headerlink" title="事物的实现："></a>事物的实现：</h2><ul><li>用锁来保证事物的一致性</li><li>redo log用来保证事物的原子性和持久性</li><li>undo log用来保证事物的一致性</li></ul><p>其中，redo恢复提交事务修改的页操作，而undo回滚行记录到某一个特定的版本。</p><p>当事物提交(commit)时,必须先将该事务的所有日志写入到重做日志文件(Redo log)中进行持久化。</p><p>在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。如果用户执行的事物或语句由于某种原因失败了，又或者用户用一条RollBack语句请求回滚，可以利用这些undo信息将数据回滚到修改前的样子。</p><p>保存点(Savepoint)用来通知系统应该记住事物当前的状态，以便之后发生错误时，事物能回到保存点当时的状态。注意：rollback to savepoint命令并不真正的结束事物。</p><h2 id="事物的隔离级别"><a href="#事物的隔离级别" class="headerlink" title="事物的隔离级别"></a>事物的隔离级别</h2><p>SQL标准定义了以下四种隔离级别：</p><ul><li>READ UNCOMMITTED（读取未提交）:最低的隔离级别，一个事务所做的修改，即使尚未提交，对其他事务也是可见的。<strong>会导致脏读、幻读或不可重复读</strong></li><li>READ COMMITTED（读取已提交）：一个事务所做的修改在提交之前对其他事务是不可见的。<strong>可以避免脏读，但不能避免幻读或不可重复读</strong></li><li>REPEATABLE READ（可重复读）：保证在同一个事务中多次读取同一数据的结果是一样的，除非该数据被这个事务自己所修改。为InnoDB默认的隔离级别。<strong>可以避免脏读和不可重复读，但不能避免幻读</strong></li><li>SERIALIZABLE（可串行化）：最高的隔离级别，强制事务串行执行，这样多个事务间就不会产生干扰，也就不会出现并发不一致问题（需要加锁实现）。<strong>可以避免脏读、不可重复读和幻读</strong>。</li></ul><p>隔离级别越低，事务请求的锁越少或保持锁的时间越短。</p><p>虽然InnoDB存储引擎在默认的隔离级别为REPEATABLE READ（可重读）但其在该事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生，这与其他数据库系统是不同的。所以说InnoDB存储引擎的在默认的隔离级别下已经能完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化) 隔离级别。因此，InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。</p><p>此外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE(可串行化)</p><p><img src="/img/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 第2版[M]. 机械工业出版社, 2013.</li><li><a href="https://blog.csdn.net/qq_34337272/article/details/80611486">MySQL锁机制</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">Cyc2018:数据库系统原理</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md#%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8Einnodb%E9%94%81%E7%AE%97%E6%B3%95">JavaGuide；MySQL</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2021/02/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式分为三种，分别为：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>接下来以pizza店的例子阐述三种模式</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>一句话描述：简单工厂模式将对象的创建封装了起来</strong></p><p>通过工厂类创建对象，并且根据传入参数决定具体要实例化哪种子类对象的做法，叫简单工厂模式(Simpe Factory Pattern)<br>以下代码描述了产品类，包括一个抽象接口和两个具体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Pizza类为接口，description方法由具体的pizza类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//有两种pizza类实现了上面的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am cheesepizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am veggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们构建一个pizza工厂专门负责构造pizza对象。从而把本应在PizzaStore中构造并初始化pizza对象的代码迁移到pizza工厂类的创建方法createPizza中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//pizza工厂类。这个类只做一件事：帮客户创建pizza</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePizzaFactory</span></span>&#123;<br>    <span class="hljs-comment">//在创建方法中传入参数type，根据参数来判断要创建哪种pizza对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String type)</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;cheese&quot;</span>))<br>            pizza = <span class="hljs-keyword">new</span> CheesePizza();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;veggie&quot;</span>))<br>            pizza = <span class="hljs-keyword">new</span> VeggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在客户端（也就是PizzaStore类）中，想要创建哪种对象，只需传入对应的名称即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">(String type)</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个工厂对象factory</span><br>        SimplePizzaFactory factory = <span class="hljs-keyword">new</span> SimplePizzaFactory();<br>        <span class="hljs-comment">//再利用工厂factory创建与type相对应的工厂对象</span><br>        Pizza pizza = factory.createPizza(type);<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法（均可以调用createPizza方法创建pizza对象）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过简单工厂模式，我们可以把客户类和具体子类的实例化解耦，客户端不再需要用众多if else语句根据type判断自己应该实例化哪个子类。现在客户端只需要用将type传入工厂类中的创建方法，即可在在这个方法的返回值中得到想要的对象。</p><p>这样做有什么好处呢？   </p><blockquote><p>设想如果未使用简单工厂模式，在客户端用if else判断并实例化产品对象。当我们有多个客户端的时候，这些客户端就都需要知道产品的细节（即有哪些产品以及需要构建哪种产品对象）。而且如果我们多增加一项产品，那么这么多客户端都需要进行修改（再增加一条if else语句）</p></blockquote><p>简单工厂模式的缺陷：  </p><blockquote><p>即使使用了简单工厂模式，当我们多增加一项产品时，还是要在工厂类的构建方法中增加一条if else语句。这样就不符合”对扩展开放，对修改封闭”的OO原则。</p></blockquote><p>因此就引入了工厂方法模式，我们将在这个模式中解决以上缺陷带来的问题。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>一句话描述：每一个产品子类都有一个对应的工厂子类</strong></p><p>在工厂方法模式中，我们为每一个Pizza子类创建对应的工厂子类，工厂方法模式将构建产品的细节封装进具体的工厂子类中。注意：</p><ul><li>每一个Pizza子类都实现Pizza接口</li><li>每一个工厂子类都实现工厂接口</li></ul><p>因此，我们可以使用某一种具体工厂子类创建其对应的Pizza对象。当新增一种pizza时，我们构建一种和它对应的新工厂子类，就可以构造这种pizza对象。而不用在工厂类中修改代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象的工厂接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-function">Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//以下为两种工厂子类:CheesePizza工厂和VeggiePizza工厂</span><br><span class="hljs-comment">//它们分别实现了工厂接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizzaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">new</span> CheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeggiePizzaFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PizzaFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">()</span></span>&#123;<br>        Pizza pizza = <span class="hljs-keyword">new</span> VeggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于客户端PizzaStore，想得到哪种Pizza对象，只需要构造与其对应的工厂子类对象，并使用其创建方法即可。连简单工厂模式中的传入type参数这一步都免了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个cheese披萨工厂</span><br>        PizzaFactory cheesefactory = <span class="hljs-keyword">new</span> CheesePizzaFactory();<br>        <span class="hljs-comment">//再利用这个工厂创建我们想要的cheese披萨</span><br>        Pizza pizza = cheesefactory.createPizza();<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg"></p><p>工厂方法模式的缺陷：  </p><blockquote><p>如果我们的产品子类越来越多，那么我们就要为每一个产品子类都创建一个工厂子类，这样类就会越来越多，非常繁琐。</p></blockquote><p>为了解决这个问题，以下引入抽象工厂模式</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>一句话描述：把产品分组，每组配备一个工厂，组内不同产品对应于这个工厂中的不同方法</strong></p><p>在抽象工厂模式中，我们不为每一个产品子类配备一个工厂子类。而是将产品进行分组，每组组内的不同产品由同一个工厂类的不同方法创建。</p><p>假设我们当前有四种pizza产品，分别为：</p><ul><li>大份cheese披萨</li><li>小份cheese披萨</li><li>大份蔬菜披萨</li><li>小份蔬菜披萨</li></ul><p>工厂方法模式的做法是：为这四种产品类都配备一个对应的具体工厂子类。</p><p>而对于抽象工厂模式，我们将产品分为两组：大份组和小份组。每组配备一个工厂。</p><p>以下为产品类：包括cheese披萨和蔬菜披萨两种抽象接口，每种接口分别由大份和小份两个具体类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">cheesePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigcheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cheesePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a BigcheesePizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallcheesePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">cheesePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a SmallcheesePizza&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">veggiePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigveggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">veggiePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a BigveggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallveggiePizza</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">veggiePizza</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cook a SmallveggiePizza&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是工厂类，先定义一个抽象的工厂接口。由于产品有两种（大份披萨和小份披萨），因此我们实现两种工厂类BigFactory和SmallFactory，分别用来构建大披萨对象和小披萨对象。</p><p>此外，每个工厂对应产品分类中的所有产品，工厂类都有一个与其对应的构建方法。例如：我们想得到一个大份cheese披萨对象，那么只需要使用大份pizza工厂中的createCheesePizza()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-function">cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//大份披萨工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>&#123;<br>        cheesePizza pizza = <span class="hljs-keyword">new</span> BigcheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>&#123;<br>        veggiePizza pizza = <span class="hljs-keyword">new</span> BigveggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//小份披萨工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> cheesePizza <span class="hljs-title">createCheesePizza</span><span class="hljs-params">()</span></span>&#123;<br>        cheesePizza pizza = <span class="hljs-keyword">new</span> SmallcheesePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> veggiePizza <span class="hljs-title">createVeggiePizza</span><span class="hljs-params">()</span></span>&#123;<br>        veggiePizza pizza = <span class="hljs-keyword">new</span> SmallveggiePizza();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是客户端代码，通过使用不同的工厂，并调用该工厂中不同的创建方法，我们就可以创造出不同的产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//先创建一个大份披萨工厂</span><br>        Factory1 BigFactory = <span class="hljs-keyword">new</span> BigFactory();<br>        <span class="hljs-comment">//再利用这个工厂中的相应方法创建我们想要的cheese披萨</span><br>        Pizza pizza = BigFactory.createCheesePizza();<br>        pizza.cook();<br>        <span class="hljs-keyword">return</span> pizza;<br>    &#125;<br>    <span class="hljs-comment">//其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储管理</title>
    <link href="/2021/02/15/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2021/02/15/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="1-地址空间"><a href="#1-地址空间" class="headerlink" title="1.地址空间"></a>1.地址空间</h2><p>就像进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。</p><p>即要做到的是：给每个程序一个自己的地址空间，使得一个程序中的地址28所对应的物理地址与另一个程序中的地址28所对应的物理地址不同。</p><p>一种为每个进程提供私有地址空间的简单方式是：使用两个寄存器，程序的起始物理地址装载到<strong>基址寄存器</strong>中，程序的长度装载到<strong>界限寄存器</strong>中。每个内存地址在送到内存之前，都会自动先加上基址寄存器的内容。</p><hr><p>如果把所有进程一直保存在内存中需要巨大的内存，如果内存不够，就做不到这一点。处理这种内存超载问题有以下两种方式</p><ul><li>交换技术<br>把一个进程完整地调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要在磁盘上，所以当它们不运行时就不会占用内存。但是受限于磁盘传输速率限制，将进程从磁盘调出和换入通常需要不短的时间。</li><li>虚拟内存（使得程序在只有一部分被调入内存的情况下运行）</li></ul><h2 id="2-虚拟内存"><a href="#2-虚拟内存" class="headerlink" title="2.虚拟内存"></a>2.虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>虚拟内存的基本思想是：每个程序都有自己的地址空间，这个空间被分割成多个块，每个块称作一个页面(page)。每一页有自己连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的页时，由硬件执行必要的映射。当程序引用到不在物理内存中的页时，操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。、</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K，这些地址是虚拟地址。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p>注意：在使用虚拟内存的情况下，虚拟地址不是直接被送到内存总线上，而是被送到内存管理单元（MMU），MMU把虚拟地址映射成为物理内存地址。</p><p><img src="/img/%E5%9B%BE3.1.jpg" alt="avatar"></p><p>虚拟地址空间按照固定大小划分成称为页面(page)的若干单元。在物理内存中对应的单元成为页框(page frame)</p><p>如果程序访问到一个未映射的页面，内存管理单元MMU法线该页没有被映射（/img/图中用X表示），于是使CPU陷入到操作系统，这里称为**<em>缺页中断**</em> (page fault)。操作系统找到一个很少使用的页框且把它的内容写入磁盘，然后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表的目的是把虚拟页面映射为相应的页框。每个进程需要自己的页表（因为它有自己的虚拟地址空间）</p><p>虚拟内存的本质上是用来创造一个新的抽象概念——地址空间。这个概念是对物理内存的抽象，类似于进程是对物理机器(CPU)的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某一页。</p><h2 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3.页面置换算法"></a>3.页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最优页面置换算法"><a href="#1-最优页面置换算法" class="headerlink" title="1. 最优页面置换算法"></a>1. 最优页面置换算法</h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。<br>此算法是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1<br></code></pre></td></tr></table></figure><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-最近最久未使用页面置换算法"><a href="#2-最近最久未使用页面置换算法" class="headerlink" title="2. 最近最久未使用页面置换算法"></a>2. 最近最久未使用页面置换算法</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h3 id="3-先进先出"><a href="#3-先进先出" class="headerlink" title="3. 先进先出"></a>3. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。<br>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h3 id="4-第二次机会算法"><a href="#4-第二次机会算法" class="headerlink" title="4. 第二次机会算法"></a>4. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><h3 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h3><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><h3 id="7-工作集页面置换算法"><a href="#7-工作集页面置换算法" class="headerlink" title="7.工作集页面置换算法"></a>7.工作集页面置换算法</h3><p>一个进程正在使用的页面的集合称为它的工作集（working set）。如果整个工作集都被装入到了内存中，那么进程在运行到下一个阶段之前，不会产生很多缺页中断。若内存太小而无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断，导致运行速度也会变得很缓慢。若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了颠簸（thrashing）</p><p>不少分页系统都会跟踪进程的工作集，以确保在让进程运行之前，它的工作集就已经在内存中了。该方法称为工作集模型，其目的在于大大减少缺页中断。在让进程运行前预先装入其工作集页面也成为预先调页(prepaging)</p><p>基于工作集的页面置换算法的基本思路就是找出一个不在工作集中的页面并淘汰它。</p><p><img src="/img/%E5%9B%BE3.5.jpg" alt="avatar"></p><p>最好的两种算法是老化算法和工作集时钟算法</p><h2 id="4-分段"><a href="#4-分段" class="headerlink" title="4.分段"></a>4.分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与物理内存进行映射。</p><p><img src="/img/%E5%9B%BE3.2.jpg" alt="avatar"></p><p>下/img/图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p>分段的做法是把每个表分成段，一个段(segment)构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。它们既不会影响到其他的段，地址空间中也没有任何其他东西阻挡它增长。</p><p><img src="/img/%E5%9B%BE3.3.jpg" alt="avatar"></p><p>使用段的好处是：</p><ul><li>简化对长度经常变动的数据结构的管理</li><li>简化链接操作</li><li>简化修改</li><li>有助于在几个进程之间共享过程和数据</li></ul><h3 id="分段与分页的结合"><a href="#分段与分页的结合" class="headerlink" title="分段与分页的结合"></a>分段与分页的结合</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><p><img src="/img/%E5%9B%BE3.4.jpg" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2021/02/15/%E6%AD%BB%E9%94%81/"/>
    <url>/2021/02/15/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h2><p>在进程对设备、文件等资源取得了排他性的访问权时，有可能会出现死锁。</p><p>资源可以分为如下两类：</p><ul><li>可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用（比如存储器）</li><li>不可抢占资源：在不引起相关计算失败的情况下，无法把它从占有它的进程中抢占过来（比如CD刻录机）</li></ul><p>考虑这样一种情况：进程A获取了资源1，进程B获取了资源2，每个进程如果都想请求另一个资源就会被阻塞，那么每个进程都无法继续运行。这种情况就是死锁。</p><h2 id="2-死锁的条件"><a href="#2-死锁的条件" class="headerlink" title="2.死锁的条件"></a>2.死锁的条件</h2><ul><li><p><strong>互斥条件</strong>：每个资源要么已经分配给了一个进程，要么就是可用的。</p></li><li><p><strong>占有和等待条件</strong>：已经得到了某个资源的进程可以再请求新的资源。</p></li><li><p><strong>不可抢占条件</strong>：已经分配给一个进程的资源不能强制被抢占，它只能被占有它的进程显式地释放。</p></li><li><p><strong>环路等待条件</strong>：死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。</p><p>死锁发生时，以上四个条件必须同时满足。</p></li></ul><h2 id="3-处理方法"><a href="#3-处理方法" class="headerlink" title="3.处理方法"></a>3.处理方法</h2><p>有以下四种处理死锁的策略：</p><ul><li><strong>鸵鸟策略</strong>：忽略该问题</li><li><strong>死锁检测并恢复</strong>：让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。</li><li><strong>死锁避免</strong>：仔细对资源进行分配，动态地避免死锁。</li><li><strong>死锁预防</strong>：通过破坏死锁的四个条件，防止死锁的产生。</li></ul><h3 id="3-1-鸵鸟策略"><a href="#3-1-鸵鸟策略" class="headerlink" title="3.1 鸵鸟策略"></a><strong>3.1 鸵鸟策略</strong></h3><p>像鸵鸟一样，把头埋在沙子里，假装根本没发生问题。<br>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方案会获得更高的性能。<br>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="3-2-死锁检测并恢复"><a href="#3-2-死锁检测并恢复" class="headerlink" title="3.2 死锁检测并恢复"></a><strong>3.2 死锁检测并恢复</strong></h3><p>核心思想：系统并不试/img/图阻止死锁的发生，而是允许死锁发生。当检测到死锁发生时，采取措施进行恢复。</p><p>死锁恢复：</p><ul><li>利用抢占恢复：将某一资源从一个进程强行取走给另一个进程使用，接着又送回。</li><li>利用回滚恢复：将一个进程复位到一个更早的状态，那是它还没有取得所需的资源，接着就把这个资源分配给一个死锁进程。如果复位后的进程试/img/图重新获得对该资源的控制，它就必须一直等到该资源可用时为止。</li><li>通过杀死进程恢复：杀掉环中的一个进程，打破死锁。</li></ul><h3 id="3-3-死锁避免"><a href="#3-3-死锁避免" class="headerlink" title="3.3 死锁避免"></a><strong>3.3 死锁避免</strong></h3><p>资源轨迹/img/图：</p><p><img src="/img/%E5%9B%BE6.1.jpg" alt="avatar"></p><p>/img/图中阴影部分表示该区域内两进程都拥有打印机或都拥有绘/img/图仪，互斥使用的规则决定了不可能进入该区域。</p><p>在点t，进程B请求资源。系统必须决定是否分配。如果系统把资源分配给B，系统进入不安全区域。要避免死锁，应该将进程B挂起，直到A请求并释放绘/img/图仪。</p><p><strong>安全状态和不安全状态</strong><br>如果死锁没有发生，并且即使所有进程突然请求对资源的最大需求，也让然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>下/img/图所示的状态即为安全状态：<br><img src="/img/%E5%9B%BE6.2.jpg" alt="avatar"></p><p>从/img/图 a 开始出发，先让 B 拥有所需的所有资源（/img/图 b），运行结束后释放 B，此时空闲数变为 5（/img/图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称/img/图 a 所示的状态时安全的。</p><p>如果任何分配资源实例的序列都无法保证工作的完成，则从安全状态进入到了不安全状态。如下/img/图所示：<br><img src="/img/%E5%9B%BE6.3.jpg" alt="avatar"></p><p>注意：**<em>不安全状态并不是死锁**</em>。<br>安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。</p><p><strong>银行家算法</strong><br>银行家算法将客服比作进程，将贷款单位比作资源，将银行家比作操作系统。</p><p>银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会达到安全状态。若是，那么就满足该请求；若否，那么久推迟对这一请求的满足。为了看状态是否安全，银行家看他是否有足够的资源满足某个客户。如果可以，那么这笔投资认为是能够收回的，并且接着检查最接近最大限额的一个客户，以此类推。如果所有投资最终都被收回，那么该状态是安全的，最初的请求可以被批准。</p><h2 id="3-4-死锁预防"><a href="#3-4-死锁预防" class="headerlink" title="3.4 死锁预防"></a><strong>3.4 死锁预防</strong></h2><p>通过破坏死锁的四个条件，防止死锁的产生。</p><ul><li>破坏互斥条件：如果资源不被一个进程独占，那么死锁肯定不会发生。</li><li>破坏占有和等待条件：要求当一个进程请求资源时，先暂时释放其当前占有的所有资源，然后再尝试一次获得所需的全部资源。</li><li>破坏不可抢占条件：可以通过将一些资源虚拟化的方式来实现。</li><li>破坏环路等待条件：将资源进行编号，制定规则：进程可以在任何时候提出资源请求，但是所有资源请求必须按照资源编号的顺序退出。任何时候总有一个已分配的资源是编号最高的。占用该资源的进程不可能请求其他已分配的各种资源。它或者会执行完毕，或者最坏的情况是去请求编号更高的资源，而编号更高的资源肯定是可用的。最终，它会结束并释放所有的资源，这时其他占有最高编号资源的进程也可以执行完。简而言之，存在一种所有进程都可以执行完毕的情景，所以不会产生死锁。</li></ul><p><img src="/img/%E5%9B%BE6.4.jpg" alt="avatar"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引</title>
    <link href="/2021/02/15/%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/02/15/%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引也叫键，是帮助存储引擎快速找到记录的一种数据结构。相当于一个目录的作用。</p><p>索引的优点：</p><ul><li>加快数据的检索速度</li><li>通过创建唯一性索引，保证数据库表中每一行数据的唯一性</li></ul><p>索引的缺点：</p><ul><li>创建和维护索引需要耗费时间：当对表中数据进行修改时，如果数据有索引，那么索引也需要修改。</li><li>占用物存储空间</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是一颗搜索树，也是平衡树。<br>在B+树中，所有记录节点都是按照键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列。如下图所示：如果一个指针的左右相邻的key分别是3和5，则该指针所指向节点的所有key大于等于3小于等于5。</p><p>B树与B+树的区别：</p><ul><li>B树的所有节点既存放键(key)也存放数据(data);而B+树只有叶子节点存放key和data，其他内节点只存放key。</li><li>B树的叶子节点都是独立的;B+树的叶子节点有一条指针指向与它相邻的叶子节点。</li></ul><p><img src="/img/b+%E6%A0%91.jpg"></p><p>B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入内存中，再在内存中进行查找，最后得到要查找的数据。</p><p>此外，数据库系统将B+树的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p>由于B+树和红黑树相比有更低的树高度。一般B+树的高度都在2-4层，因此查找某一键值的行记录时最多只需要2-4次IO操作。</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>B+树索引可以分为聚集索引和辅助索引。</p><ul><li>二者相同点为：内部结构都为B+树，即高度平衡。叶子节点存放着所有的数据。</li><li>二者不同点为：​ 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。<h3 id="1-聚集索引"><a href="#1-聚集索引" class="headerlink" title="1.聚集索引"></a>1.聚集索引</h3>聚集索引即索引结构和数据一起存放的索引。聚集索引(clustered index)按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行数据，也将聚集索引的叶子节点称为数据页。</li></ul><p>因为无法把行数据存放在两个不同地方，因此一个表只能有一个聚集索引。</p><p>在数据页（叶子节点）上存放的是完整的每行的记录，而在非数据页（非叶子节点）的索引页中，存放的仅仅是键值及指向数据页的偏移量。</p><h3 id="2-辅助索引"><a href="#2-辅助索引" class="headerlink" title="2.辅助索引"></a>2.辅助索引</h3><p>对于辅助索引，叶子节点不包含行记录的数据<br>。叶子节点data中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚集索引中得到完整的一行记录。</p><p>即：有以下两步（<strong>回表查询</strong>：先定位主键值，再定位行记录）：</p><ul><li>先通过普通索引定位到主键值</li><li>再通过聚集索引定位到行记录</li></ul><p><strong>覆盖索引</strong>：如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引基于哈希表实现，简单地说就是把键值换算成hashcode，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快(O(1)时间复杂度）。</p><p>但有着如下缺点：</p><ul><li>哈希索引和B+树索引相比，丧失了有序性。因此无法排序和分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>自适应哈希索引是指：当InnoDB注意到某些索引被使用得很频繁时，会在内存中创键哈希索引，让 B+树 索引也具有哈希索引的一些优点。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 第2版[M]. 机械工业出版社, 2013.</li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md">Cyc2018:MySQL</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.md">JavaGuide:数据库索引总结2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2021/02/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了一簇算法，并把它们分别封装起来，让它们之间可以相互替换。此模式让算法的变化独立于使用算法的客户。</p><p><img src="/img/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义一个算法簇：描述鸭子的不同飞行行为.算法簇包含两个具体的算法(行为)：FlyWithWings和FlyNoWay。它们都实现自接口FlyBehavior</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I can fly with wings&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyNoWay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlyBehavior</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I can&#x27;t fly&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下为鸭子类，它不需要知道飞行行为的具体细节。因为它已将飞行行为委托给别人处理，而不是在Duck类内部定义这些行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span></span>&#123;<br>    <span class="hljs-comment">//FlyBehavior实例变量是一个接口类型，我们能在运行时利用多态为它指定不同的具体实现类。</span><br>    <span class="hljs-keyword">private</span> FlyBehavior flyBehavior;<br>    <span class="hljs-comment">//不在乎flyBehavior接口的对象是什么，只关心该对象知道如何进行fly动作就够了。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performFly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(flyBehavior != <span class="hljs-keyword">null</span>)<br>            flyBehavior.fly();<br>    &#125;<br>    <span class="hljs-comment">//为这个鸭子类设置给定的飞行行为</span><br>    <span class="hljs-comment">//在运行时想改变鸭子的飞行行为，只需调用这个方法即可</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlyBehavior</span><span class="hljs-params">(FlyBehavior flyBehavior)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.flyBehavior = flyBehavior;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，因为飞行行为已经和鸭子类解耦（实际上二者为组合关系），因此飞行动作也可以被其他类的对象复用。而且当我们新增飞行行为时，只需要多创建一个实现飞行接口的具体行为类即可，不会影响到既有的具体行为类，也不会影响使用到飞行行为的Duck类。</p><p>以下为客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Duck duck = <span class="hljs-keyword">new</span> Duck();<br>        duck.setFlyBehavior(<span class="hljs-keyword">new</span> FlyWithWings());<br>        duck.performFly();<br>        duck.setFlyBehavior(<span class="hljs-keyword">new</span> FlyNoWay());<br>        duck.performFly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出将依次为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">I can fly <span class="hljs-keyword">with</span> wings<br>I can<span class="hljs-symbol">&#x27;t</span> fly<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2021/02/15/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2021/02/15/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层分为数据平面和控制平面。  </p><ul><li>数据平面的作用是在一个路由器中，将数据报从一个输入链路转移到一个适当的输出链路，即转发功能(forward)</li><li>控制平面的作用是协调一个网络中的每个路由器的转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送，即路由功能(routing)</li></ul><p>链路层交换机和路由器的区别：</p><ul><li>链路层交换机基于链路层帧中的字段值做出转发决定，交换机因此被称为链路层设备。</li><li>路由器基于网络层数据报中的首部字段做出转发决定，路由器因此被称为网络层设备</li></ul><p>当一个数据报从源被传送到目的地主机时，它通过了一些列的路由器。每个路由器都是用这个数据报的目的地地址来转发包。即，每个路由器都有一个转发表，其将目的地的IP地址与一个输出链路接口相对应。当一个数据报到达路由器时，路由器使用数据高的目的Ip地址在转发表中找到一个合适的输出链路接口(output link interface)</p><p>网络层协议概览：</p><p><img src="/img/%E5%9B%BE%E7%89%874.1.jpg"></p><h2 id="2-IP协议-Internet-Protocol"><a href="#2-IP协议-Internet-Protocol" class="headerlink" title="2.IP协议(Internet Protocol)"></a>2.IP协议(Internet Protocol)</h2><h3 id="2-1-IP数据报格式："><a href="#2-1-IP数据报格式：" class="headerlink" title="2.1 IP数据报格式："></a>2.1 IP数据报格式：</h3><p><img src="/img/%E5%9B%BE%E7%89%874.2.jpg" alt="IP数据报格式"></p><ul><li>header length：由于IPv4数据报中包含一些可变数量的选项(options),因此需要首部长度字段用来确定IP数据报中载荷从何处开始。大多数IP数据报不包含(option),所以**<em>一般的IP数据报具有20字节的首部**</em>。</li><li>TTL(Time-to-live):该字段用来确保数据报不会永远在网络中循环。每当一个路由器处理数据包时，该字段就减1.若TTL字段减为0，则该数据报被丢弃。</li><li>Protocol：该字段只有当一个IP数据报到达其最终目的地时才会有用，其指示了IP数据报的数据部分应该交给哪个特定的传输层协议。例如：值为6表明要将data交给TCP，值为17表明要将data交给UDP。这里Protoclo字段所起到的作用，类似于传输层报文段中的端口号的作用。**<em>协议号是将网络层与传输层绑定在一起的粘合剂，而端口号是将传输层与应用层绑定在一起的粘合剂**</em></li><li>首部检验和：路由器对收到的每个IP数据报计算其首部检验和，如果数据报首部中携带的检验和，与计算得到的检验和不一致，则检测出error，路由器一般会丢掉检测出error的数据报。</li></ul><h3 id="2-2-IP编址"><a href="#2-2-IP编址" class="headerlink" title="2.2 IP编址"></a>2.2 IP编址</h3><p>主机和物理链路之间的边界叫接口。IP要求每台主机和路由器接口拥有自己的IP地址。因此一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>每个IP地址长度为32比特（4字节），这些地址通常按所谓点分十进制记法表示，即地址中的每个字节用它的十进制形式书写，各字节间以句点隔开。</p><p><img src="/img/%E5%9B%BE%E7%89%874.3.jpg"></p><p>如/img/图片所示，在这个例子中，互联左上方的三个主机接口和一个路由器接口的网络形成一个子网。IP编址为这个子网分配一个地址223.1.1.0/24。其中的“/24”记法，称为子网掩码（subnet mask），指示32比特中的最左侧24比特定义了子网地址。一个子网中的所有设备拥有共同的子网地址。</p><p>形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。当该组织外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组值的内部时，仅需要考虑该地址前面的x比特，这相当大地减少了在这些路由器中转发表的长度。</p><p>一个地址的剩余32-x比特可认为是用于区分该组织内部设备的，其中的所有设备具有相同的网络前缀。当该组织内部的路由器转发分组时，才会考虑这些比特。</p><p>IP广播地址是255.255.255.255。当一个主机发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机。</p><h2 id="3-DHCP协议"><a href="#3-DHCP协议" class="headerlink" title="3. DHCP协议"></a>3. DHCP协议</h2><p>DHCP(Dynamic Host Configuration Protocal)协议允许主机自动获取一个IP地址。网络管理员能够配置DHCP，以使某给定主机每次与网络连接时能得到一个相同的IP地址，或者某主机将被分配一个临时的IP地址，每次与网络连接时该地址也许是不同的。同时，DHCP还允许一台主机得知其他的一些信息，例如子网掩码、第一条路由器地址（默认网关）与它的本地DNS服务器的地址。</p><p>DHCP适合这样的情况：许多用户来来往往，并且只在有限的时间内需要地址。</p><p>每个子网一般都将具有一台DHCP服务器。如果在子网中没有服务器，则需要一个DHCP中继代理，这个代理知道用于该网络的DHCP服务器的地址。</p><p>DHCP协议的四个步骤（yiaddr:your Internet adress)：    </p><p><img src="/img/%E5%9B%BE%E7%89%874.4.jpg"></p><ul><li><strong>DHCP服务器发现</strong>：一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可以通过广播DHCP发现报文(DHCP discover message)来完成，客户在UDP分组中向端口67发送该发现报文。</li><li><strong>DHCP服务器提供</strong>：当DHCP服务器收到一个DHCP发现报文时，用DHCP提供报文（DHCP offer message）向客户做出响应，该报文向该子网中的所有节点广播，仍然使用广播地址255.255.255.255。每台DHCP服务器提供的报文含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP地址租用期（即IP地址有效的时间量）</li><li><strong>DHCP请求</strong>：新到达的客户从一个或多个服务器offer中选择一个，并向选中的服务器offer用DHCP请求报文（DHCP request message）进行响应，并回显配置的参数。</li><li><strong>DHCP ACK</strong>：服务器使用DHCP ACK报文（DHCP ACK message）对DHCP请求报文进行响应，证实所要求的参数。</li></ul><h2 id="4-网络地址转换（NAT）"><a href="#4-网络地址转换（NAT）" class="headerlink" title="4.网络地址转换（NAT）"></a>4.网络地址转换（NAT）</h2><p>NAT用于如下/img/图片所示的家庭网络等专用网络或具有专用地址的地域，一个具有专用地址的地域是指其地址仅对该网络中的设备有意义的网络。</p><p><img src="/img/%E5%9B%BE%E7%89%874.5.jpg"></p><p>NAT路由器对于外部设备来说甚至不像一台路由器，相反它对外界的行为就像一个具有单一IP地址的设备。在/img/图片中，所有离开家庭路由器流向更大的因特网的报文都拥有一个源地址138.76.29.7,且所有进入家庭的报文都拥有一个目的地址138.76.29.7。NAT路由器对外界隐藏了家庭网络内的细节。</p><p>路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间的计算机提供地址。</p><p>例如：主机10.0.0.1指派了源端口号3345并将该数据报发送到LAN中，NAT路由器收到该数据报，为其生成一个新的源端口号5001，将源IP地址替代为其WAN一侧接口的IP地址138.76.29.7，且将源端口3345更换为新端口5001.<br>当报文到达NAT路由器时，路由器使用目的地址的IP地址与目的端口号从NAT转发表中检索出家庭网络浏览器使用的相应IP地址。于是，路由器重写该数据报的目的地址和目的端口号，并向家庭网络转发该数据报。</p><p>注：如果一个主机在NAT后面，那么它无法作为一个服务器接受TCP连接请求。</p><h2 id="5-ICMP（Internet-Control-Message-Protocol"><a href="#5-ICMP（Internet-Control-Message-Protocol" class="headerlink" title="5.ICMP（Internet Control Message Protocol)"></a>5.ICMP（Internet Control Message Protocol)</h2><p>主机和路由器用ICMP来彼此沟通网络层的信息。ICMP最典型的用途是差错报告。ICMP报文是承载在IP分组中的，因此从体系结构上讲它是位于IP之上的，但是它仍然被认为是网络层的协议而不是更高层的协议。当一台主机收到一个指明上层协议为ICMP的IP数据报时，它分解出该数据报的内容给ICMP，就像分解出一个数据报的内容给TCP或UDP一样。</p><p>ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8字节内容（以便发送方能确定引发该差错的数据报）<br>ICMP报文类型如下：</p><p><img src="/img/%E5%9B%BE%E7%89%874.6.jpg"></p><p>以下为两个ICMP的应用：</p><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo （Type类型为8，code类型为0）请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 报文段，并由目的主机发送终点不可达ICMP差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（Type3 code3）。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6.IPv6"></a>6.IPv6</h2><p>为了解决IPv4地址不够用的问题，IPv6将IP地址长度从32比特增加到128比特，且IPv6数据报的首部被固定为40字节。IPv6也不允许在中间路由器上进行分片和重新组装，这种操作只能在源和目的地上执行。</p><h3 id="IPv4向IPv6的过渡："><a href="#IPv4向IPv6的过渡：" class="headerlink" title="IPv4向IPv6的过渡："></a>IPv4向IPv6的过渡：</h3><p>IPv4向IPv6的过渡有两种方式，分别为双栈方法（dual-stack）和使用隧道（tunneling）</p><p><strong><em>双栈方法</em></strong>：<br>使用双栈方法的IPv6节点具有完整的IPv4实现，它具有发送和接受IPv4和IPv6两种数据报的能力。但是这种方法有一个缺点：如下/img/图片所示：如果不适用隧道的话，即使E和F之间能交换IPv5数据报，但从D到E的IPv4数据报中并不含有从A发出的初始IPv6数据报中的所有字段。因此E和F之间也只能交换IPv4.</p><p><strong><em>使用隧道</em></strong>：  </p><p><img src="/img/%E5%9B%BE%E7%89%874.7.jpg"></p><p>我们将两台IPv6路由器之间中间IPv4路由器的集合称为一个隧道(tunnel),借助于隧道，在隧道发送端的IPv6节点（如B）可将整个IPv6数据报放到一个IPv4数据报的数据(data)字段中。于是，该IPv4数据报的地址设为指向隧道接受端的IPv6节点(如E)。</p><p>在隧道接受端的IPv6节点最终收到该IPv4数据报，并确定该IPv4数据报含有一个IPv6数据报，于是从中取出IPv6数据报，再为该IPv6数据报提供路由，就好像它是从一个直接相连的IPv6邻居那里接收到该IPv6数据的一样。</p><h2 id="7-路由选择算法"><a href="#7-路由选择算法" class="headerlink" title="7.路由选择算法"></a>7.路由选择算法</h2><p>路由选择算法的目的：给定一组路由器以及连接路由器的链路，路由选择算法要找到一条从源路由器到目的路由器的最好路径。</p><p>其分为两类；</p><ul><li>全局式路由选择算法：用完整的、全局的网络信息计算出从源到目的地之间的最低费用路径。具有这种全局信息的算法常被称作<strong>链路状态(link state,LS)算法</strong></li><li>分散式路由选择算法： 没有节点拥有关于所有网络链路费用的完整信息，每个节点仅有与其直接相连链路的费用信息便可开始计算。常被称作<strong>距离向量(distance-vector,DV)算法</strong></li></ul><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。在一个AS内部，所有路由器运行同样的自治系统内部路由选择协议。在各AS之间，AS运行相同的AS间路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰者模式</title>
    <link href="/2021/02/15/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/02/15/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态地为对象扩展功能。</p><p>在扩展功能这一方面，装饰者模式比继承更有弹性</p><p><img src="/img/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>实现背景</strong>：一家咖啡店有多种饮料(如咖啡、豆浆），还有多种调料可以添加（如Whip、Mocha）。每种饮料都有一个基础价格，加完调料后，价格即为基础价格加上调料价格。要求我们要计算一杯加过调料的饮料的价格。</p><p>所有的装饰者和被装饰者都要继承自抽象类Beverage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    String description;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象调料类（装饰者），所有的调料类都需继承自这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CondimentDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-comment">//beverage为被装饰者的引用</span><br>    <span class="hljs-keyword">protected</span> Beverage beverage;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下为两个调料类(装饰者类)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以下是两个调料类（装饰者）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mocha</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage = beverage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Mocha&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Whip</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Whip</span><span class="hljs-params">(Beverage beverage)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.beverage = beverage;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, Whip&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是两个饮料类（被装饰者类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Coffee</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Coffee&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Soybean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Soybean</span><span class="hljs-params">()</span></span>&#123;<br>        description = <span class="hljs-string">&quot;Soybean&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.6</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    Beverage beverage = <span class="hljs-keyword">new</span> Soybean();<br>    beverage = <span class="hljs-keyword">new</span> Mocha(beverage);<br>    beverage = <span class="hljs-keyword">new</span> Whip(beverage);<br>    System.out.println(beverage.getDescription() + <span class="hljs-string">&quot;, $&quot;</span> + beverage.cost());<br>    Beverage beverage2 = <span class="hljs-keyword">new</span> Coffee();<br>    beverage2 = <span class="hljs-keyword">new</span> Mocha(beverage2);<br>    beverage2 = <span class="hljs-keyword">new</span> Whip(beverage2);<br>    System.out.println(beverage2.getDescription() + <span class="hljs-string">&quot;, $&quot;</span> + beverage2.cost());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2021/02/15/%E9%94%81/"/>
    <url>/2021/02/15/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</p><h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。但锁的各种操作(获取锁、释放锁、检查锁状态)都会增加系统开销。因此锁的粒度越小，系统开销就越大。因此在选择锁的粒度时，需要在锁开销和并发程度做平衡。</p><p>MySQL数据库根据锁的粒度把锁分为表级锁和行级锁:</p><ul><li>表级锁：对当前操作的整张表加锁。锁的粒度大，系统开销小，加锁快，不会出现死锁。但发生锁冲突的概率高，并发程度低。</li><li>行级锁：只对当前操作的行进行枷锁。锁的粒度小，系统开销大，加锁慢，会出现死锁。但能大大减少数据库操作的冲突，并发度高。</li></ul><p>InnoDB支持行级锁和表级锁，默认为行级锁。而MyISAM存储引擎支持表级锁。</p><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>InnoDB实现了以下两种标准的行级锁：</p><ul><li>共享锁（S Lock）：也叫读锁。如果一个事务获得数据对象A的S锁，就可以对A进行读操作，但是不能进行写操作，加锁期间其他事务也可以获得A的S锁并读取它。但任何事务都不能获取数据上的X锁，直到A已释放所有共享锁。</li><li>排他锁（X Lock）：也叫写锁。如果一个事务获得数据对象A的X锁，就可以对A进行读和写操作。加X锁期间其他事务不能对A加任何锁，因此叫排他锁。</li></ul><p>锁的兼容性可以理解为：同一个数据对象可否同时获得两个不同的锁：</p><p><img src="/img/%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B.jpg"></p><p>为了支持在更细粒度上进行加锁，InnoDB支持意向锁。意向锁将锁定的对象分为多个层次。如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。</p><p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。</p><p>而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p><p>意向锁是一种表锁，分为如下两种：</p><ul><li>意向共享锁（IS Lock）：表示事务准备给数据行记入共享锁，一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁。</li><li>意向共享锁（IX Lock）：表示事务准备给数据行加入排他锁，一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>注意：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</li></ul><h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过锁机制实现了事物的隔离性要求，使事物可以并发地工作。但在并发情况下，多个事物同时对同一事物进行操作，会带来以下几种并发不一致问题：</p><h3 id="1-丢失更新"><a href="#1-丢失更新" class="headerlink" title="1.丢失更新"></a>1.丢失更新</h3><p>即一个事务的更新操作会被另一个事务的更新操作所覆盖。例如；事务T1先将行记录r更新为v1，事务T2再将记录r更新为v2（当前两事务均为提交）。随后事务T1先提交，事务T2后提交。则最终记录r即为v2，事务T2的修改覆盖了事务T1的修改。</p><h3 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h3><p>要理解脏读，首先要理解脏数据。</p><p>脏数据是指事物对缓冲池中行记录的修改，并且还没有提交(commit)。(它和脏页不同，后者是在缓冲池中已经修改，但还没有刷新到硬盘中的页)</p><p>脏读指的是在不同的事物下，<strong>当前事务可以读到另外一个事物未提交的数据</strong>。</p><p>例如：事物1修改了数据但并未提交，事物2随后读取了这个数据，之后如果事物1回滚了此次修改，事物2读到的就是不正确的数据。</p><h3 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h3><p>不可重复读是指在一个事物内多次读取同一数据集合，在这个事物还没有结束时，另一个事物也访问了该数据集合并做了一些修改。因此，由于第二个事物的修改，第一个事物两次读取到的数据可能是不一致的。</p><p>例如：事物1先读取一次数据，之后事物2对数据进行了修改并提交，这样事物1再次读取这个数据时，读取结果就和第一次不同。</p><p>不可重复读和脏读的区别：</p><ul><li>脏读读到的是未提交的数据，不可重复读读到的是已提交的数据</li><li>脏读违反了数据库事物的隔离性，不可重复读违反了数据库事物的一致性。</li></ul><h3 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h3><p>幻读和不和重复读类似，是指当一个事务T1读取了几行数据后，另一个并发事务T2插入了一些数据，因此在之后的查询中，事务T1就会发现多了一些原本不存在的记录。</p><p>幻读和不可重复读的区别：</p><ul><li>幻读的关注点在于增删，比如多次读取一条记录发现记录增多或减少了。</li><li>不可重复读的关注点在于修改，比如多次读取一条记录发现其中某些列的值被修改。</li></ul><p>产生并发不一致问题的主要原因是破坏了事务的隔离性，数据库系统提供了多种事务的隔离级别供用户解决并发一致性问题。</p><h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><p>InnoDB存储引擎有三种行锁的算法，分别是：</p><ul><li>Record Lock:锁定一个记录上的索引，而不是记录本身。</li><li>Gap Lock:间隙锁，锁定索引间的间隙(一个范围)，但不包含索引本身(为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生)</li><li>Next-Key Lock: Record Lock和Gap Lock的结合。不仅锁定一个记录上的索引，也锁定索引之间的间隙。（InnoDB存储引擎使用这个机制来避免幻读,在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。）</li></ul><p>例如索引包含以下值：10，11，13，20。采用Next-Key Lock。那么将锁定如下区间：</p><pre><code>(-∞,10][10,11)[11,13)[13,20)[20,+∞]</code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务</p><h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h2><p>一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式(multi versioning)的方式来读取当前执行时间数据库中行的数据。具体为：如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待该行上锁的释放。相反地、InnoDB存储引擎会去读取行的一个快照数据。</p><p>快照数据其实就是当前行数据之前的历史版本（通过undo来实现，快照数据不需要上锁，因为没有事物需要对历史数据进行修改操作），每行数据可能有多个快照数据（多个历史版本），一般称这种技术为行多版本技术，由此带来的并发控制，称为多版本并发控制。</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照（历史版本）。</p><p>MVCC可以实现提交读READ COMMITTED和可重复读REPEATABLE READ两种隔离级别。</p><ul><li>在READ COMMITTED隔离级别下，总是读取行的最新版本，如果行被锁定了（被另一个事物使用），则读取该行版本的一个快照。</li><li>而对于REPEATABLE READ的事物隔离级别，总是读取事务开始时的行数据版本。</li></ul><p>而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><ul><li>MVCC的SELECT操作读的是快照中的数据，不需要进行加锁操作。</li><li>MVCC的对于数据库进行修改的操作(INSERT、UPDATE、DELETE)需要读取最新的数据，因此需要进行加锁操作。</li><li>此外，在进行SELETE操作时，可以强制指定进行加锁操作。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的行记录加一个X锁，其他事物就不能对该行加上任何锁<br>SELETE...for update<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加一个S锁，其他事物可以向被锁定的行加S锁，但如果加X锁，则会被阻塞。<br>SELETE...lock <span class="hljs-keyword">in</span> share mode<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 第2版[M]. 机械工业出版社, 2013.</li><li><a href="https://blog.csdn.net/qq_34337272/article/details/80611486">MySQL锁机制</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">Cyc2018:数据库系统原理</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md#%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8Einnodb%E9%94%81%E7%AE%97%E6%B3%95">JavaGuide；MySQL</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机</title>
    <link href="/2021/02/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2021/02/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h1><p><img src="/img/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="Java运行时数据区"></p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<br>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p><h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的线程内存模型。每个方法被执行的时候，Java虚拟机会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直到执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。</p><p>该区域可能抛出的异常：</p><ul><li>若线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li><li>若Java虚拟机的栈容量可以动态扩展，当栈扩展至无法申请到足够的内存会抛出OutOfMemoryError异常</li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p>本地方法栈和Java虚拟机栈类似，只是本地方法栈为执行本地方法服务，虚拟机栈为执行Java方法服务。<br>注：本地方法一般是用其他语言（C、C++、汇编）编写的，并且被编译为基于本机硬件和操作系统的程序。</p><h2 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h2><p>此区域的唯一目的就是存放对象实例，它也是垃圾收集器管理的内存区域。<br>Java堆在虚拟机启动时创建，被所有线程共享，是虚拟机管理的内存区域中最大的一块。</p><p>现代的垃圾收集器基本都采用分代收集算法，即针对不同类型的对象采取不同的垃圾回收策略。因此可以把Java堆分成新生代和老生代这两部分区域。</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p>用于存放类相关的信息，如类名、常量、静态变量、方法描述、即时编译器编译后的代码等数据。被所有线程共享。<br>这个区域的垃圾回收的主要目标是对常量池的回收和对类的卸载。</p><p>运行时常量池也是方法区的一部分，class文件中的常量池会在类加载后被放入这个区域。</p><h2 id="对象的创建、内存布局和访问"><a href="#对象的创建、内存布局和访问" class="headerlink" title="对象的创建、内存布局和访问"></a>对象的创建、内存布局和访问</h2><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h3><ul><li>给对象分配内存（两种方法：指针碰撞、空闲列表）</li><li>将分配到的内存空间都初始化为零值</li><li>用构造函数根据使用者的意愿对对象进程初始化</li></ul><h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中的存储布局可以分为以下三部分：</p><ul><li>对象头：包括Mark Word（哈希码、GC分代年龄等）和类型指针（虚拟机通过这个指针来确定该对象是哪个类的实例）</li><li>实例数据：对象真正存储的有用信息</li><li>对齐填充；任何对象的大小都必须是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通过填充对齐来补全。</li></ul><h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h3><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。对象的访问方式有以下两种：</p><ul><li>使用句柄访问：reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息。好处是reference存储的是稳定句柄地址，在对象被移动时只会改变句柄的实例数据指针，而reference本身不需要修改。</li><li>直接指针访问；reference中存储的直接就是对象地址。好处是节省了一次指针定位的时间开销，访问速度更快。</li></ul><p><img src="/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="对象的访问定位"></p><p>内存溢出和内存泄漏的区别：</p><ul><li>内存泄漏：已经分配的堆内存由于某些原因无法释放</li><li>内存溢出：没有足够的内存再供分配了</li></ul><h1 id="二、垃圾收集与内存分配"><a href="#二、垃圾收集与内存分配" class="headerlink" title="二、垃圾收集与内存分配"></a>二、垃圾收集与内存分配</h1><p>在Java的内存区域中：程序计数器、虚拟机栈、本地方法栈这三个区域属于线程私有，当线程结束时内存自然就跟着回收了。因此只需要对Java堆和方法区进行垃圾收集。</p><h2 id="判断哪些对象需要被回收"><a href="#判断哪些对象需要被回收" class="headerlink" title="判断哪些对象需要被回收"></a>判断哪些对象需要被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加一；当引用失效时，计数器就减一；计数器为0的对象可被回收。</p><p>缺陷：当两个对象存在循环引用时，引用计数器永不为0，导致无法对这两个对象进行回收。  正是因为这个缺陷的存在，Java虚拟机不使用引用计数算法来判断对象的存活与否。</p><p>例如：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h3><p>Java虚拟机使用可达性分析算法判断对象是否可被回收。其以GC Roots作为起始节点集开始根据引用关系向下搜索，可达的对象存活，不可达的对象可被回收。</p><p>GC Roots包括如下：</p><ul><li><p>虚拟机栈中引用的对象</p></li><li><p>方法区中类静态属性所引用的对象（例如引用类型静态变量）</p></li><li><p>方法区中常量引用的对象（字符串常量池中的引用）</p></li><li><p>所有被同步锁（synchronized关键字）所持有的对象</p></li><li><p>等等</p><p><img src="/img/GCRoot.jpg" alt="GCRoot.jpg"></p></li></ul><p><strong>四种引用关系：</strong></p><ul><li>强引用：使用new关键字创建的引用，例如Object obj = new Object()。只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。</li><li>软引用：在系统将要发生内存溢出异常之前，先将软引用关联的对象列进回收范围进行第二次回收。如果这次回收后还没获得足够的内存，才会抛出内存溢出异常。</li><li>弱引用：一旦垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象。</li><li>虚引用：又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</li></ul><p><strong>方法区的回收</strong><br>方法区的垃圾收集主要回收废弃的常量和不再使用的类型。</p><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。<br>设计者一般至少会把Java堆划分为新生代和老生代两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老生代中存放。</p><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h3><p>步骤：</p><ul><li>首先标记出所有需要回收的对象</li><li>在标记完成后，统一回收所有被标记的对象</li></ul><p>缺点：</p><ul><li>执行效率不稳定（标记和清除两个过程的执行效率随对象数量增长而降低）</li><li>会产生大量的内存碎片，导致无法给大对象分配内存</li></ul><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></p><h3 id="2-标记-复制算法"><a href="#2-标记-复制算法" class="headerlink" title="2.标记-复制算法"></a>2.标记-复制算法</h3><p>此算法主要针对新生代。它将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img src="/img/%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="标记复制算法"></p><p>现在的商业虚拟机大都采用这种收集算法回收新生代的内存，但是并不是划分为大小相等的两块，而是把新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（老年代）进行分配担保，即借用老年代的空间存储放不下的对象。</p><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h3><p>此算法主要针对老年代。其中的标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p>此算法缺点在于：需要移动大量对象，处理效率比较低。优点在于不会产生内存碎片。</p><p><img src="/img/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></p><p>Java虚拟机为什么要划分为新生代和老年代？<br>分代收集可以让我们根据各个年代的特点选择合适的垃圾收集算法。在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="垃圾收集器"></p><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><p>Serial收集器是一个单线程工作的收集器。它在进行收集时，必须暂停所有工作线程，直到它收集结束。</p><p><img src="/img/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p><p>Serial收集器对运行在客户端模式下的虚拟机来说是很好的选择。因为这种场景下内存不会特别大，停顿时间可以接收</p><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><p>多线程版本的Serial收集器。</p><p>适用于服务端模式的新生代垃圾收集。除了Serial之外，只有它能和CMS配合使用。也可以理解为，ParNew合并入CMS，成为它专门处理新生代的组成部分。</p><p><img src="/img/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p><p><strong>并行和并发区分</strong>：  </p><ul><li>并行：并行描述的是多条垃圾收集器线程之间的关系</li><li>并发：并发描述的是垃圾收集器线程与用户线程之间的关系<h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3>吞吐量优先收集器</li></ul><p>其他垃圾收集器的目标是尽可能缩短垃圾收集时用户线程的停顿时间。而此收集器的目标是达到一个可以控制的吞吐量。吞吐量是指CPU用于运行用户代码的时间和总时间（运行用户代码时间+运行垃圾收集时间）的比值。</p><p>顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p><p>垃圾收集停顿时间的缩短是以牺牲吞吐量和新生代空间为代价获取的。（新生代空间变小，虽然每次的垃圾回收时间缩短，但是垃圾回收变得频繁，进而导致吞吐量下降）</p><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h3><p>Serial的老年代版本，同样是一个单线程收集器。它有两大用途：</p><ul><li><p>在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用</p></li><li><p>作为 CMS 收集器的后备方案</p><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本</p></li></ul><p><img src="/img/Parallel_Scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel Scavenge收集器"></p><p>在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的老年代收集器。它是基于标记-清除算法实现的。</p><p>分为以下四个步骤：</p><ol><li>初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程。耗时最长但是不需要停顿，可以与用户线程并发运行</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要停顿。</li><li>并发清除：清除掉已经标记的死亡对象，不需要停顿。</li></ol><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以和用户线程一起工作，所以从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><img src="/img/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p><p>缺点如下：</p><ol><li>基于标记-清除算法，会产生很多内存碎片。往往会出现老年代还有大量空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次Full GC的情况。</li><li>无法处理浮动垃圾。浮动垃圾是指并发标记和并发清理阶段由于用户线程继续运行而产生的垃圾。这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时清理。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，这样停顿时间就长了。</li><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3>G1(Garbage First)收集器是一款面向服务端应用的垃圾收集器。在多CPU和大内存场景下有很好的性能。</li></ol><p>G1收集器不像其他收集器一样只对新生代或老年代进行回收，它可以直接对新生代和老年代一起回收。衡量标准不再是它属于哪一个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。这就是G1收集器的Mixed GC模式。</p><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），收集器能够对扮演不同角色的Region采用不同的策略处理。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>G1收集器的工作步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收<br>除了并发标记以外，其余步骤都要完全暂停用户线程<br><img src="/img/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器"></li></ul><p>G1收集器的特点：</p><ul><li>可预测的停顿：G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定消耗在 GC 上的时间不得超过 N 毫秒</li><li>空间整合：G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</li></ul><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><ul><li>对象优先在新生代的Eden上分配，当Eden空间不够时，发起MinorGC</li><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li></ul><hr><h1 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a>三、类加载机制</h1><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中才能被运行和使用。而虚拟机如何加载这些Class文件、Class文件中的信息进入到虚拟机中会发生什么变化，这些是类加载机制要处理的内容。</p><p>虚拟机的类加载机制：Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类。</p><p>在Java中，类加载是在程序运行期间完成的。即，第一次使用到一个类时才对其进行加载，而不是一次性加载所有类（会占用很大的内存）</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/img/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="类的生命周期"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类的生命周期中前五个阶段：加载、验证、准备、解析、初始化构成了类加载过程。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>在加载阶段，Java虚拟机完成了以下三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（可以通过ZIP包、网络、数据库等途径获取）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li></ul><p>数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。此外所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p>确保Class文件的字节流中包含的信息符合要求，不会危害虚拟机自身的安全。</p><p>Class文件并不一定只能从Java源码编译而来，虽然Java语言本身相对安全，但Java无法做到的事情在字节码层面上却有可能实现。所以如果虚拟机不检查输入的字节流的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致系统收到攻击。</p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><p>准备阶段是正式为类中定义的变量（静态变量）在方法区中分配内存并设置类变量初始值（通常为零值）的阶段。</p><p>注意：这个阶段只为静态变量分配内存，实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。因为实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p><p>在准备阶段设置的初始值一般为零值，例如下面的value变量在这个阶段将被初始化为0(之后的初始化阶段才会被具体赋值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>特殊情况：如果value是常量，那么它就会被初始化为表达式所定义的值123</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><p>解析阶段是Java虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>例如：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析阶段符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><p>在初始化阶段，Java虚拟机才真正开始执行类中编写的Java代码，将主导权从虚拟机移交给应用程序。</p><p>初始化阶段是执行类构造器 &lt; clinit &gt;() 的过程。在准备阶段，类变量已经赋过一次系统要求的初始零值，而在初始化阶段，根据使用者通过程序制定的主观计划去初始化类变量和其它资源。</p><p>&lt; clinit &gt;() 是由编译器自动收集类中所有静态变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        i = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 给变量赋值可以正常编译通过</span><br>        System.out.print(i);  <span class="hljs-comment">// 这句编译器会提示“非法向前引用”</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚拟机会保证一个类的 &lt; clinit &gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt; clinit &gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt; clinit &gt;() 方法完毕。</p><h2 id="类加载器与双亲委派模型"><a href="#类加载器与双亲委派模型" class="headerlink" title="类加载器与双亲委派模型"></a>类加载器与双亲委派模型</h2><p>Java虚拟机的设计者将类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader)</p><p>每一个类加载器，都有一个独立的类命名空间。即使两个类来源于同一个Class文件，被同一个Java虚拟机加载，但只要加载它们的类加载器不同，那这两个类就必定不相等。（两个类相互独立）</p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>从Java虚拟机的角度看，类加载器只分为以下两种：</p><ul><li>启动类加载器（Bootstrap ClassLoader)：使用C++实现，是虚拟机自身的一部分。</li><li>其他类加载器：使用Java语言实现，独立于虚拟机之外，全部继承自抽象类java.lang.ClassLoader</li></ul><p>从Java开发人员的角度看，类加载器可以分为以下的三层类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader): 这个加载器将存放在 <JAVA_HOME>\lib 目录下的，能被虚拟机识别的类库加载到虚拟机内存中（按照文件名识别，如 rt.jar）。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</li><li>扩展类加载器（Extension ClassLoader)：这个加载器将 <JAVA_HOME>/lib/ext 目录中的、或者被 java.ext.dir 系统变量所指定的路径中所有的类库加载到虚拟机内存中。由于类加载器是Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application ClassLoader)：也称为“系统类加载器”，它负责加载用户类路径（ClassPath）上所有的类库。开发者同样可以直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>Java应用通过以上三种类加载器的相互配合来完成类加载，此外用户也可以加入自定义的类加载器来进行拓展。类加载器的层次关系如下所示，这种关系被称为双亲委派模型：</p><p><img src="/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。注意：类加载器的父子关系不是以继承(is-a)来实现的，而是以组合(has-a)来实现的。</p><p><strong>工作过程</strong>：<br>每个类加载器都先将类加载请求委派给父类加载器去处理，所以最后所有的加载请求都传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，自加载器才会尝试自己去完成加载。</p><p>Java官方API文档的描述如下：</p><blockquote><p>The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a “parent” class loader. When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p></blockquote><p><strong>好处</strong><br>Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，可以使基础类得到统一。</p><p>例如：存放在rt.jar中的类java.lang.Object，无论哪一个类加载器要加载这个类，最终都将委派给处于模型顶端的启动类加载器进行加载，因此能保证程序中加载的所有的Object类都是同一个类（正如前述：相同的类文件被不同的类加载器加载产生的是两个不同的类）。</p><p>反之，如果没有双亲委派模型，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，它将会被应用程序类加载器加载，这样程序中就会有多个Object类，造成混乱。</p><p><strong>实现</strong><br>双亲委派模型的代码全部集中在java.lang.ClassLoader的loadClass()方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>        <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过了</span><br>        Class c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c = findBootstrapClassOrNull(name);<br>            &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// 如果父类加载器抛出ClassNotFoundException</span><br>                <span class="hljs-comment">// 说明父类加载器无法完成加载请求</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 在父类加载器无法加载时</span><br>                <span class="hljs-comment">// 再调用本身的findClass方法来进行类加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);<br>    &#125;<br>&#125;<br>loadClass()方法的运行逻辑：先检查请求加载的类是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。只有当父加载器加载失败，抛出ClassNotFoundException异常时，才调用自己的findClass()方法尝试进行加载。<br></code></pre></td></tr></table></figure><p><strong>自定义类加载器</strong><br>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，就需要继承 ClassLoader。</p><ul><li>如果想打破双亲委派模型，就需要重写loadClass()方法，因为双亲委派模型的逻辑是由loadClass()方法体现的。</li><li>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2019.</li><li><a href="https://github.com/CyC2018/CS-Notes">Cyc2018/CS-Nodes</a></li><li><a href="https://github.com/Snailclimb/JavaGuide">Snailclimb/JavaGuide</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2021/02/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/02/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使得每个进程各运行几十或几百个毫秒。严格地说，在某一瞬间，CPU只能运行一个进程。但在1秒钟期间，它可能运行多个进程，这样就产生并行的错觉。</p><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><p>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p><p><img src="/img/%E5%9B%BE2.1.jpg" alt="avatar"></p><p>停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程成为守护进程。</p><h3 id="进程的层次："><a href="#进程的层次：" class="headerlink" title="进程的层次："></a>进程的层次：</h3><p>当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。（注意：父进程和子进程有着不同的地址空间）</p><p>在UNIX中，进程和它的所有子女以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组的所有成员。而Windows中没有进程层次的概念。</p><h3 id="进程的状态："><a href="#进程的状态：" class="headerlink" title="进程的状态："></a>进程的状态：</h3><p>进程的三个状态为：</p><ul><li>运行态（该时刻进程实际占用CPU）</li><li>就绪态（可运行，但由于其他进程正在运行而暂时停止）</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）</li></ul><p><img src="/img/%E5%9B%BE2.2.jpg" alt="avatar"></p><p>调度程序的主要工作就是决定应当运行哪个进程、何时运行以及它应该运行多长时间（即/img/图中的转换2和转换3）</p><h3 id="进程的实现："><a href="#进程的实现：" class="headerlink" title="进程的实现："></a>进程的实现：</h3><p>为了实现进程模型，操作系统维护着一张进程表（process table)。每个进程占用一个进程表项。该表象包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配情况、所打开文件的状态和调度信息，以及其他在进程中运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><h3 id="2-1-线程概述"><a href="#2-1-线程概述" class="headerlink" title="2.1 线程概述"></a>2.1 线程概述</h3><p>线程是独立调度的基本单位。传统的操作系统中，每个进程有一个地址空间，并且只有一个控制线程。但由于以下原因需要使用多线程：  </p><ol><li>多个线程之间共享同一个地址空间和所有可用数据。</li><li>由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销。</li><li>若多个线程都是CPU密集的，那么并不能获得性能的增强。但如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，可以加快应用程序执行的速度。</li></ol><p>例如：假设字处理软件被编写为含有两个线程的程序。一个线程与用户交互，而另一个线程在后台重新进行格式处理。一旦第一页的语句被删除掉，交互线程就立即通知格式化线程对整本书重新进行处理。进一步考虑，可以再增加一个处理磁盘备份的线程。<br>如果程序是单线程的，那么在进行磁盘备份时，来自键盘和鼠标的交互命令就会被忽略，直到备份工作停止为止。如果使用三个线程，程序设计模型就很简单了。第一个和线程只是和用户交互；第二个线程在得到通知时进行文档的重新格式化；第三个线程周期性地将RAM中的内容写到磁盘上。<br>但是在这里若使用三个进程是行不通的，这是因为三个线程都需要在同一个文件上进行操作。通过让三个线程代替三个进程，三个线程共享公共内存，于是它们都可以访问同一个正在编辑的文件。</p><p>再例如，对于那些必须处理极大量数据的应用。通常的单线程处理方式是，读进一块数据、对其处理、然后再写出数据。这里的问题是，如果只能使用阻塞系统调用，那么在数据写入和数据输出时，会阻塞进程。而在有大量计算需要处理的时候，让CPU空转显然是浪费，应该尽可能避免。<br>但多线程提供了一个解决方案，有关的进程可以用一个输入线程、一个处理线程和一个输出线程构造。输入线程把数据读入到输入缓存区中，处理线程从输入缓存区读取数据、处理数据、并把结果放到输出缓存区中；处理线程从输入缓存区中读取数据、处理数据、并把结果放到输出缓存区中；输出线程再把这些结果写道磁盘上。按照这种方式工作，输入、处理和输出可以全部同时进行。当然，这种模型只有当系统调用只阻塞调用线程而不是调用进程时，才能正常工作。  </p><h3 id="2-2-经典的线程模型"><a href="#2-2-经典的线程模型" class="headerlink" title="2.2 经典的线程模型"></a>2.2 经典的线程模型</h3><p>理解进程的一个角度是：用某种方法把相关的资源集中在一起，进程有存放程序正文和数据以及其他资源的地址空间。另一个概念是：进程拥有一个执行的线程(thread)。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。</p><p>可以这样理解：**<em>进程用于把资源集中在一起，而线程则是在CPU上被调度执行的实体。**</em><br>即：在同一进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘、打印机和其他资源。</p><p><img src="/img/%E5%9B%BE2.3.jpg" alt="avatar"></p><p>进程中的不同线程不像不同进程之间那样存在着很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写、甚至清除另一个线程的堆栈。</p><ul><li>线程概念试/img/图实现的是：共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一个任务而共同工作。</li><li>由于每一个线程都会调用不同的过程，从而有一个各自不同的执行历史，因此每个线程都有其自己的堆栈</li><li>所有线程都是平等的，不论有无层次关系。</li></ul><h3 id="2-3-线程的实现方式"><a href="#2-3-线程的实现方式" class="headerlink" title="2.3 线程的实现方式"></a>2.3 线程的实现方式</h3><ul><li>在用户空间实现线程：此时，每个进程都有一个其专用的线程表(thread table)，用来跟踪该进程中的线程。</li><li>在内核实现线程：每个进程中没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。</li></ul><p><img src="/img/%E5%9B%BE2.4.jpg" alt="avatar"></p><h2 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3.进程间通信"></a>3.进程间通信</h2><h3 id="3-1-临界区"><a href="#3-1-临界区" class="headerlink" title="3.1 临界区"></a>3.1 临界区</h3><p>即：**<em>对共享内存进行访问的程序片段**</em></p><p>如果两个或多个进程同时读写某些共享数据，其最后的结果会取决于进程运行的精确时序，称为竞争条件(race condition)。</p><p>要避免竞争条件，关键是要找出某种途径来阻止多个进程同时读写共享的数据。换言之，我们需要的是互斥(mutual exclusion),即以某种手段确保当一个进程使用一个共享变量或文件时，其他进程不能做同样的操作。</p><h3 id="3-2-同步与互斥"><a href="#3-2-同步与互斥" class="headerlink" title="3.2 同步与互斥"></a>3.2 同步与互斥</h3><ul><li>互斥： 当一个进程在临界区内更新共享内存时，其他进程将不会进入其临界区。即：多个进程在同一时刻只有一个进程能进入临界区。</li><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li></ul><p>注：连续测试一个变量直到某个值出现为止，称为忙等待(busy waiting)。由于这种方式浪费CPU时间，所以通常应该避免。</p><h3 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。如果每个进程在进入临界区前都执行一个down操作，并在退出后都执行一个up操作，就能够实现互斥。</p><ul><li>  <strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>  <strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。所谓原语，即原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<br>semaphore mutex = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P1</span><span class="hljs-params">()</span> </span>&#123;<br>    down(&amp;mutex);<br>    <span class="hljs-comment">// 临界区</span><br>    up(&amp;mutex);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P2</span><span class="hljs-params">()</span> </span>&#123;<br>    down(&amp;mutex);<br>    <span class="hljs-comment">// 临界区</span><br>    up(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-互斥量"><a href="#3-4-互斥量" class="headerlink" title="3.4 互斥量"></a>3.4 互斥量</h3><p>互斥量（mutex）是信号量的一个简化版本。<br>互斥量是一种可以处于两态之一的变量：解锁和加锁。0表示解锁，其他所有的值则表示加锁。互斥量使用两个过程，当一个线程（或进程）需要访问临界区时，它调用mutex_lock。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入临界区，并且互斥量被自动锁定以防止其他线程进入。另一方面，如果该互斥量当前已经加锁，则调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock。</p><p><font size=3>   <strong>使用信号量实现生产者-消费者问题</strong>   </font> </br></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去，造成死锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore empty = N;<br>semaphore full = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        <span class="hljs-keyword">int</span> item = produce_item();<br>        down(&amp;empty);<br>        down(&amp;mutex);<br>        insert_item(item);<br>        up(&amp;mutex);<br>        up(&amp;full);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        down(&amp;full);<br>        down(&amp;mutex);<br>        <span class="hljs-keyword">int</span> item = remove_item();<br>        consume_item(item);<br>        up(&amp;mutex);<br>        up(&amp;empty);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-屏障"><a href="#3-5-屏障" class="headerlink" title="3.5 屏障"></a>3.5 屏障</h3><p>屏障这一同步机制是准备用于进程组而不是用于双进程的生产者-消费者类情形的。它规定：除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。</p><p>可以在通过每个阶段的结尾安置屏障(barrier)来实现这种行为，当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p><p><img src="/img/%E5%9B%BE2.5.jpg" alt="avatar"></p><h2 id="4-调度"><a href="#4-调度" class="headerlink" title="4.调度"></a>4.调度</h2><p>如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序(scheduler)，该程序使用的算法称为调度算法(scheduler algorithm)。</p><p>调度算法分为两类：</p><ul><li>非抢占式调度算法：先挑选一个进程，然后让该进程运行直至被阻塞，或者直到该进程自动释放CPU,即使该进程运行了若干个小时，它也不会被强迫挂起。</li><li>抢占式调度算法：先挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。</li></ul><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="4-1-批处理系统"><a href="#4-1-批处理系统" class="headerlink" title="4.1 批处理系统"></a>4.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1 先来先服务 first-come first-serverd（FCFS）</strong>  </p><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>2 短作业优先 shortest job first（SJF）</strong>  </p><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>3 最短剩余时间优先 shortest remaining time next（SRTN）</strong>  </p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="4-2-交互式系统"><a href="#4-2-交互式系统" class="headerlink" title="4.2. 交互式系统"></a>4.2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>1 轮转调度</strong><br>每个进程被分配一个时间片，允许该进程在该时间段内运行。如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换。</p><p>这个时间片若设计得过短，则会导致过多的进程切换，降低了CPU效率。若设计过程又可能引起对短的交互请求的响应时间边长。</p><p><strong>2 优先级调度</strong><br>核心思想：为每个进程分配一个优先级，按优先级进行调度。  </p><p>将一组进程按优先级分为若干类，并在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。<br>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><strong>3 多级队列</strong><br>属于最高优先级类的进程运行1个时间片，属于次高优先级类的进程运行2个时间片，再次以及运行4个时间片.以此类推，当一个进程用完分配的时间片后，它被移到下一个类。</p><h3 id="4-3-实时系统"><a href="#4-3-实时系统" class="headerlink" title="4.3 实时系统"></a>4.3 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="4-4-线程调度"><a href="#4-4-线程调度" class="headerlink" title="4.4 线程调度"></a>4.4 线程调度</h3><p>首先，对于用户级线程。由于内核并不知道有线程的存在，所以它还是像以前那样操作。在这种情况下，线程无时间片，进程有时间片。多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程运行。</p><p>其次，对于内核级线程。内核选择一个特定的线程运行，它不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，而且超过的时间片，就会强制挂起线程。</p><p><img src="/img/%E5%9B%BE2.6.jpg" alt="avatar"></p><p>此外，从进程A的一个线程切换到进程B的一个线程，其代价高于运行进程A的第2个线程（因为必须修改内存映像，清除内存高速缓存的内容）</p><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><h2 id="5-经典的IPC问题"><a href="#5-经典的IPC问题" class="headerlink" title="5.经典的IPC问题"></a>5.经典的IPC问题</h2><h3 id="5-1-生产者-消费者问题"><a href="#5-1-生产者-消费者问题" class="headerlink" title="5.1 生产者-消费者问题"></a>5.1 生产者-消费者问题</h3><p>如3.4节所述</p><h3 id="5-2-哲学家就餐问题"><a href="#5-2-哲学家就餐问题" class="headerlink" title="5.2 哲学家就餐问题"></a>5.2 哲学家就餐问题</h3><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。  </p><p><img src="/img/%E5%9B%BE2.7.jpg" alt="avatar"></p><p>一种错误的解法时，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h3 id="5-3-读者-写者问题"><a href="#5-3-读者-写者问题" class="headerlink" title="5.3 读者-写者问题"></a>5.3 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h2><p>为了隐蔽中断的影响，操作系统提供了一个由并行运行的顺序进程组成的概念模型。进程可以动态地创建和终止。每个进程都有自己的地址空间。</p><p>在一个进程中使用多个控制线程是有益的。这些线程被独立调度，每个线程都有自己的堆栈，但在一个进程中的所有线程共享一个公共地址空间。线程可以在用户空间或内核中实现。</p><p>进程之间通过进程间通信原语彼此童心，如信号量、管程和消息。这些原语用来确保同一时刻不会有两个进程在临界中。进程可以处在运行、就绪和阻塞状态。</p><p>进程间通信原语可以用来解决诸如生产者-消费者问题、哲学家就餐问题和读者-写者问题等。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
